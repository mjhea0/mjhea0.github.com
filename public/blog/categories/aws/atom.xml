<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Aws | Michael Herman]]></title>
  <link href="http://mherman.org/blog/categories/aws/atom.xml" rel="self"/>
  <link href="http://mherman.org/"/>
  <updated>2017-12-01T07:10:05-07:00</updated>
  <id>http://mherman.org/</id>
  <author>
    <name><![CDATA[Michael Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker on AWS: From Containerization to Orchestration]]></title>
    <link href="http://mherman.org/blog/2017/11/16/docker-on-aws-from-containerization-to-orchestration/"/>
    <updated>2017-11-16T08:23:24-07:00</updated>
    <id>http://mherman.org/blog/2017/11/16/docker-on-aws-from-containerization-to-orchestration</id>
    <content type="html"><![CDATA[<p>In this post, we&rsquo;ll take a number of containerized microservices running on a single EC2 instance and scale them out to Amazon&rsquo;s container orchestration service, <a href="https://aws.amazon.com/ecs/">EC2 Container Service</a> (ECS).</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/docker-aws/aws-docker.png" style="max-width: 100%; border:0; box-shadow: none;" alt="aws and docker">
</div>


<p><br></p>

<p>We&rsquo;ll be using the following tools&hellip;</p>

<table>
<thead>
<tr>
<th> Tool    </th>
<th> Use Cases              </th>
<th> Version                                                                </th>
</tr>
</thead>
<tbody>
<tr>
<td> Docker  </td>
<td> Containerization and distribution      </td>
<td> <a href="https://docs.docker.com/release-notes/docker-ce/#17090-ce-2017-09-26">17.09.0-ce</a>    </td>
</tr>
<tr>
<td> AWS ECS </td>
<td> Container orchestration and management  </td>
<td> <a href="https://github.com/aws/amazon-ecs-agent/releases/tag/v1.15.0">1.15.0</a> (service agent) </td>
</tr>
</tbody>
</table>


<p><em>Updates:</em></p>

<ul>
<li>Nov 25, 2017: Updated the Inbound Rules on the Security Group.</li>
</ul>


<h2>Contents</h2>

<ol>
<li>Prerequisites</li>
<li>Objectives</li>
<li>Project Setup</li>
<li>Containerization</li>
<li>Orchestration</li>
<li>Next Steps</li>
</ol>


<h2>Prerequisites</h2>

<p>This post assumes prior knowledge of Docker and some experience working with a Docker-based microservice stack. You should also be familiar with the following AWS services - <a href="https://aws.amazon.com/vpc/">VPC</a>, <a href="https://aws.amazon.com/elasticloadbalancing/">ELB</a>, <a href="https://aws.amazon.com/ec2/">EC2</a>, and <a href="https://aws.amazon.com/iam/">IAM</a>.</p>

<p>Refer to the following resources for more info:</p>

<ol>
<li><a href="http://mherman.org/blog/2017/05/11/developing-microservices-node-react-docker">Developing Microservices - Node, React, and Docker</a></li>
<li><a href="https://testdriven.io">Microservices with Docker, Flask, and React</a> - full course, powered by the fine folks at <a href="https://testdriven.io">testdriven.io</a>!</li>
</ol>


<h2>Objectives</h2>

<p>By the end of this tutorial, you will be able to&hellip;</p>

<ol>
<li>Explain what <em>container orchestration</em> is and why you may need to incorporate an orchestration tool into your deployment process</li>
<li>Discuss the pros and cons of using EC2 Container Service (ECS) over other <em>orchestration tools</em> like Kubernetes, Mesos, and Docker Swarm</li>
<li>Configure an <em>Application Load Balancer</em> (ALB) along with <em>ECS</em> to run a set of microservices</li>
<li>Integrate <em>Amazon EC2 Container Registry</em> (ECR) into the deployment process</li>
<li>Send <em>container logs</em> to CloudWatch</li>
<li>Update a running container via a <em>zero-downtime deployment</em> strategy to not disrupt the current users or your application</li>
<li>Explain the types of <em>scaling</em> that are available to you</li>
</ol>


<h2>Project Setup</h2>

<p>Fork the <a href="https://github.com/mjhea0/microservice-ping-pong">microservice-ping-pong</a> repo, clone it down, and then check out the <a href="https://github.com/mjhea0/microservice-ping-pong/releases/tag/v1">v1</a> tag to the master branch:</p>

<pre><code class="sh">$ git clone https://github.com/YOUR_GITHUB_NAME/microservice-ping-pong
$ cd microservice-ping-pong
$ git checkout tags/v1 -b master
</code></pre>

<p>Take note of the <em>docker-compose.yml</em> file to see an overview of the  project structure:</p>

<pre><code class="yaml">version: '3.3'

services:

  node-john:
    container_name: node-john
    build:
      context: ./services/node
      dockerfile: Dockerfile
    image: node-base
    ...

  node-paul:
    container_name: node-paul
    image: node-base
    ...

  node-george:
    container_name: node-george
    image: node-base
    ...

  node-ringo:
    container_name: node-ringo
    image: node-base
    ...

  client:
    container_name: node-client
    build:
      context: ./services/client
      dockerfile: Dockerfile
    ...

  nginx:
    container_name: node-nginx
    build: ./services/nginx
    ...
</code></pre>

<p>So, that&rsquo;s one Nginx container and one React container as well as four Node containers. Also, did you notice that we&rsquo;re using the same image to build each of the Node containers?</p>

<div style="text-align:left;">

<table style="margin:0;">
<thead>
<tr>
<th> Container    </th>
<th> Image    </th>
<th> Tech    </th>
</tr>
</thead>
<tbody>
<tr>
<td> node-john   </td>
<td> node-base </td>
<td> NodeJs  </td>
</tr>
<tr>
<td> node-paul   </td>
<td> node-base </td>
<td> NodeJS  </td>
</tr>
<tr>
<td> node-george </td>
<td> node-base </td>
<td> NodeJS  </td>
</tr>
<tr>
<td> node-ringo  </td>
<td> node-base </td>
<td> NodeJS </td>
</tr>
<tr>
<td> client      </td>
<td> client    </td>
<td> ReactJS </td>
</tr>
<tr>
<td> nginx       </td>
<td> nginx     </td>
<td> Nginx   </td>
</tr>
</tbody>
</table>

</div>




<p></p>


<p>Feel free to fire up the app locally:</p>

<pre><code class="sh">$ docker build -t node-base ./services/node
$ export REACT_APP_BASE_URL=http://DOCKER_MACHINE_IP
$ docker-compose up -d --build
</code></pre>

<p><a href="/images/blog/docker-aws/ping.png"><img src="/images/blog/docker-aws/ping.png" alt="ping pong app" /></a></p>

<p>The functionality is quite simple: When the end user clicks on one of the letters, an AJAX request is sent to the <code>node-john</code> container, which then triggers a series of container-to-container requests:</p>

<ol>
<li><code>node-john</code> requests <code>node-paul</code></li>
<li><code>node-paul</code> requests <code>node-george</code></li>
<li><code>node-george</code> requests <code>node-ringo</code></li>
</ol>


<p>Once complete, a response is sent back to the client with the following array:</p>

<pre><code class="json">[
  "meow from node-paul:3000",
  "meow from node-george:3000",
  "meow from node-ringo:3000"
]
</code></pre>

<p>Nothing special. Just a basic app, meant to highlight some aspects of how networking works in Docker land.</p>

<h2>Containerization</h2>

<p>Next, let&rsquo;s deploy the cluster to a single Amazon EC2 instance with Docker <a href="https://docs.docker.com/compose/">Compose</a> and <a href="https://docs.docker.com/machine/">Machine</a>.</p>

<h3>Docker Machine</h3>

<p>Assuming you already have an AWS account <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/get-set-up-for-amazon-ec2.html">setup</a> along with <a href="https://aws.amazon.com/iam/">IAM</a> and your AWS credentials are stored in an <em>~/.aws/credentials</em> file, create a new host on an EC2 instance:</p>

<pre><code class="sh">$ docker-machine create --driver amazonec2 ping-pong
</code></pre>

<blockquote><p>For more, review the <a href="https://docs.docker.com/machine/examples/aws/">Amazon Web Services (AWS) EC2 example</a> from Docker.</p></blockquote>

<p>Once done, set it as the active host and point the Docker client at it:</p>

<pre><code class="sh">$ docker-machine env ping-pong
$ eval $(docker-machine env ping-pong)
</code></pre>

<p>Grab the IP address associated with the new EC2 instance and use it to set the <code>REACT_APP_BASE_URL</code> environment variable:</p>

<pre><code class="sh">$ docker-machine ip ping-pong
$ export REACT_APP_BASE_URL=http://DOCKER_MACHINE_IP
</code></pre>

<blockquote><p>The <code>REACT_APP_BASE_URL</code> environment variable must be set at the build-time, so it is available <em>before</em> we kick off Create React App&rsquo;s production build process. See <em>services/client/Dockerfile</em> for more info.</p></blockquote>

<p>Build and tag the <code>node-base</code> image:</p>

<pre><code class="sh">$ docker build -t node-base ./services/node
</code></pre>

<p>Fire up the containers:</p>

<pre><code class="sh">$ docker-compose up -d --build
</code></pre>

<p>Make sure to expose port 80 in the <a href="https://stackoverflow.com/questions/26338301/ec2-how-to-add-port-8080-in-security-group">Security Group</a>, and then test it out in the browser:</p>

<div>
  <img src="http://mherman.org/images/blog/docker-aws/ping3.png" style="max-width: 80%; border:0; box-shadow: none;" alt="ping pong app">
</div>


<p>Back in your terminal, open the Docker <a href="https://docs.docker.com/compose/reference/logs/">logs</a> with a <a href="https://docs.docker.com/compose/reference/logs/">follow</a> flag:</p>

<pre><code class="sh">$ docker-compose logs -f
</code></pre>

<p>Then, with your terminal window and browser side-by-side on your screen, click on of the letters:</p>

<p><a href="/images/blog/docker-aws/ping2.png"><img src="/images/blog/docker-aws/ping2.png" alt="ping pong app" /></a></p>

<p>You should see a number of POST requests in the terminal, as the containers ping each other.</p>

<p>It&rsquo;s important to note that the majority of your apps can live on a single instance like this. Spin up Postgres on <a href="https://aws.amazon.com/rds/">RDS</a> and possibly a message queue on <a href="https://aws.amazon.com/sqs/">SQS</a> and you should be good for a while. As your app grows and you add feature after feature, you may that you need to create separate services and scale them independency from the whole. At that point, it may be time to start looking at ECS.</p>

<p>With that, let&rsquo;s look at how scale this out to multiple EC2 instances with <a href="https://aws.amazon.com/ecs/">ECS</a>&hellip;</p>

<h2>Orchestration</h2>

<blockquote><p>If you&rsquo;re completely new to ECS, please review the <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html">Getting Started with Amazon ECS</a> guide.</p></blockquote>

<h3>What is container orchestration?</h3>

<p>As you move from deploying containers on a single machine to deploying them across a number of machines, you need an orchestration tool to manage the arrangement and coordination of the containers across the entire system. This is where ECS fits in along with a number of other orchestration tools - like <a href="https://kubernetes.io/">Kubernetes</a>, <a href="http://mesos.apache.org/">Mesos</a>, and <a href="https://docs.docker.com/engine/swarm/">Docker Swarm</a>.</p>

<div>
  <img src="http://mherman.org/images/blog/docker-aws/kubernetes-vs-docker-swarm-vs-mesos.png" style="max-width: 40%; border:0; box-shadow: none;" alt="kubernetes vs docker swarm vs mesos">
</div>




<p></p>


<h3>Why ECS?</h3>

<p>ECS is simpler to set up and easier to use and you have the full power of AWS behind it, so you can easily integrate it into other AWS services (which we will be doing shortly). In short, you get scheduling, service discovery, load balancing, and auto-scaling out-of-the-box. Plus, you can take full advantage of EC2&rsquo;s multiple availability-zones.</p>

<p>If you&rsquo;re already on AWS and have no desire to leave, then it makes sense to use AWS.</p>

<p>Keep in mind, that ECS is often lagging behind Kubernetes, in terms of features, though. If you&rsquo;re looking for the most features and portability and you don&rsquo;t mind installing and managing the tool, then Kubernetes, Docker Swarm, or Mesos may be right for you.</p>

<p>One last thing to take note of is that since ECS is closed-source, there isn&rsquo;t a true way to run an environment locally in order to achieve  development-to-production parity.</p>

<blockquote><p>For more, review the <a href="https://blog.kublr.com/choosing-the-right-containerization-and-cluster-management-tool-fdfcec5700df">Choosing the Right Containerization and Cluster Management Tool</a> blog post.</p></blockquote>

<h3>Orchestration feature wish-list</h3>

<p>Most orchestration tools come with a core set of features. You can find those features below along with the associated AWS service&hellip;</p>

<table>
<thead>
<tr>
<th> Feature       </th>
<th> Info                  </th>
<th> AWS Service                         </th>
</tr>
</thead>
<tbody>
<tr>
<td> Health checks </td>
<td> Verify when a task is ready to accept traffic </td>
<td> ALB </td>
</tr>
<tr>
<td> Path-based routing </td>
<td> Forward requests based on the URL path </td>
<td> ALB </td>
</tr>
<tr>
<td> Dynamic port-mapping </td>
<td> Ports are assigned dynamically when a new container is spun up </td>
<td> ALB </td>
</tr>
<tr>
<td> Zero-downtime deployments </td>
<td> Deployments do not disrupt the users </td>
<td> ALB </td>
</tr>
<tr>
<td> Service discovery </td>
<td> Automatic detection of new containers and services </td>
<td> ALB, ECS </td>
</tr>
<tr>
<td> High availability </td>
<td> Containers are evenly distributed across Availability Zones </td>
<td> ECS </td>
</tr>
<tr>
<td> Auto scaling </td>
<td> Automatically scaling resources up or down based on fluctuations in traffic patterns or metrics (like CPU usage) </td>
<td> ECS </td>
</tr>
<tr>
<td> Provisioning </td>
<td> New containers should select hosts based on resources and configuration </td>
<td> ECS </td>
</tr>
<tr>
<td> Container storage </td>
<td> Private image storage and management </td>
<td> ECR </td>
</tr>
<tr>
<td> Container logs </td>
<td> Centralized storage of container logs </td>
<td> CloudWatch </td>
</tr>
<tr>
<td> Monitoring </td>
<td> Ability to monitor basic stats like CPU usage, memory, I/O, and network usage as well as set alarms and create events </td>
<td> CloudWatch </td>
</tr>
<tr>
<td> Secrets management </td>
<td> Sensitive info should be encrypted and stored in a centralized store </td>
<td> Parameter Store, KMS, IAM </td>
</tr>
</tbody>
</table>


<h3>Elastic Load Balancer</h3>

<p>The <a href="https://aws.amazon.com/elasticloadbalancing/">Elastic Load Balancer</a> distributes incoming application traffic and scales resources as needed to meet traffic needs.</p>

<p>A load balancer is one of (if not) the most important parts of your applications since it needs to always be up, routing traffic to healthy back-ends, and ready to scale at a moment&rsquo;s notice.</p>

<p>There are currently <a href="https://aws.amazon.com/elasticloadbalancing/details/#details">three types</a> of Elastic Load Balancers to choose from. We&rsquo;ll be using the Application Load Balancer since it provides support for <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/application/tutorial-load-balancer-routing.html">path-based routing</a> and <a href="https://aws.amazon.com/premiumsupport/knowledge-center/dynamic-port-mapping-ecs/">dynamic port-mapping</a> and it also enables zero-downtime deployments. The Application Load Balancer is one of those AWS services that makes ECS so powerful. In fact, before it&rsquo;s <a href="https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/">release</a>, ECS was not a viable orchestration solution.</p>

<p>To set up, click &ldquo;Load Balancers&rdquo; in the <a href="https://console.aws.amazon.com/ec2">EC2 Dashboard</a>. Click &ldquo;Create Load Balancer&rdquo;, and then select the &ldquo;Create&rdquo; button under &ldquo;Application Load Balancer&rdquo;.</p>

<h4>Configure Load Balancer</h4>

<ul>
<li>&ldquo;Name&rdquo;: <code>microservice-ping-pong-alb</code></li>
<li>&ldquo;VPC&rdquo;: Select the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/default-vpc.html">default VPC</a> to keep things simple</li>
<li>&ldquo;Availability Zones&rdquo;: Select at least two available subnets</li>
</ul>


<p><a href="/images/blog/docker-aws/configure-load-balancer1.png"><img src="/images/blog/docker-aws/configure-load-balancer1.png" alt="configure load balancer" /></a></p>

<h4>Configure Security Settings</h4>

<p>Skip this for now.</p>

<h4>Configure Security Groups</h4>

<p>Create a new <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html">Security Group</a> called <code>microservice-ping-pong-security-group</code>, making sure to open up port 80.</p>

<p><a href="/images/blog/docker-aws/configure-load-balancer2.png"><img src="/images/blog/docker-aws/configure-load-balancer2.png" alt="configure load balancer" /></a></p>

<h4>Configure Routing</h4>

<ul>
<li>&ldquo;Name&rdquo;: <code>microservice-ping-pong-client-tg</code></li>
<li>&ldquo;Port&rdquo;: <code>3000</code></li>
<li>&ldquo;Path&rdquo;: /</li>
</ul>


<p><a href="/images/blog/docker-aws/configure-load-balancer3.png"><img src="/images/blog/docker-aws/configure-load-balancer3.png" alt="configure load balancer" /></a></p>

<h4>Register Targets</h4>

<p>Do not assign any instances manually since this will be managed by ECS. Review and then create the new load balancer.</p>

<p>Once created, take note of the new Security Group:</p>

<p><a href="/images/blog/docker-aws/load-balancer.png"><img src="/images/blog/docker-aws/load-balancer.png" alt="aws ecs load balancer" /></a></p>

<p>With that, we also need to set up Target Groups and Listeners:</p>

<p><a href="/images/blog/docker-aws/elastic-load-balancing.png"><img src="/images/blog/docker-aws/elastic-load-balancing.png" alt="elastic load balancing " /></a></p>

<h3>Target Groups</h3>

<p><a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html">Target Groups</a> are attached to the Application Load Balancer and are used to route traffic to the containers found in the ECS Service.</p>

<p>You may have already noticed, but a Target Group called <code>microservice-ping-pong-client-tg</code> was already created when we set up the Application Load Balancer, so we just need to set up one more.</p>

<p>Within the <a href="https://console.aws.amazon.com/ec2">EC2 Dashboard</a>, click &ldquo;Target Groups&rdquo;, and then create the following Target Group:</p>

<ul>
<li>&ldquo;Target group name&rdquo;: <code>microservice-ping-pong-node-tg</code></li>
<li>&ldquo;Port&rdquo;: <code>3000</code></li>
<li>Then, under &ldquo;Health check settings&rdquo; set the &ldquo;Path&rdquo; to <code>/ping</code>.</li>
</ul>


<p><a href="/images/blog/docker-aws/configure-target-group.png"><img src="/images/blog/docker-aws/configure-target-group.png" alt="configure target groups" /></a></p>

<h3>Listeners</h3>

<p>Back on the &ldquo;Load Balancers&rdquo; page on the <a href="https://console.aws.amazon.com/ec2">EC2 Dashboard</a>, click the <code>microservice-ping-pong-alb</code> Load Balancer, and then select the &ldquo;Listeners&rdquo; tab. Here, we can add <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html">Listeners</a> to the load balancer, which are then forwarded to a specific Target Group.</p>

<p>There should already be a listener for &ldquo;HTTP : 80&rdquo;. Click the &ldquo;View/edit rules >&rdquo; link, and then insert three new rules:</p>

<ol>
<li>If <code>/</code>, Then <code>microservice-ping-pong-client-tg</code></li>
<li>If <code>/ping</code>, Then <code>microservice-ping-pong-client-tg</code></li>
<li>If <code>/start</code>, Then <code>microservice-ping-pong-client-tg</code></li>
</ol>


<p><a href="/images/blog/docker-aws/load-balancer-listeners.png"><img src="/images/blog/docker-aws/load-balancer-listeners.png" alt="aws ecr" /></a></p>

<h3>ECR</h3>

<p>Next, we&rsquo;ll set up <a href="https://aws.amazon.com/ecr/">EC2 Container Registry</a> (ECR), a private image registry.</p>

<p>Navigate to the <a href="https://console.aws.amazon.com/ecs">ECS Console</a>, click &ldquo;Repositories&rdquo; on the navigation pane, and then click the &ldquo;Create repository&rdquo; button. Add the following repositories, making sure to follow the build, tag, and push commands after each is created:</p>

<ol>
<li><code>microservice-ping-pong/client</code></li>
<li><code>microservice-ping-pong/node</code></li>
</ol>


<blockquote><p>Be sure to update the value of the <code>REACT_APP_BASE_URL</code> environment variable to the Load Balancer&rsquo;s &ldquo;DNS name&rdquo;.</p></blockquote>

<p>Example build, tag, and push:</p>

<pre><code class="sh">$ aws ecr get-login --no-include-email --region us-east-1
$ docker build -t microservice-ping-pong/client ./services/client
$ docker tag microservice-ping-pong/client:latest \
  AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/microservice-ping-pong/client:latest
$ docker push \
  AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/microservice-ping-pong/client:latest
</code></pre>

<h4>Why only two images?</h4>

<p>Well, we&rsquo;ll use the Application Load Balancer instead of Nginx in our stack so we won&rsquo;t need that image or container. For the Node containers, just like before, we can use one image to create all four containers since they are identical.</p>

<p><a href="/images/blog/docker-aws/ecr.png"><img src="/images/blog/docker-aws/ecr.png" alt="aws ecr" /></a></p>

<p>Did you notice that we tagged the image with <code>latest</code> in the example above? This is an anti-pattern. Tags can (and should) be used for version control as well as denoting which environment the image should belong to - like development, pre-prod/staging, or production.</p>

<p>For example, you could use both the commit git commit SHA1 hash (to associate the image back to a specific commit to help with debugging) along with and the environment name.</p>

<p><code>/$PROJECT/$ENVIRONMENT:$SHA1</code></p>

<h3>ECS</h3>

<p>The <a href="https://aws.amazon.com/ecs/">EC2 Container Service</a> (ECS) has four main components:</p>

<ol>
<li>Task Definitions</li>
<li>Tasks</li>
<li>Services</li>
<li>Clusters</li>
</ol>


<p>In short, Task Definitions are used to spin up Tasks that get assigned to a Service, which is then assigned to a Cluster.</p>

<p><img src="/images/blog/docker-aws/ecs.png" alt="ecs" /></p>

<h4>Clusters</h4>

<p>An <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_clusters.html">ECS Cluster</a> is just a group of EC2 container instances managed by ECS.</p>

<p>To create a Cluster, click &ldquo;Clusters&rdquo; on the <a href="https://console.aws.amazon.com/ecs">ECS Console</a> sidebar, and then click the &ldquo;Create Cluster&rdquo; button.</p>

<ol>
<li>&ldquo;Cluster name&rdquo;: <code>microservice-ping-pong-cluster</code></li>
<li>&ldquo;EC2 instance type&rdquo;: <code>t2.small</code></li>
<li>&ldquo;Number of instances&rdquo;: <code>2</code></li>
<li>&ldquo;Key pair&rdquo;: Select an existing <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html">Key Pair</a> or create a new one</li>
<li>Select the default VPC and the previously created Security Group along with the appropriate subnets</li>
</ol>


<p><a href="/images/blog/docker-aws/configure-cluster.png"><img src="/images/blog/docker-aws/configure-cluster.png" alt="configure cluster" /></a></p>

<p>Navigate to the Cluster once it&rsquo;s up, and then click the &ldquo;ECS Instances&rdquo; tab. From there, click the &ldquo;Actions&rdquo; dropdown and select &ldquo;View Cluster Resources&rdquo; to ensure all is well:</p>

<p><a href="/images/blog/docker-aws/cluster.png"><img src="/images/blog/docker-aws/cluster.png" alt="aws ecs cluster" /></a></p>

<h4>Task Definitions</h4>

<p><a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html">Task Definitions</a> define which containers make up the overall application and how much resources are allocated to each container. You can think of them as blueprints.</p>

<p>Within the <a href="https://console.aws.amazon.com/ecs">ECS Console</a>, click &ldquo;Task Definitions&rdquo; and then &ldquo;Create new Task Definition&rdquo;.</p>

<p>First, Update the &ldquo;Task Definition Name&rdquo; to <code>microservice-ping-pong-client-td</code> and then add a new container:</p>

<ul>
<li>&ldquo;Container name&rdquo;: <code>client</code></li>
<li>&ldquo;Image&rdquo;: <code>AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/microservice-ping-pong/client:latest</code></li>
<li>&ldquo;Memory Limits (MB)&rdquo;: <code>300</code> soft limit</li>
<li>&ldquo;Port mappings&rdquo;: <code>0</code> host, <code>3000</code> container</li>
</ul>


<blockquote><p>We set the host port for the client service to 0 so that a port is dynamically assigned when the Task is spun up.</p></blockquote>

<ul>
<li>&ldquo;Log configuration&rdquo;: It&rsquo;s a good idea to configure logs, via <a href="http://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_LogConfiguration.html">LogConfiguration</a>, to pipe logs to <a href="https://console.aws.amazon.com/cloudwatch/">CloudWatch</a>. To set up, we need to create a new Log Group. Simply navigate to <a href="https://console.aws.amazon.com/cloudwatch">CloudWatch</a>, click &ldquo;Logs&rdquo; on the navigation pane, click the &ldquo;Actions&rdquo; drop-down button, and then select &ldquo;Create log group&rdquo;. Name the group <code>microservice-ping-pong-client</code>.</li>
</ul>


<p><a href="/images/blog/docker-aws/configure-task-def.png"><img src="/images/blog/docker-aws/configure-task-def.png" alt="configure task def" /></a></p>

<p><a href="/images/blog/docker-aws/configure-task-def2.png"><img src="/images/blog/docker-aws/configure-task-def2.png" alt="configure task def" /></a></p>

<p>Then, set up a single Task Definition for each of the Node containers:</p>

<ul>
<li>&ldquo;Name&rdquo;: <code>microservice-ping-pong-node-td</code></li>
<li>&ldquo;Container&rdquo;:

<ul>
<li>&ldquo;Container name&rdquo;: <code>node-john</code></li>
<li>&ldquo;Image&rdquo;: <code>AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/microservice-ping-pong/node:latest</code></li>
<li>&ldquo;Memory Limits (MB)&rdquo;: <code>300</code> soft limit</li>
<li>&ldquo;Port mappings&rdquo;: <code>0</code> host, <code>3000</code> container</li>
<li>&ldquo;Links&rdquo;: <code>node-paul</code>, <code>node-george</code>, <code>node-ringo</code></li>
<li>&ldquo;Log configuration&rdquo;: <code>microservice-ping-pong-node</code></li>
</ul>
</li>
<li>&ldquo;Container&rdquo;:

<ul>
<li>&ldquo;Container name&rdquo;: <code>node-paul</code></li>
<li>&ldquo;Image&rdquo;: <code>AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/microservice-ping-pong/node:latest</code></li>
<li>&ldquo;Memory Limits (MB)&rdquo;: <code>300</code> soft limit</li>
<li>&ldquo;Port mappings&rdquo;: <code>0</code> host, <code>3000</code> container</li>
<li>&ldquo;Log configuration&rdquo;: <code>microservice-ping-pong-node</code></li>
</ul>
</li>
<li>&ldquo;Container&rdquo;:

<ul>
<li>&ldquo;Container name&rdquo;: <code>node-george</code></li>
<li>&ldquo;Image&rdquo;: <code>AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/microservice-ping-pong/node:latest</code></li>
<li>&ldquo;Memory Limits (MB)&rdquo;: <code>300</code> soft limit</li>
<li>&ldquo;Port mappings&rdquo;: <code>0</code> host, <code>3000</code> container</li>
<li>&ldquo;Log configuration&rdquo;: <code>microservice-ping-pong-node</code></li>
</ul>
</li>
<li>&ldquo;Container&rdquo;:

<ul>
<li>&ldquo;Container name&rdquo;: <code>node-ringo</code></li>
<li>&ldquo;Image&rdquo;: <code>AWS_ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/microservice-ping-pong/node:latest</code></li>
<li>&ldquo;Memory Limits (MB)&rdquo;: <code>300</code> soft limit</li>
<li>&ldquo;Port mappings&rdquo;: <code>0</code> host, <code>3000</code> container</li>
<li>&ldquo;Log configuration&rdquo;: <code>microservice-ping-pong-node</code></li>
</ul>
</li>
</ul>


<p><a href="/images/blog/docker-aws/task-defs.png"><img src="/images/blog/docker-aws/task-defs.png" alt="aws ecs task definitions" /></a></p>

<h4>Services</h4>

<p><a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Services</a> instantiate the containers from the Task Definitions and run them on EC2 boxes within an ECS Cluster. Such instances are called <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_run_task.html">Tasks</a>. To create a new Service, on the &ldquo;Services&rdquo; tab within the newly created Cluster, click &ldquo;Create&rdquo;.</p>

<p>Add the following Services&hellip;</p>

<h5>Client</h5>

<ul>
<li>&ldquo;Task Definition&rdquo;: <code>microservice-ping-pong-client-td:LATEST_REVISION_NUMBER</code></li>
<li>&ldquo;Service name&rdquo;: <code>microservice-ping-pong-client-service</code></li>
<li>&ldquo;Number of tasks&rdquo;: 1</li>
</ul>


<p><a href="/images/blog/docker-aws/configure-service1.png"><img src="/images/blog/docker-aws/configure-service1.png" alt="configure service" /></a></p>

<p>Click &ldquo;Next&rdquo;. On the &ldquo;Configure network&rdquo; step, select the &ldquo;Application Load Balancer&rdquo; under &ldquo;Load balancer type&rdquo;.</p>

<ul>
<li>&ldquo;Load balancer name&rdquo;: <code>microservice-ping-pong-alb</code></li>
<li>&ldquo;Container name : port&rdquo;: <code>client:0:3000</code></li>
</ul>


<p><a href="/images/blog/docker-aws/configure-service2.png"><img src="/images/blog/docker-aws/configure-service2.png" alt="configure service" /></a></p>

<p>Click &ldquo;Add to load balancer&rdquo;.</p>

<ul>
<li>&ldquo;Listener port&rdquo;: <code>80:HTTP</code></li>
<li>&ldquo;Target group name&rdquo;: <code>microservice-ping-pong-client-tg</code></li>
</ul>


<p><a href="/images/blog/docker-aws/configure-service3.png"><img src="/images/blog/docker-aws/configure-service3.png" alt="configure service" /></a></p>

<p>Click the next button a few times, and then &ldquo;Create Service&rdquo;.</p>

<h5>Node</h5>

<ul>
<li>&ldquo;Task Definition&rdquo;: <code>microservice-ping-pong-node-td:LATEST_REVISION_NUMBER</code></li>
<li>&ldquo;Service name&rdquo;: <code>microservice-ping-pong-node-service</code></li>
<li>&ldquo;Number of tasks&rdquo;: 1</li>
</ul>


<p>Click &ldquo;Next&rdquo;. On the &ldquo;Configure network&rdquo; step, select the &ldquo;Application Load Balancer&rdquo; under &ldquo;Load balancer type&rdquo;.</p>

<ul>
<li>&ldquo;Load balancer name&rdquo;: <code>microservice-ping-pong-alb</code></li>
<li>&ldquo;Container name : port&rdquo;: <code>node-john:0:3000</code></li>
</ul>


<p>Click &ldquo;Add to load balancer&rdquo;.</p>

<ul>
<li>&ldquo;Listener port&rdquo;: <code>80:HTTP</code></li>
<li>&ldquo;Target group name&rdquo;: <code>microservice-ping-pong-node-tg</code></li>
</ul>


<p><a href="/images/blog/docker-aws/ecs-services.png"><img src="/images/blog/docker-aws/ecs-services.png" alt="aws ecs services" /></a></p>

<h3>Sanity Check</h3>

<p>Navigate to the <a href="https://console.aws.amazon.com/ec2">EC2 Dashboard</a>, and click &ldquo;Target Groups&rdquo;. Make sure <code>microservice-ping-pong-client-tg</code> and <code>microservice-ping-pong-node-tg</code> have a single registered instance each. Both instances should also be <em>unhealthy</em> because they failed their respective health checks.</p>

<p>To get them to pass the health checks, we need to add another inbound rule to the Security Group associated with the containers (which we defined when we configured the Cluster), <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/create-application-load-balancer.html#alb-sec-group">allowing</a> traffic from the Load Balancer to reach the containers.</p>

<h3>Inbound Rule</h3>

<p>Within the <a href="https://console.aws.amazon.com/ec2">EC2 Dashboard</a>, click &ldquo;Security Groups&rdquo; and select the Security group associated with the containers, which is the same group assigned to the Load Balancer). Click the &ldquo;Inbound&rdquo; tab and then click &ldquo;Edit&rdquo;</p>

<p>Add a new rule:</p>

<ol>
<li>&ldquo;Type&rdquo;: <code>All traffic</code></li>
<li>&ldquo;Port Range&rdquo;: <code>0 - 65535</code></li>
<li>&ldquo;Source&rdquo;: Choose <code>Custom</code>, then add the Security Group ID</li>
</ol>


<p>Once added, the next time a container is added to each of the Target Groups, the instance should be <em>healthy</em>:</p>

<p><a href="/images/blog/docker-aws/target-groups.png"><img src="/images/blog/docker-aws/target-groups.png" alt="aws target groups" /></a></p>

<p>Then, navigate back to the Load Balancer and grab the &ldquo;DNS name&rdquo; from the &ldquo;Description&rdquo; tab. Test each endpoint in your browser:</p>

<ol>
<li><a href="http://LOAD_BALANCER_DNS_NAME">http://LOAD_BALANCER_DNS_NAME</a></li>
<li><a href="http://LOAD_BALANCER_DNS_NAME/ping">http://LOAD_BALANCER_DNS_NAME/ping</a></li>
<li><a href="http://LOAD_BALANCER_DNS_NAME/start">http://LOAD_BALANCER_DNS_NAME/start</a></li>
</ol>


<p>Essentially, when the Service was spun up, ECS automatically discovered and associated the new Cluster instances with the Application Load Balancer.</p>

<p><a href="/images/blog/docker-aws/elastic-load-balancing-ecs.png"><img src="/images/blog/docker-aws/elastic-load-balancing-ecs.png" alt="elastic load balancing and ecs " /></a></p>

<h3>Zero Downtime Deployments</h3>

<p>Check you understanding and try this on your own.</p>

<h4>Steps</h4>

<ol>
<li>Make a quick change to the app locally.</li>
<li>Build, tag, and push the new images.</li>
<li><p>Add a new revision to the task definition.</p>

<p> <a href="/images/blog/docker-aws/task-def-revision.png"><img src="/images/blog/docker-aws/task-def-revision.png" alt="task definition revision " /></a></p></li>
<li><p>Update the service.</p>

<p> <a href="/images/blog/docker-aws/service-update1.png"><img src="/images/blog/docker-aws/service-update1.png" alt="update service " /></a></p>

<p> <a href="/images/blog/docker-aws/service-update2.png"><img src="/images/blog/docker-aws/service-update2.png" alt="update service " /></a></p></li>
</ol>


<h4>What happens next?</h4>

<ol>
<li><p>Once you update the Service, ECS will pick up on these changes and instantiate the Task Definitions, creating new Tasks that will spin up on the Cluster instances.</p>

<p> <a href="/images/blog/docker-aws/service-update3.png"><img src="/images/blog/docker-aws/service-update3.png" alt="update service " /></a></p></li>
<li><p>ALB will run health checks on the new instances once they are up.</p>

<ul>
<li><p>If the health checks pass, traffic is forwarded appropriately to the new Tasks while the old Tasks are spun down.</p>

<p>  <a href="/images/blog/docker-aws/service-update4.png"><img src="/images/blog/docker-aws/service-update4.png" alt="update service " /></a></p></li>
<li><p>If the health checks fail, the new Tasks are spun down.</p></li>
</ul>
</li>
</ol>


<p>The health checks are the last line of defense after your own unit, integration, and functional tests.</p>

<div>
  <img src="http://mherman.org/images/blog/docker-aws/ping4.png" style="max-width: 80%; border:0; box-shadow: none;" alt="ping pong app">
</div>


<h3>Autoscaling</h3>

<p>You can scale up or down at both the Cluster (adding additional EC2 instances) and Service (adding more Tasks to an existing instance) level.</p>

<h4>Cluster</h4>

<p>To manually scale, navigate to the Cluster and click the &ldquo;ECS Instances&rdquo; tab. Then, click the &ldquo;Scale ECS Instances&rdquo; button and provide the desired number of instances you&rsquo;d like to scale up (or down) to.</p>

<p><a href="/images/blog/docker-aws/scale-by-cluster.png"><img src="/images/blog/docker-aws/scale-by-cluster.png" alt="scale by cluster " /></a></p>

<p>You can automate this process by setting up an <a href="http://docs.aws.amazon.com/autoscaling/latest/userguide/AutoScalingGroup.html">Auto Scaling Group</a>. Review the <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/cloudwatch_alarm_autoscaling.html">Scaling Container Instances with CloudWatch Alarms</a> tutorial for more info.</p>

<h4>Service</h4>

<p>You can also scale Tasks up (or down) at the Service-level.</p>

<p><a href="/images/blog/docker-aws/service-auto-scaling.png"><img src="/images/blog/docker-aws/service-auto-scaling.png" alt="service auto scaling " /></a></p>

<p><a href="/images/blog/docker-aws/service-auto-scaling2.png"><img src="/images/blog/docker-aws/service-auto-scaling2.png" alt="service auto scaling " /></a></p>

<p>For more on this, review the <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/service_autoscaling_tutorial.html">Service Auto Scaling with CloudWatch Service Utilization Metrics</a> tutorial.</p>

<h2>Next Steps</h2>

<p>That&rsquo;s it!</p>

<h3>Check your understanding</h3>

<ol>
<li>Add CI/CD (via <a href="http://mherman.org/blog/2017/09/18/on-demand-test-environments-with-docker-and-aws-ecs">Circle CI</a> or <a href="https://medium.com/@YadavPrakshi/automate-zero-downtime-deployment-with-amazon-ecs-and-lambda-c4e49953273d">AWS Lambda</a>) and Postgres via RDS (<a href="https://testdriven.io/part-five-ec2-relational-database-service/">example</a>)</li>
<li>Turn back to the feature wish-list. Implement anything not covered.</li>
<li>Did you notice that we didn&rsquo;t add any of the environment variables from the Docker Compose file to the Task Definitions? Why does the app still work? Update the Task Definitions on your own.</li>
</ol>


<h3>Resources</h3>

<ol>
<li><a href="http://mherman.org/presentations/microservice-ping-pong">Slides</a></li>
<li><a href="https://github.com/mjhea0/microservice-ping-pong">Repo</a></li>
<li><strong><em><a href="http://testdriven.io/">Testdriven.io</a> - full tutorial!</em></strong> ❤️</li>
<li><a href="https://www.packtpub.com/books/content/how-to-build-12-factor-design-microservices-on-docker-part-1">How to Build 12 Factor Microservices on Docker</a></li>
<li><a href="https://github.com/wsargent/docker-cheat-sheet">Docker Cheat Sheet</a></li>
</ol>


<p>Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On-Demand Environments With Docker and AWS ECS]]></title>
    <link href="http://mherman.org/blog/2017/09/18/on-demand-test-environments-with-docker-and-aws-ecs/"/>
    <updated>2017-09-18T08:08:43-06:00</updated>
    <id>http://mherman.org/blog/2017/09/18/on-demand-test-environments-with-docker-and-aws-ecs</id>
    <content type="html"><![CDATA[<p>In this tutorial, we&rsquo;ll look at how to spin up reproducible (and easily-destructible), on-demand test environments with <a href="http://docker.com/">Docker</a>, <a href="https://aws.amazon.com/ecs/">Amazon EC2 Container Service</a> (ECS), and <a href="https://circleci.com/">Circle CI</a> (for continuous integration and delivery).</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/on-demand-environments/on-demand-envs.png" style="max-width: 90%; border:0; box-shadow: none;" alt="on demand test environments">
</div>


<p>We&rsquo;ll be using the following tools&hellip;</p>

<table>
<thead>
<tr>
<th> Tool    </th>
<th> Use Cases              </th>
<th> Version                                                                </th>
</tr>
</thead>
<tbody>
<tr>
<td> Docker  </td>
<td> Containerization and distribution      </td>
<td> <a href="https://github.com/moby/moby/releases/tag/v17.03.2-ce">17.03.2-ce</a>    </td>
</tr>
<tr>
<td> AWS ECS </td>
<td> Container orchestration and management  </td>
<td> <a href="https://github.com/aws/amazon-ecs-agent/releases/tag/v1.14.4">1.14.4</a> (service agent) </td>
</tr>
<tr>
<td> Circle CI </td>
<td> Continuous integration </td>
<td> <a href="https://circleci.com/docs/2.0/">2.0</a> </td>
</tr>
<tr>
<td> AWS JavaScript SDK </td>
<td> Interacting with AWS </td>
<td> <a href="https://github.com/aws/aws-sdk-js/releases/tag/v2.114.0">2.114.0</a> </td>
</tr>
</tbody>
</table>


<p>For a demo, check out the following <a href="https://www.youtube.com/watch?v=O4jlWN3IVhE">video</a>.</p>

<h2>Contents</h2>

<ol>
<li>Prerequisites</li>
<li>Objectives</li>
<li>Introduction</li>
<li>Development Workflow</li>
<li>Project Setup</li>
<li>Manual AWS Setup</li>
<li>Circle CI Setup</li>
<li>AWS SDK Setup</li>
<li>Deployment Script</li>
<li>Testing</li>
<li>Teardown Script</li>
<li>Conclusion and Next Steps</li>
</ol>


<h2>Prerequisites</h2>

<p>This post assumes prior knowledge of Docker and Docker Compose along with microservice architecture in general.</p>

<p>If you haven&rsquo;t already, review the <a href="http://mherman.org/blog/2017/05/11/developing-microservices-node-react-docker">Developing Microservices - Node, React, and Docker</a> blog post. This tutorial utilizes a <em>slightly</em> modified version of the finished project from that post, so be sure to review the code from the <a href="https://github.com/mjhea0/microservice-movies/releases/tag/v3">v3</a> tag of the <a href="https://github.com/mjhea0/microservice-movies">microservice-movies</a> repository, taking note of each service:</p>

<table>
<thead>
<tr>
<th> Name             </th>
<th> Service </th>
<th> Container </th>
<th> Tech                 </th>
</tr>
</thead>
<tbody>
<tr>
<td> Web              </td>
<td> Web     </td>
<td> web       </td>
<td> React, React-Router  </td>
</tr>
<tr>
<td> Movies API       </td>
<td> Movies  </td>
<td> movies    </td>
<td> Node, Express        </td>
</tr>
<tr>
<td> Movies DB        </td>
<td> Movies  </td>
<td> movies-db </td>
<td> Postgres             </td>
</tr>
<tr>
<td> Swagger          </td>
<td> Movies  </td>
<td> swagger   </td>
<td> Swagger UI           </td>
</tr>
<tr>
<td> Users API        </td>
<td> Users   </td>
<td> users     </td>
<td> Node, Express        </td>
</tr>
<tr>
<td> Users DB         </td>
<td> Users   </td>
<td> users-db  </td>
<td> Postgres             </td>
</tr>
<tr>
<td> Functional Tests </td>
<td> Test    </td>
<td> n/a       </td>
<td> TestCafe             </td>
</tr>
</tbody>
</table>


<p>You should also be familiar with AWS in general along with the following AWS services - <a href="https://aws.amazon.com/vpc/">VPC</a>, <a href="https://aws.amazon.com/elasticloadbalancing/">ELB</a>, <a href="https://aws.amazon.com/ec2/">EC2</a>, and <a href="https://aws.amazon.com/iam/">IAM</a>.</p>

<h2>Objectives</h2>

<p>By the end of this tutorial, you will be able to&hellip;</p>

<ol>
<li>Explain what on-demand environments are, why you would want to use them, and the overall development workflow</li>
<li>Discuss the benefits of using on-demand environments</li>
<li>Automate the building, configuring, deploying, and maintaining of on-demand environments on AWS</li>
<li>Configure an Application Load Balancer and ECS to run a set of microservices</li>
<li>Set up continuous integration and deployment to ECS via Circle CI</li>
<li>Integrate Amazon EC2 Container Registry, an image registry, into the continuous integration process</li>
<li>Create a teardown script to remove the environment once testing is complete</li>
</ol>


<h2>Introduction</h2>

<p>The end goal of on-demand test environments is to allow developers to quickly and easily spin up multiple, independent testing environments.</p>

<p>In other words, testing environments are spun up as needed during the development process - when code is checked-in, for example - and, then, when no longer needed, spun down just as quickly to free up resources and keep costs down.</p>

<p>With microservices, testing a single service can be difficult, time consuming, and expensive since you often have to spin up a plethora of services, especially if you have resource and/or config-heavy services. On-demand environments simplify this, making testing and trial easy, decreasing the feedback cycle between review and development.</p>

<p>Such environments can used for running integration and end-to-end tests, QA, UAT, troubleshooting, and basic trial.</p>

<blockquote><p><strong>NOTE:</strong> For more on the benefits of using reproducible, on-demand test environments, review the <a href="https://www.cognizant.com/whitepapers/the-business-case-for-on-demand-test-services-codex1342.pdf">The Business Case for On-Demand Test Services</a> whitepaper.</p></blockquote>

<h2>Development Workflow</h2>

<p>With on-demand environments, the development workflow looks like&hellip;</p>

<h3>(1) Local development</h3>

<ol>
<li>Create a new feature branch from the master branch</li>
<li>Make code changes</li>
<li>Commit and push code to GitHub</li>
</ol>


<h3>(2) Continuous integration</h3>

<ol>
<li>Open a new PR against the development branch</li>
<li>A new build is then triggered on Circle CI</li>
<li>If the build passes, manually merge the PR</li>
<li>A new build is triggered again on Circle CI</li>
<li>If the build passes, deployment occurs&hellip;</li>
</ol>


<h3>(3) Deployment on AWS via deployment scripts</h3>

<ol>
<li>Images are created, tagged, and pushed to ECR</li>
<li>Task Definitions are registered on ECS</li>
<li>Target Groups are created</li>
<li>A Listener is added to the load balancer and Rules are added</li>
<li>ECS Services are created</li>
</ol>


<h3>(4) Testing</h3>

<ol>
<li>End-to-end tests</li>
<li>Acceptance tests</li>
<li>UAT</li>
</ol>


<h3>(5) Teardown</h3>

<ol>
<li>All AWS Resources are torn down</li>
</ol>


<h2>Project Setup</h2>

<p>Fork the <a href="https://github.com/mjhea0/microservice-movies">microservice-movies</a> repo, clone it down, and then check out the <a href="https://github.com/mjhea0/microservice-movies/releases/tag/v3">v3</a> tag to a new branch called <code>aws-docker-on-demand</code>:</p>

<pre><code class="sh">$ git clone https://github.com/YOUR_GITHUB_NAME/microservice-movies
$ cd microservice-movies
$ git checkout tags/v3 -b aws-docker-on-demand
</code></pre>

<p>Set the environment variables:</p>

<pre><code class="sh">$ export NODE_ENV=test
$ export REACT_APP_USERS_SERVICE_URL=http://localhost:3000
$ export REACT_APP_MOVIES_SERVICE_URL=http://localhost:3001
</code></pre>

<p>Build the images and fire up the containers:</p>

<pre><code class="sh">$ docker-compose -f docker-compose-review.yml build
$ docker-compose -f docker-compose-review.yml up -d
</code></pre>

<p>Run the tests:</p>

<pre><code class="sh">$ docker-compose -f docker-compose-review.yml \
    run users-service-review npm test \ &amp;&amp;
  docker-compose -f docker-compose-review.yml \
    run movies-service-review npm test \ &amp;&amp;
  testcafe firefox tests/**/*.js
</code></pre>

<p>Finally, ensure you can view the app in your browser at <a href="http://localhost:3007">http://localhost:3007</a>, and then try logging in with username <code>michael</code> and password <code>herman</code>.</p>

<h2>Manual AWS Setup</h2>

<p>Before deploying, we need to configure the the following AWS resources:</p>

<ol>
<li><a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html">EC2 Key Pair</a></li>
<li><a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_clusters.html">ECS Cluster</a></li>
<li><a href="https://aws.amazon.com/ecr/">EC2 Container Registry</a> (ECR)</li>
<li><a href="https://aws.amazon.com/elasticloadbalancing/applicationloadbalancer/">Application Load Balancer</a> (ALB)</li>
<li><a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html">Security Group</a></li>
</ol>


<p>Keep in mind that you <em>could</em> create each of these resources dynamically as well. Clusters can take a bit of time to fire up since EC2 instances need to be spun up though. By setting up the Cluster beforehand, EC2 instances are up and running, ready for Tasks to be added.</p>

<h3>EC2 Key Pair</h3>

<p>Within the <a href="https://console.aws.amazon.com/ec2/">EC2 Dashboard</a>, click &ldquo;Key Pairs&rdquo; on the navigation pane, and then click the &ldquo;Create Key Pair&rdquo; button. Name the key <code>microservicemovies-review</code>. Save the file in a safe place - i.e., &ldquo;~/.ssh&rdquo;.</p>

<h3>ECS Cluster</h3>

<p>An <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_clusters.html">ECS Cluster</a> is just a group of EC2 container instances managed by ECS. To set up, navigate to the <a href="https://console.aws.amazon.com/ecs">ECS Console</a>, and then <a href="http://docs.aws.amazon.com/awsconsolehelpdocs/latest/gsg/getting-started.html#select-region">select</a> the region for the Cluster on the right-side of the nav bar.</p>

<blockquote><p><strong>NOTE</strong>: This tutorial uses the <code>US West (Oregon)</code> / <code>us-west-2</code> region. Feel free to use the region of your choice. For more info, review the <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html">Regions and Availability Zones</a> guide.</p></blockquote>

<p>Next, click the &ldquo;Create Cluster&rdquo; button:</p>

<ol>
<li>&ldquo;Cluster name&rdquo;: <code>microservicemovies-review</code></li>
<li>&ldquo;EC2 instance type&rdquo;: <code>t2.medium</code></li>
<li>&ldquo;Number of instances&rdquo;: <code>3</code></li>
<li>&ldquo;Key pair&rdquo;: <code>microservicemovies-review</code></li>
<li>Create a new <a href="https://aws.amazon.com/vpc/">VPC</a> and <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html">Security Group</a></li>
</ol>


<p>Create the Cluster.</p>

<p>Navigate to the Cluster once it&rsquo;s created, and then click the &ldquo;ECS Instances&rdquo; tab. From there, click the &ldquo;Actions&rdquo; dropdown and select &ldquo;View Cluster Resources&rdquo;. Take note of the VPC and Security Group:</p>

<p><a href="/images/blog/on-demand-environments/aws-ecs-cluster-resources.png"><img src="/images/blog/on-demand-environments/aws-ecs-cluster-resources.png" alt="aws ecs cluster resources" /></a></p>

<h3>ECR</h3>

<p>Within the <a href="https://console.aws.amazon.com/ecs">ECS Console</a>, click &ldquo;Repositories&rdquo; on the navigation pane, and then click the &ldquo;Create repository&rdquo; button. Add the following repositories:</p>

<ol>
<li><code>microservicemovies/users-db-review</code></li>
<li><code>microservicemovies/movies-db-review</code></li>
<li><code>microservicemovies/users-service-review</code></li>
<li><code>microservicemovies/movies-service-review</code></li>
<li><code>microservicemovies/web-service-review</code></li>
<li><code>microservicemovies/swagger-review</code></li>
</ol>


<p><a href="/images/blog/on-demand-environments/aws-ecr-repos.png"><img src="/images/blog/on-demand-environments/aws-ecr-repos.png" alt="aws ecr repos" /></a></p>

<h3>Application Load Balancer</h3>

<p><a href="https://aws.amazon.com/elasticloadbalancing/">Elastic Load Balancing</a>, as of writing, supports two types of load balancers - <em>Classic</em> and <em>Application</em>. Either will work with ECS, but the Application Load Balancer (ALB) is the better of the two since it:</p>

<ol>
<li>Dynamically maps container services to ports</li>
<li>Distributes traffic evenly across the entire ECS Service</li>
<li>Runs status health checks against each service</li>
<li>Allows for zero-downtime deploys</li>
</ol>


<p>To set up, navigate to the <a href="https://console.aws.amazon.com/ec2/">EC2 Dashboard</a>, update the region (if necessary), and then click &ldquo;Load Balancers&rdquo; in the navigation pane. Click the &ldquo;Create Load Balancer&rdquo; button. Select &ldquo;Application Load Balancer&rdquo;, and then go through each of the steps to configure the load balancer&hellip;</p>

<ol>
<li><em>Configure Load Balancer</em>:

<ul>
<li>&ldquo;Name&rdquo;: <code>microservicemovies-review</code></li>
<li>&ldquo;VPC&rdquo;: Select the VPC that was just created</li>
<li>&ldquo;Availability Zones&rdquo;: Select at least two available subnets</li>
</ul>
</li>
<li><em>Configure Security Settings</em>: Skip this for now</li>
<li><em>Configure Security Groups</em>: Select the Security Group that was just created</li>
<li><em>Configure Routing</em>:

<ul>
<li>&ldquo;Name&rdquo;: <code>review-default</code></li>
<li>&ldquo;Port&rdquo;: <code>80</code></li>
<li>&ldquo;Path&rdquo;: <code>/</code></li>
</ul>
</li>
<li><em>Register Targets</em>: Do not assign any instances manually since this will be managed by ECS</li>
</ol>


<p><a href="/images/blog/on-demand-environments/aws-load-balancer.png"><img src="/images/blog/on-demand-environments/aws-load-balancer.png" alt="aws load balancer" /></a></p>

<p>Along with the Application Load Balancer, this will also create a default Target Group called <code>review-default</code>:</p>

<p><a href="/images/blog/on-demand-environments/aws-default-target-group.png"><img src="/images/blog/on-demand-environments/aws-default-target-group.png" alt="aws default target group" /></a></p>

<h3>Security Group</h3>

<p>Finally, let&rsquo;s add some ports to work with to the Security Group. Within the <a href="https://console.aws.amazon.com/ec2/">EC2 Dashboard</a>, click &ldquo;Security Groups&rdquo; in the navigation pane, and then select the Security Group that was just created. On the &ldquo;Inbound Rules&rdquo; pane, click the &ldquo;Edit&rdquo; button and the &ldquo;Add another rule button&rdquo;:</p>

<ol>
<li>&ldquo;Type&rdquo;: &ldquo;Custom TCP Rule&rdquo;</li>
<li>&ldquo;Protocol&rdquo;: &ldquo;TCP (6)&rdquo;</li>
<li>&ldquo;Port Range&rdquo;: <code>30000-50000</code></li>
<li>&ldquo;Source&rdquo;: <code>0.0.0.0/0</code></li>
</ol>


<p>Click the &ldquo;Save&rdquo; button.</p>

<p><a href="/images/blog/on-demand-environments/aws-security-groups.png"><img src="/images/blog/on-demand-environments/aws-security-groups.png" alt="aws security groups" /></a></p>

<p>That&rsquo;s it for the basic AWS resources.</p>

<h2>Circle CI Setup</h2>

<p>Next, <a href="https://circleci.com/signup/">sign up</a> for Circle CI (if necessary) and follow the basic <a href="https://circleci.com/docs/2.0/first-steps/">steps</a> to configure Circle 2.0, making sure to enable access to your GitHub repos. Then, create a new folder called &ldquo;.circleci&rdquo; in the project root of &ldquo;microservice-movies&rdquo; and add a <em>config.yml</em> file to that directory:</p>

<pre><code class="yaml">version: 2

jobs:
  build:
    docker:
      - image: docker:17.03.2-ce-git
    working_directory: ~/microservice-movies
    environment:
      - NODE_ENV: test
      - REACT_APP_USERS_SERVICE_URL: http://localhost:3000
      - REACT_APP_MOVIES_SERVICE_URL: http://localhost:3001
    parallelism: 1
    steps:
      - checkout
      - setup_remote_docker:
          reusable: true
          exclusive: false
      - run:
          name: Install dependencies
          command: |
            apk add --no-cache \
              py-pip=9.0.0-r1 \
              bash \
              jq \
              curl \
              nodejs
            pip install \
              docker-compose==1.12.0 \
              awscli==1.11.76
      - run:
          name: Build Docker images
          command: docker-compose -f docker-compose-review.yml build
      - run:
          name: Spin up Docker containers
          command: docker-compose -f docker-compose-review.yml up -d
      - run:
          name: Test the user service
          command: docker-compose -f docker-compose-review.yml run users-service-review npm test
      - run:
          name: Test the movies service
          command: docker-compose -f docker-compose-review.yml run movies-service-review npm test
</code></pre>

<p>Review this file. Refer to the Circle <a href="https://circleci.com/docs/2.0/">documentation</a> as needed. Commit and push your code to GitHub once done. On Circle, navigate to the <a href="https://circleci.com/add-projects">Add Projects</a> page and click the &ldquo;Build Project&rdquo; button next to your project. This will trigger a new build, which should pass.</p>

<h2>AWS SDK Setup</h2>

<p>Since the microservice stack is built with Node, we&rsquo;ll develop the deployment script in JavaScript with the <a href="https://www.npmjs.com/package/aws-sdk">AWS JavaScript SDK</a>.</p>

<p>Add a <em>package.json</em> to the project root:</p>

<pre><code class="json">{
  "name": "microservice-movies",
  "dependencies": {
    "aws-sdk": "2.114.0"
  }
}
</code></pre>

<p>Install the dependency:</p>

<pre><code class="sh">$ npm install
</code></pre>

<p>Add a new folder to the project root called &ldquo;ecs&rdquo;, and then create a new folder called &ldquo;scripts&rdquo; within that folder. Finally, add a new file called <em>setup.js</em> to &ldquo;scripts&rdquo;:</p>

<pre><code class="javascript">const AWS = require('aws-sdk');


// globals

const AWS_ACCOUNT_ID = process.env.AWS_ACCOUNT_ID;
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID;
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY;
const AWS_USERNAME = process.env.AWS_USERNAME;
const AWS_CONFIG_REGION = 'us-west-2';

const clusterName = 'microservicemovies-review';


// config

AWS.config = new AWS.Config();
AWS.config.accessKeyId = AWS_ACCESS_KEY_ID;
AWS.config.secretAccessKey = AWS_SECRET_ACCESS_KEY;
AWS.config.region = AWS_CONFIG_REGION;


// init aws services

const ecs = new AWS.ECS();
const iam = new AWS.IAM();


// methods

function ensureAuthenticated() {
  return new Promise((resolve, reject) =&gt; {
    const params = { UserName: AWS_USERNAME };
    iam.getUser(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function confirmRegion() {
  return new Promise((resolve, reject) =&gt; {
    if (AWS.config.region !== AWS_CONFIG_REGION) {
      reject('Something went wrong!');
    }
    resolve(AWS_CONFIG_REGION);
  });
}

function getCluster() {
  return new Promise((resolve, reject) =&gt; {
    const params = { clusters: [ clusterName ] };
    ecs.describeClusters(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}


// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
  return confirmRegion();
})
.then((region) =&gt; {
  console.log(`AWS Region -&gt; ${region}`);
  return getCluster();
})
.then((cluster) =&gt; {
  if (!cluster.clusters.length) {
    console.log('Cluster does not exist!');
    return;
  }
  console.log(`ECS Cluster -&gt; ${cluster.clusters[0].clusterName}`);
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<p>In essence, this confirms that the AWS user credentials are correct and that the AWS Region and ECS Cluster are configured properly.</p>

<p>Set the following environment variables locally:</p>

<ol>
<li><code>AWS_ACCOUNT_ID</code></li>
<li><code>AWS_ACCESS_KEY_ID</code></li>
<li><code>AWS_SECRET_ACCESS_KEY</code></li>
<li><code>AWS_USERNAME</code></li>
</ol>


<p>Run the script:</p>

<pre><code class="sh">$ node ecs/scripts/setup.js
</code></pre>

<p>You should see:</p>

<pre><code class="sh">Welcome AWS_USERNAME!
AWS Region -&gt; us-west-2
ECS Cluster -&gt; microservicemovies-review
</code></pre>

<p>Add another step to the bottom of <em>.circleci/config.yml</em>:</p>

<pre><code class="yaml">- run:
    name: Deploy
    command: |
      npm install
      node ecs/scripts/setup.js
</code></pre>

<p>Add the following <a href="https://circleci.com/docs/2.0/env-vars/#adding-environment-variables-in-the-app">environment variables</a> to Circle so that we can properly configure the AWS SDK:</p>

<ol>
<li><code>AWS_ACCOUNT_ID</code></li>
<li><code>AWS_ACCESS_KEY_ID</code></li>
<li><code>AWS_SECRET_ACCESS_KEY</code></li>
<li><code>AWS_USERNAME</code></li>
</ol>


<p>Commit your changes, and then push to GitHub to trigger a new build. Make sure it passes before moving on.</p>

<h2>Deployment Script</h2>

<p>Moving right along, let&rsquo;s start building the deployment scripts to set up the AWS resources and deploy the app.</p>

<p>Main Steps:</p>

<ol>
<li>Tag and push images to ECR</li>
<li>Get open port for the Listener</li>
<li>Register Task Definitions</li>
<li>Create Target Groups</li>
<li>Add the Listener and Rules</li>
<li>Create new Services</li>
</ol>


<h3>(1) Tag and push images to ECR</h3>

<p>Create a new file in &ldquo;ecs/scripts&rdquo; called <em>ecr.sh</em>:</p>

<pre><code class="sh">#!/usr/bin/env bash


# config

set -e

ECS_REGION="us-west-2"
NAMESPACE="microservicemovies"
IMAGE_BASE="microservicemovies"
ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${ECS_REGION}.amazonaws.com"
SHORT_GIT_HASH=$(echo $CIRCLE_SHA1 | cut -c -7)
TAG=$SHORT_GIT_HASH


# helpers

configure_aws_cli() {
  echo "Configuring AWS..."
  aws --version
  aws configure set default.region $ECS_REGION
  aws configure set default.output json
  echo "AWS configured!"
}

tag_and_push_images() {
  echo "Tagging and pushing images..."
  $(aws ecr get-login --region "${ECS_REGION}")
  # tag
  docker tag ${IMAGE_BASE}_users-db-review ${ECR_URI}/${NAMESPACE}/users-db-review:${TAG}
  docker tag ${IMAGE_BASE}_movies-db-review ${ECR_URI}/${NAMESPACE}/movies-db-review:${TAG}
  docker tag ${IMAGE_BASE}_users-service-review ${ECR_URI}/${NAMESPACE}/users-service-review:${TAG}
  docker tag ${IMAGE_BASE}_movies-service-review ${ECR_URI}/${NAMESPACE}/movies-service-review:${TAG}
  docker tag ${IMAGE_BASE}_web-service-review ${ECR_URI}/${NAMESPACE}/web-service-review:${TAG}
  docker tag ${IMAGE_BASE}_swagger-review ${ECR_URI}/${NAMESPACE}/swagger-review:${TAG}
  # push
  docker push ${ECR_URI}/${NAMESPACE}/users-db-review:${TAG}
  docker push ${ECR_URI}/${NAMESPACE}/movies-db-review:${TAG}
  docker push ${ECR_URI}/${NAMESPACE}/users-service-review:${TAG}
  docker push ${ECR_URI}/${NAMESPACE}/movies-service-review:${TAG}
  docker push ${ECR_URI}/${NAMESPACE}/web-service-review:${TAG}
  docker push ${ECR_URI}/${NAMESPACE}/swagger-review:${TAG}
  echo "Images tagged and pushed!"
}

# main

configure_aws_cli
tag_and_push_images
</code></pre>

<p>Each deploy is associated with a different commit and, thus, a different version of the code. To link the commit back to a specific image, we just used part of the Git commit SHA as the image tag:</p>

<pre><code class="sh">SHORT_GIT_HASH=$(echo $CIRCLE_SHA1 | cut -c -7)
TAG=$SHORT_GIT_HASH
</code></pre>

<blockquote><p><strong>NOTE:</strong> Instead of using the associated Git commit SHA, you could get a bit creative and build a Heroku-like random name generator.</p></blockquote>

<p>Update the <code>Deploy</code> command in <em>.circle/config.yml</em>:</p>

<pre><code class="yaml">- run:
    name: Deploy
    command: |
      npm install
      node ecs/scripts/setup.js
      sh ecs/scripts/ecr.sh
</code></pre>

<p>Commit and push your code to GitHub to trigger a new Circle build. Once done, ensure the images are up on ECS with the appropriate tag:</p>

<p><a href="/images/blog/on-demand-environments/aws-ecr-users-db-review-image.png"><img src="/images/blog/on-demand-environments/aws-ecr-users-db-review-image.png" alt="aws ecr users db review image" /></a></p>

<h3>(2) Get open port for the Listener</h3>

<p>Remember how we set a range of open ports, <code>30000</code> - <code>50000</code>, when we set up the Security Group? Well, each new environment will be assigned to a port within this range.</p>

<p>Add a new file called <em>listener.js</em> to &ldquo;ecs/scripts&rdquo;:</p>

<pre><code class="javascript">const AWS = require('aws-sdk');


// globals

const AWS_ACCOUNT_ID = process.env.AWS_ACCOUNT_ID;
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID;
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY;
const AWS_USERNAME = process.env.AWS_USERNAME;
const AWS_CONFIG_REGION = 'us-west-2';
const LOAD_BALANCER_ARN = 'UPDATE_ME';


// config

AWS.config = new AWS.Config();
AWS.config.accessKeyId = AWS_ACCESS_KEY_ID;
AWS.config.secretAccessKey = AWS_SECRET_ACCESS_KEY;
AWS.config.region = AWS_CONFIG_REGION;


// init aws services

const elbv2 = new AWS.ELBv2();


// methods

function getPort() {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      LoadBalancerArn: LOAD_BALANCER_ARN
    };
    elbv2.describeListeners(params, (err, data) =&gt; {
      if (err) { reject(err); }
      const max = data.Listeners.reduce((prev, current) =&gt; {
        return (prev.Port &gt; current.Port) ? prev : current;
      });
      if (parseInt(max.Port) === 80) {
        resolve(30000);
      } else {
        const port = parseInt(max.Port) + 1;
        resolve(port);
      }
    });
  });
}


module.exports = {
  getPort
};
</code></pre>

<p>Add then update the following variable:</p>

<pre><code class="javascript">const LOAD_BALANCER_ARN = 'UPDATE_ME';
</code></pre>

<p>Then, take note of the following <code>if</code> statement:</p>

<pre><code class="javascript">if (parseInt(max.Port) === 80) {
  resolve(30000);
} else {
  const port = parseInt(max.Port) + 1;
  resolve(port);
}
</code></pre>

<p>Why do we need this?</p>

<p>Since the default Target Group, <code>review-default</code>, was configured to listen on port 80, we need to account for it if it&rsquo;s the only Listener set up since we&rsquo;re bumping the port by 1 each time.</p>

<p>We&rsquo;ll test this out in the next section&hellip;</p>

<h3>(3) Register Task Definitions</h3>

<p>A <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html">Task Definition</a> is used to create an application from one or more containers. It&rsquo;s similar to a Docker Compose file.</p>

<p>Steps:</p>

<ol>
<li>Create Task Definition files</li>
<li>Create script to register Task Definitions</li>
</ol>


<h4>Create Task Definition files</h4>

<p>Create a new directory called &ldquo;tasks&rdquo; within &ldquo;ecs&rdquo;, and then add the following files:</p>

<ol>
<li><em>users-review_task.js</em></li>
<li><em>movies-review_task.js</em></li>
<li><em>web-review_task.js</em></li>
</ol>


<h5>Users - <em>users-review_task.js</em></h5>

<pre><code class="javascript">function createUsersTaskDefinition(accountID, region, tag, family, revision) {
  const taskDefinition = {
    containerDefinitions: [
      {
        name: 'users-service-review',
        image: `${accountID}.dkr.ecr.${region}.amazonaws.com\/microservicemovies\/users-service-review:${tag}`,
        essential: true,
        memoryReservation: 300,
        cpu: 300,
        portMappings: [
          {
            containerPort: 3000,
            hostPort: 0,
            protocol: 'tcp'
          }
        ],
        environment: [
          {
            name: 'DATABASE_URL',
            value: 'postgres://postgres:postgres@users-db-review:5432/users_dev'
          },
          {
            name: 'DATABASE_TEST_URL',
            value: 'postgres://postgres:postgres@users-db-review:5432/users_test'
          },
          {
            name: 'NODE_ENV',
            value: 'test'
          },
          {
            name: 'TOKEN_SECRET',
            value: 'changeme'
          }
        ],
        links: [
          'users-db-review'
        ],
        logConfiguration: {
          logDriver: 'awslogs',
          options: {
            'awslogs-group': 'microservicemovies',
            'awslogs-region': region
          }
        }
      },
      {
        name: 'users-db-review',
        image: `${accountID}.dkr.ecr.${region}.amazonaws.com\/microservicemovies\/users-db-review:${tag}`,
        essential: true,
        memoryReservation: 300,
        cpu: 300,
        portMappings: [
          {
            containerPort: 5432
          }
        ],
        environment: [
          {
            name: 'POSTGRES_USER',
            value: 'postgres'
          },
          {
            name: 'POSTGRES_PASSWORD',
            value: 'postgres'
          }
        ],
        logConfiguration: {
          logDriver: 'awslogs',
          options: {
            'awslogs-group': 'microservicemovies',
            'awslogs-region': region
          }
        }
      }
    ],
    family: 'microservicemovies-review-users-td'
  };
  return taskDefinition;
}

module.exports = {
  createUsersTaskDefinition
};
</code></pre>

<p>Most of this should be fairly straightforward since the container definition relates back to the Docker Compose file. Review the <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html">Task Definition Parameters</a> guide for more info.</p>

<p>Two things to note:</p>

<ol>
<li>We set the host port for the users service to <code>0</code> so that a port is dynamically assigned when the Task is fired up.</li>
<li>We also configured logs, via  <a href="http://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_LogConfiguration.html">LogConfiguration</a>, to pipe logs to <a href="https://console.aws.amazon.com/cloudwatch">CloudWatch</a>. To set up, we need to create a new <a href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatchLogsConcepts.html">Log Group</a>. Simply navigate to <a href="https://console.aws.amazon.com/cloudwatch">CloudWatch</a>, click &ldquo;Logs&rdquo; on the navigation pane, click the &ldquo;Actions&rdquo; drop-down button, and then select &ldquo;Create log group&rdquo;. Name the group <code>microservicemovies-review</code>.</li>
</ol>


<h5>Movies - <em>movies-review_task.js</em></h5>

<pre><code class="javascript">function createMoviesTaskDefinition(accountID, region, tag, family, revision) {
  const taskDefinition = {
    containerDefinitions: [
      {
        name: 'movies-service-review',
        image: `${accountID}.dkr.ecr.${region}.amazonaws.com\/microservicemovies\/movies-service-review:${tag}`,
        essential: true,
        memoryReservation: 300,
        cpu: 300,
        portMappings: [
          {
            containerPort: 3000,
            hostPort: 0,
            protocol: 'tcp'
          }
        ],
        environment: [
          {
            name: 'DATABASE_URL',
            value: 'postgres://postgres:postgres@movies-db-review:5432/movies_dev'
          },
          {
            name: 'DATABASE_TEST_URL',
            value: 'postgres://postgres:postgres@movies-db-review:5432/movies_test'
          },
          {
            name: 'NODE_ENV',
            value: 'test'
          },
          {
            name: 'TOKEN_SECRET',
            value: 'changeme'
          }
        ],
        links: [
          'movies-db-review'
        ],
        logConfiguration: {
          logDriver: 'awslogs',
          options: {
            'awslogs-group': 'microservicemovies',
            'awslogs-region': region
          }
        }
      },
      {
        name: 'movies-db-review',
        image: `${accountID}.dkr.ecr.${region}.amazonaws.com\/microservicemovies\/movies-db-review:${tag}`,
        essential: true,
        memoryReservation: 300,
        cpu: 300,
        portMappings: [
          {
            containerPort: 5432
          }
        ],
        environment: [
          {
            name: 'POSTGRES_USER',
            value: 'postgres'
          },
          {
            name: 'POSTGRES_PASSWORD',
            value: 'postgres'
          }
        ],
        logConfiguration: {
          logDriver: 'awslogs',
          options: {
            'awslogs-group': 'microservicemovies',
            'awslogs-region': region
          }
        }
      },
      {
        name: 'swagger-review',
        image: `${accountID}.dkr.ecr.${region}.amazonaws.com\/microservicemovies\/swagger-review:${tag}`,
        essential: true,
        memoryReservation: 300,
        cpu: 300,
        portMappings: [
          {
            containerPort: 3001,
            hostPort: 0,
            protocol: 'tcp'
          }
        ],
        environment: [
          {
            name: 'NODE_ENV',
            value: 'test'
          }
        ],
        logConfiguration: {
          logDriver: 'awslogs',
          options: {
            'awslogs-group': 'microservicemovies',
            'awslogs-region': region
          }
        }
      }
    ],
    family: 'microservicemovies-review-movies-td'
  };
  return taskDefinition;
}

module.exports = {
  createMoviesTaskDefinition
};
</code></pre>

<p>The first two containers should be almost identical to the containers in the previous Task Definition. Review the Swagger container definition.</p>

<h5>Web - <em>web-review_task.js</em></h5>

<pre><code class="javascript">function createWebTaskDefinition(accountID, region, tag, usersURL, moviesURL) {
  const taskDefinition = {
    containerDefinitions: [
      {
        name: 'web-service-review',
        image: `${accountID}.dkr.ecr.${region}.amazonaws.com\/microservicemovies\/web-service-review:${tag}`,
        essential: true,
        memoryReservation: 300,
        cpu: 300,
        portMappings: [
          {
            containerPort: 9000,
            hostPort: 0,
            protocol: 'tcp'
          }
        ],
        environment: [
          {
            name: 'NODE_ENV',
            value: 'test'
          },
          {
            name: 'REACT_APP_USERS_SERVICE_URL',
            value: usersURL
          },
          {
            name: 'REACT_APP_MOVIES_SERVICE_URL',
            value: moviesURL
          }
        ],
        logConfiguration: {
          logDriver: 'awslogs',
          options: {
            'awslogs-group': 'microservicemovies',
            'awslogs-region': region
          }
        }
      },
    ],
    family: 'microservicemovies-review-web-td'
  };
  return taskDefinition;
}

module.exports = {
  createWebTaskDefinition
};
</code></pre>

<p>Notice how we&rsquo;re passing in values for the environment variables. You could also use HashiCorp&rsquo;s <a href="https://www.vaultproject.io/">Vault</a> project to better manage secrets and variables.</p>

<h4>Create script to register Task Definitions</h4>

<p>Next, add a new file called <em>tasks.js</em> to &ldquo;ecs/scripts&rdquo;:</p>

<pre><code class="javascript">const AWS = require('aws-sdk');

const createUsersTaskDefinition = require('../tasks/users-review_task').createUsersTaskDefinition;
const createMoviesTaskDefinition = require('../tasks/movies-review_task').createMoviesTaskDefinition;
const createWebTaskDefinition = require('../tasks/web-review_task').createWebTaskDefinition;

const port = require('./listener').getPort;


// globals

const AWS_ACCOUNT_ID = process.env.AWS_ACCOUNT_ID;
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID;
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY;
const AWS_USERNAME = process.env.AWS_USERNAME;
const AWS_CONFIG_REGION = 'us-west-2';
const SHORT_GIT_HASH = process.env.CIRCLE_SHA1.substring(0, 7);
const LOAD_BALANCER_DNS = 'http://microservicemovies-review-476947634.us-west-2.elb.amazonaws.com';


// config

AWS.config = new AWS.Config();
AWS.config.accessKeyId = AWS_ACCESS_KEY_ID;
AWS.config.secretAccessKey = AWS_SECRET_ACCESS_KEY;
AWS.config.region = AWS_CONFIG_REGION;


// init aws services

const ecs = new AWS.ECS();
const iam = new AWS.IAM();


// methods

function ensureAuthenticated() {
  return new Promise((resolve, reject) =&gt; {
    const params = { UserName: AWS_USERNAME };
    iam.getUser(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function registerTaskDef(task) {
  return new Promise((resolve, reject) =&gt; {
    const params = task;
    ecs.registerTaskDefinition(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function registerUsersTD() {
  const task = createUsersTaskDefinition(AWS_ACCOUNT_ID, AWS_CONFIG_REGION, SHORT_GIT_HASH);
  return registerTaskDef(task)
  .then((res) =&gt; {
    console.log('Task Registered!');
    console.log(res.taskDefinition.taskDefinitionArn);
  })
  .catch((err) =&gt; {
    console.log(err);
  });
}

function registerMoviesTD() {
  const task = createMoviesTaskDefinition(AWS_ACCOUNT_ID, AWS_CONFIG_REGION, SHORT_GIT_HASH);
  return registerTaskDef(task)
  .then((res) =&gt; {
    console.log('Task Registered!');
    console.log(res.taskDefinition.taskDefinitionArn);
  })
  .catch((err) =&gt; {
    console.log(err);
  });
}

function registerWebTD(usersURL, moviesURL) {
  const task = createWebTaskDefinition(AWS_ACCOUNT_ID, AWS_CONFIG_REGION, SHORT_GIT_HASH, usersURL, moviesURL);
  return registerTaskDef(task)
  .then((res) =&gt; {
    console.log('Task Registered!');
    console.log(res.taskDefinition.taskDefinitionArn);
  })
  .catch((err) =&gt; {
    console.log(err);
  });
}


// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
  return port();
})
.then((port) =&gt; {
  const usersURL = `${LOAD_BALANCER_DNS}:${port}/users`;
  const moviesURL = `${LOAD_BALANCER_DNS}:${port}/movies`;
  registerUsersTD();
  registerMoviesTD();
  registerWebTD(usersURL, moviesURL);
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<p>Here, we pulled in the <code>getPort</code> function from the <em>listener.js</em> file, created the individual Task Definitions, and then passed the definitions to the <code>registerTaskDefinition</code> function to register them on AWS. Review the official AWS SDK <a href="http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/ECS.html#registerTaskDefinition-property">documentation</a> for more info.</p>

<p>Update the <code>Deploy</code> command in <em>.circle/config.yml</em>:</p>

<pre><code class="yaml">- run:
    name: Deploy
    command: |
      npm install
      node ecs/scripts/setup.js
      sh ecs/scripts/ecr.sh
      node ecs/scripts/tasks.js
</code></pre>

<p>Commit and push your code to GitHub. Once the Circle build passes, make sure the Task Definitions were created:</p>

<p><a href="/images/blog/on-demand-environments/aws-ecs-task-definitions.png"><img src="/images/blog/on-demand-environments/aws-ecs-task-definitions.png" alt="aws ecs task definitions" /></a></p>

<p>Also, make sure the <code>REACT_APP_USERS_SERVICE_URL</code> and <code>REACT_APP_MOVIES_SERVICE_URL</code> environment variables were added correctly to the <code>microservicemovies-review-web-td</code> Task Definition by clicking the Task Definition name, selecting the latest revision, and then expanding the <code>web-service-review</code> container:</p>

<p><a href="/images/blog/on-demand-environments/aws-ecs-web-task-definition.png"><img src="/images/blog/on-demand-environments/aws-ecs-web-task-definition.png" alt="aws ecs web task definition" /></a></p>

<h3>(4) Create Target Groups</h3>

<p><a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html">Target Group</a>s are used to link the Application Load Balancer (ALB) to the container instances, which we just defined.</p>

<p>Create a new script in &ldquo;scripts&rdquo; called <em>alb.js</em>:</p>

<pre><code class="js">const AWS = require('aws-sdk');


// globals

const AWS_ACCOUNT_ID = process.env.AWS_ACCOUNT_ID;
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID;
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY;
const AWS_USERNAME = process.env.AWS_USERNAME;
const AWS_CONFIG_REGION = 'us-west-2';
const SHORT_GIT_HASH = process.env.CIRCLE_SHA1.substring(0, 7);
const VPC_ID='UPDATE_ME';

let USERS_TARGET_GROUP_ARN;
let MOVIES_TARGET_GROUP_ARN;
let WEB_TARGET_GROUP_ARN;


// config

AWS.config = new AWS.Config();
AWS.config.accessKeyId = AWS_ACCESS_KEY_ID;
AWS.config.secretAccessKey = AWS_SECRET_ACCESS_KEY;
AWS.config.region = AWS_CONFIG_REGION;


// init aws services

const elbv2 = new AWS.ELBv2();
const iam = new AWS.IAM();


// methods

function ensureAuthenticated() {
  return new Promise((resolve, reject) =&gt; {
    const params = { UserName: AWS_USERNAME };
    iam.getUser(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function addTargetGroup(service, port, path) {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      Name: `${SHORT_GIT_HASH}-${service}`,
      Port: port,
      Protocol: 'HTTP',
      VpcId: VPC_ID,
      HealthCheckPath: path
    };
    elbv2.createTargetGroup(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}


// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
  return addTargetGroup('users', '3000', '/users/ping');
})
.then((res) =&gt; {
  USERS_TARGET_GROUP_ARN = res.TargetGroups[0].TargetGroupArn;
  console.log('Target Group Added!');
  return addTargetGroup('movies', '3000', '/movies/ping');
})
.then((res) =&gt; {
  MOVIES_TARGET_GROUP_ARN = res.TargetGroups[0].TargetGroupArn;
  console.log('Target Group Added!');
  return addTargetGroup('web', '9000', '/');
})
.then((res) =&gt; {
  WEB_TARGET_GROUP_ARN = res.TargetGroups[0].TargetGroupArn;
  console.log('Target Group Added!');
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<p>Make sure to add the correct VPC ID in the script, and then take note of the <code>addTargetGroup</code> function:</p>

<pre><code class="javascript">function addTargetGroup(service, port, path) {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      Name: `${SHORT_GIT_HASH}-${service}`,
      Port: port,
      Protocol: 'HTTP',
      VpcId: VPC,
      HealthCheckPath: path
    };
    elbv2.createTargetGroup(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}
</code></pre>

<p>Again, the <code>name</code> should be unique, so we used a portion of the Git commit SHA in it. The <code>port</code> refers back to the container port, and the <code>HealthCheckPath</code> is used by the load balancer to ensure the container is running.</p>

<table>
<thead>
<tr>
<th> Task Name             </th>
<th> Port </th>
<th> Path         </th>
</tr>
</thead>
<tbody>
<tr>
<td> users-service-review  </td>
<td> 3000 </td>
<td> /users/ping  </td>
</tr>
<tr>
<td> movies-service-review </td>
<td> 3000 </td>
<td> /movies/ping </td>
</tr>
<tr>
<td> web-review            </td>
<td> 9000 </td>
<td> /            </td>
</tr>
</tbody>
</table>


<p>After the Target Groups are created, we grabbed the returned <a href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Name</a> (ARN) and assigned it to a variable, which we&rsquo;ll end up using shortly when we set up the Listeners. For more on registering Target Groups, review the official <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html">documentation</a>.</p>

<p>Update the <code>Deploy</code> command in <em>.circle/config.yml</em>:</p>

<pre><code class="yaml">- run:
    name: Deploy
    command: |
      npm install
      node ecs/scripts/setup.js
      sh ecs/scripts/ecr.sh
      node ecs/scripts/tasks.js
      node ecs/scripts/alb.js
</code></pre>

<p>Commit and push your changes to GitHub. Make sure the Circle build passes. Within the <a href="https://console.aws.amazon.com/ec2/">EC2 Dashboard</a>, click &ldquo;Target Groups&rdquo; on the navigation pane, and you should see three new Target Groups:</p>

<p><a href="/images/blog/on-demand-environments/aws-target-groups.png"><img src="/images/blog/on-demand-environments/aws-target-groups.png" alt="aws target groups" /></a></p>

<h3>(5) Add the Listener and Rules</h3>

<p>A <a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html">Listener</a> forwards traffic from the load balancer to a specific Target Group.</p>

<h4>Add Listener</h4>

<p>Add the following function to <em>alb.js</em>:</p>

<pre><code class="javascript">function addListener(port) {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      DefaultActions: [
        {
          TargetGroupArn: DEFAULT_TARGET_GROUP_ARN,
          Type: 'forward'
        }
      ],
      LoadBalancerArn: LOAD_BALANCER_ARN,
      Port: port,
      Protocol: 'HTTP'
    };
    elbv2.createListener(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}
</code></pre>

<p>And add then update the following variable:</p>

<pre><code class="javascript">const DEFAULT_TARGET_GROUP_ARN = 'UPDATE_ME';
const LOAD_BALANCER_ARN = 'UPDATE_ME';
</code></pre>

<h4>Get open port</h4>

<p>Before we can create a new Listener, we need to find an open port on the Application Load Balancer to add it to. So, import the <code>getPort</code> function that we created before:</p>

<pre><code class="javascript">const port = require('./listener').getPort;
</code></pre>

<p>Update the promise chain:</p>

<pre><code class="javascript">// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
  return addTargetGroup('users', '3000', '/users/ping');
})
.then((res) =&gt; {
  USERS_TARGET_GROUP_ARN = res.TargetGroups[0].TargetGroupArn;
  console.log('Target Group Added!');
  return addTargetGroup('movies', '3000', '/movies/ping');
})
.then((res) =&gt; {
  MOVIES_TARGET_GROUP_ARN = res.TargetGroups[0].TargetGroupArn;
  console.log('Target Group Added!');
  return addTargetGroup('web', '9000', '/');
})
.then((res) =&gt; {
  WEB_TARGET_GROUP_ARN = res.TargetGroups[0].TargetGroupArn;
  console.log('Target Group Added!');
  return addListener(MAX_PORT);
})
.then((res) =&gt; {
  LISTENER_ARN = res.Listeners[0].ListenerArn;
  console.log(`Listener added on port ${res.Listeners[0].Port}!`);
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<p>Be sure to add <code>let LISTENER_ARN;</code> to the top as well.</p>

<h4>Add rules</h4>

<p>Finally, add some rules to the Listener:</p>

<pre><code class="javascript">function addRule(targetGroup, pattern, listener, priority) {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      Actions: [
        {
          TargetGroupArn: targetGroup,
          Type: 'forward'
        }
     ],
     Conditions: [
      {
        Field: 'path-pattern',
        Values: [pattern]
      }
     ],
     ListenerArn: listener,
     Priority: priority
    };
    elbv2.createRule(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}
</code></pre>

<p>Update the promise chain again:</p>

<pre><code class="javascript">// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
  return addTargetGroup('users', '3000', '/users/ping');
})
.then((res) =&gt; {
  USERS_TARGET_GROUP_ARN = res.TargetGroups[0].TargetGroupArn;
  console.log('Target Group Added!');
  return addTargetGroup('movies', '3000', '/movies/ping');
})
.then((res) =&gt; {
  MOVIES_TARGET_GROUP_ARN = res.TargetGroups[0].TargetGroupArn;
  console.log('Target Group Added!');
  return addTargetGroup('web', '9000', '/');
})
.then((res) =&gt; {
  WEB_TARGET_GROUP_ARN = res.TargetGroups[0].TargetGroupArn;
  console.log('Target Group Added!');
  return port();
})
.then((port) =&gt; {
  return addListener(port);
})
.then((res) =&gt; {
  LISTENER_ARN = res.Listeners[0].ListenerArn;
  console.log(`Listener added on port ${res.Listeners[0].Port}!`);
  return addRule(USERS_TARGET_GROUP_ARN, '/users*', LISTENER_ARN, 1);
})
.then((res) =&gt; {
  console.log('Rule Added!');
  return addRule(MOVIES_TARGET_GROUP_ARN, '/movies*', LISTENER_ARN, 2);
})
.then((res) =&gt; {
  console.log('Rule Added!');
  return addRule(MOVIES_TARGET_GROUP_ARN, '/docs*', LISTENER_ARN, 3);
})
.then((res) =&gt; {
  console.log('Rule Added!');
  return addRule(WEB_TARGET_GROUP_ARN, '/*', LISTENER_ARN, 4);
})
.then((res) =&gt; {
  console.log('Rule Added!');
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<p>Commit and push your changes. After the build passes, make sure the Listener was added to the Application Load Balancer:</p>

<p><a href="/images/blog/on-demand-environments/aws-load-balancer-listeners.png"><img src="/images/blog/on-demand-environments/aws-load-balancer-listeners.png" alt="aws load balancer listeners" /></a></p>

<p>Also, make sure the Listener has four Rules:</p>

<p><a href="/images/blog/on-demand-environments/aws-listeners-rules.png"><img src="/images/blog/on-demand-environments/aws-listeners-rules.png" alt="aws listeners rules" /></a></p>

<h3>(6) Create a new Service</h3>

<p>A <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html">Service</a> is used to spin up and run a number of Tasks within the ECS Cluster. Since we&rsquo;ve already pre-configured the Cluster and assigned EC2 instances to it, we can simply create a new Service that uses the Cluster resources.</p>

<p>Start by adding a new file called <em>services.js</em> to &ldquo;ecs/scripts&rdquo;:</p>

<pre><code class="javascript">const AWS = require('aws-sdk');


// globals

const AWS_ACCOUNT_ID = process.env.AWS_ACCOUNT_ID;
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID;
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY;
const AWS_USERNAME = process.env.AWS_USERNAME;
const AWS_CONFIG_REGION = 'us-west-2';
const SHORT_GIT_HASH = process.env.CIRCLE_SHA1.substring(0, 7);


// config

AWS.config = new AWS.Config();
AWS.config.accessKeyId = AWS_ACCESS_KEY_ID;
AWS.config.secretAccessKey = AWS_SECRET_ACCESS_KEY;
AWS.config.region = AWS_CONFIG_REGION;


// init aws services

const ecs = new AWS.ECS();
const iam = new AWS.IAM();


// methods

function ensureAuthenticated() {
  return new Promise((resolve, reject) =&gt; {
    const params = { UserName: AWS_USERNAME };
    iam.getUser(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function addService(service) {
  return new Promise((resolve, reject) =&gt; {
    const params = service;
    ecs.createService(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<p>Next, add a new directory to &ldquo;ecs&rdquo; called &ldquo;services&rdquo;, and then add the following files:</p>

<ol>
<li><em>users-review_service.js</em></li>
<li><em>movies-review_service.js</em></li>
<li><em>web-review_service.js</em></li>
</ol>


<h5>Users - <em>users-review_service.js</em></h5>

<pre><code class="javascript">function createUsersService(cluster, name, targetGroup) {
  const params = {
    cluster: cluster,
    serviceName: name,
    taskDefinition: 'microservicemovies-review-users-td',
    loadBalancers: [
      {
        targetGroupArn: targetGroup,
        containerName: "users-service-review",
        containerPort: 3000
      }
    ],
    desiredCount: 1,
    role: "ecsServiceRole"
  };
  return params;
}

module.exports = {
  createUsersService
};
</code></pre>

<h5>Movies - <em>movies-review_service.js</em></h5>

<pre><code class="javascript">function createMoviesService(cluster, name, targetGroup) {
  const params = {
    cluster: cluster,
    serviceName: name,
    taskDefinition: 'microservicemovies-review-movies-td',
    loadBalancers: [
      {
        targetGroupArn: targetGroup,
        containerName: "movies-service-review",
        containerPort: 3000
      }
    ],
    desiredCount: 1,
    role: "ecsServiceRole"
  };
  return params;
}

module.exports = {
  createMoviesService
};
</code></pre>

<h5>Web - <em>web-review_service.js</em></h5>

<pre><code class="javascript">function createWebService(cluster, name, targetGroup) {
  const params = {
    cluster: cluster,
    serviceName: name,
    taskDefinition: 'microservicemovies-review-web-td',
    loadBalancers: [
      {
        targetGroupArn: targetGroup,
        containerName: "web-service-review",
        containerPort: 9000
      }
    ],
    desiredCount: 1,
    role: "ecsServiceRole"
  };
  return params;
}

module.exports = {
  createWebService
};
</code></pre>

<p>Update <em>services.js</em>:</p>

<pre><code class="javascript">const AWS = require('aws-sdk');

const createUsersService = require('../services/users-review_service').createUsersService;
const createMoviesService = require('../services/movies-review_service').createMoviesService;
const createWebService = require('../services/web-review_service').createWebService;


// globals

const AWS_ACCOUNT_ID = process.env.AWS_ACCOUNT_ID;
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID;
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY;
const AWS_USERNAME = process.env.AWS_USERNAME;
const AWS_CONFIG_REGION = 'us-west-2';
const SHORT_GIT_HASH = process.env.CIRCLE_SHA1.substring(0, 7);
const LOAD_BALANCER_ARN = 'arn:aws:elasticloadbalancing:us-west-2:046505967931:loadbalancer/app/microservicemovies-review/493be740ee6aea54';
const CLUSTER_NAME = 'microservicemovies-review';

let USERS_TARGET_GROUP_ARN;
let MOVIES_TARGET_GROUP_ARN;
let WEB_TARGET_GROUP_ARN;


// config

AWS.config = new AWS.Config();
AWS.config.accessKeyId = AWS_ACCESS_KEY_ID;
AWS.config.secretAccessKey = AWS_SECRET_ACCESS_KEY;
AWS.config.region = AWS_CONFIG_REGION;


// init aws services

const ecs = new AWS.ECS();
const iam = new AWS.IAM();
const elbv2 = new AWS.ELBv2();


// methods

function ensureAuthenticated() {
  return new Promise((resolve, reject) =&gt; {
    const params = { UserName: AWS_USERNAME };
    iam.getUser(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function addService(service) {
  return new Promise((resolve, reject) =&gt; {
    const params = service;
    ecs.createService(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function getTargetGroups() {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      LoadBalancerArn: LOAD_BALANCER_ARN
    };
    elbv2.describeTargetGroups(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}


// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
  return getTargetGroups();
})
.then((res) =&gt; {
  const groups = res.TargetGroups.filter((group) =&gt; {
    return group.TargetGroupName.includes(SHORT_GIT_HASH);
  });
  for (const group of groups) {
    if (group.TargetGroupName.includes('users')) {
      USERS_TARGET_GROUP_ARN = group.TargetGroupArn;
    }
    if (group.TargetGroupName.includes('movies')) {
      MOVIES_TARGET_GROUP_ARN = group.TargetGroupArn;
    }
    if (group.TargetGroupName.includes('web')) {
      WEB_TARGET_GROUP_ARN = group.TargetGroupArn;
    }
  }
  const userServiceParams = createUsersService(
    CLUSTER_NAME, `${SHORT_GIT_HASH}-users`, USERS_TARGET_GROUP_ARN);
  return addService(userServiceParams);
})
.then((res) =&gt; {
  console.log('Service Added!');
  const moviesServiceParams = createMoviesService(
    CLUSTER_NAME, `${SHORT_GIT_HASH}-movies`, MOVIES_TARGET_GROUP_ARN);
  return addService(moviesServiceParams);
})
.then((res) =&gt; {
  console.log('Service Added!');
  const webServiceParams = createWebService(
    CLUSTER_NAME, `${SHORT_GIT_HASH}-web`, WEB_TARGET_GROUP_ARN);
  return addService(webServiceParams);
})
.then((res) =&gt; {
  console.log('Service Added!');
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<p>Update the <code>Deploy</code> command in <em>.circle/config.yml</em>:</p>

<pre><code class="yaml">- run:
    name: Deploy
    command: |
      npm install
      node ecs/scripts/setup.js
      sh ecs/scripts/ecr.sh
      node ecs/scripts/tasks.js
      node ecs/scripts/alb.js
      node ecs/scripts/services.js
</code></pre>

<p>Again, commit and push to GitHub, and then ensure:</p>

<ol>
<li>The Circle build passes</li>
<li>The Services were created on the <code>microservicemovies-review</code> Cluster</li>
<li>Each Service has a running Task associated with it</li>
<li>Three Target Groups were created, each with health targets</li>
<li>A Listener was added to the Application Load Balancer with four Rules</li>
<li>Logs were added to <a href="https://console.aws.amazon.com/cloudwatch">CloudWatch</a></li>
<li>The following endpoints work-

<ul>
<li><a href="http://LOAD_BALANCER_DNS:LISTENER_PORT">http://LOAD_BALANCER_DNS:LISTENER_PORT</a></li>
<li><a href="http://LOAD_BALANCER_DNS:LISTENER_PORT/users/ping">http://LOAD_BALANCER_DNS:LISTENER_PORT/users/ping</a></li>
<li><a href="http://LOAD_BALANCER_DNS:LISTENER_PORT/movies/ping">http://LOAD_BALANCER_DNS:LISTENER_PORT/movies/ping</a></li>
</ul>
</li>
</ol>


<p><a href="/images/blog/on-demand-environments/aws-ecs-services.png"><img src="/images/blog/on-demand-environments/aws-ecs-services.png" alt="aws ecs services" /></a></p>

<h2>Testing</h2>

<p>To run the end-to-end tests, first change each of the URLs in <em>tests/sample.test.js</em> from <code>http://localhost:3007</code> to <code>http://LOAD_BALANCER_DNS:LISTENER_PORT</code>, and then run the tests locally:</p>

<pre><code class="sh">$ testcafe firefox tests/**/*.js
</code></pre>

<p>They should pass.</p>

<h2>Teardown</h2>

<p>Next, let&rsquo;s add a script to handle the tearing down of the AWS resources after testing is complete.</p>

<p>Main Steps:</p>

<ol>
<li>Remove Listener</li>
<li>Remove Target Groups</li>
<li>Remove Services</li>
</ol>


<p>Start by adding a new script called <em>teardown.js</em> to &ldquo;ecs/scripts&rdquo;.</p>

<h3>(1) Remove Listener</h3>

<pre><code class="javascript">const AWS = require('aws-sdk');


// globals

const AWS_ACCOUNT_ID = process.env.AWS_ACCOUNT_ID;
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID;
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY;
const AWS_USERNAME = process.env.AWS_USERNAME;
const AWS_CONFIG_REGION = 'us-west-2';
const LOAD_BALANCER_ARN = 'UPDATE_ME';

const ARGS = process.argv.slice(2);
const USAGE_MESSAGE = '\nusage:\n  teardown.js LISTENER_PORT COMMIT_SHA\n';

if (!ARGS[0] || !ARGS[1]) {
  console.log(USAGE_MESSAGE);
  return;
}

const SHORT_GIT_HASH = ARGS[1].substring(0, 7);


// config

AWS.config = new AWS.Config();
AWS.config.accessKeyId = AWS_ACCESS_KEY_ID;
AWS.config.secretAccessKey = AWS_SECRET_ACCESS_KEY;
AWS.config.region = AWS_CONFIG_REGION;


// init aws services

const iam = new AWS.IAM();
const elbv2 = new AWS.ELBv2();


// methods

function ensureAuthenticated() {
  return new Promise((resolve, reject) =&gt; {
    const params = { UserName: AWS_USERNAME };
    iam.getUser(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function getListeners() {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      LoadBalancerArn: LOAD_BALANCER_ARN
    };
    elbv2.describeListeners(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function removeListener(listener) {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      ListenerArn: listener
    };
    elbv2.deleteListener(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}


// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
  return getListeners();
})
.then((res) =&gt; {
  const listener = res.Listeners.filter((listener) =&gt; {
    return parseInt(listener.Port) === parseInt(ARGS[0]);
  })[0];
  if (!listener) {
    throw new Error('Listener does not exist.');
  }
  return removeListener(listener.ListenerArn);
})
.then((res) =&gt; {
  console.log('Listener Removed!');
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<p>Here, we grabbed all Listeners in <code>getListeners</code> and then filtered them by the provided listener port. From there, we deleted the listener. Be sure to update <code>LOAD_BALANCER_ARN</code> before continuing.</p>

<p>Test this out:</p>

<pre><code class="sh">$ node ecs/scripts/teardown.js LISTENER_PORT COMMIT_SHA
</code></pre>

<h3>(2) Remove Target Groups</h3>

<p>Add the following two functions to <em>teardown.js</em>:</p>

<pre><code class="javascript">function getTargetGroups() {
  return new Promise((resolve, reject) =&gt; {
    var params = {};
    elbv2.describeTargetGroups(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function removeTargetGroup(targetgroup) {
  return new Promise((resolve, reject) =&gt; {
    var params = { TargetGroupArn: targetgroup };
    elbv2.deleteTargetGroup(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}
</code></pre>

<p>Then update the promise chain:</p>

<pre><code class="javascript">// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
  return getListeners();
})
.then((res) =&gt; {
  const listener = res.Listeners.filter((listener) =&gt; {
    return parseInt(listener.Port) === parseInt(ARGS[0]);
  })[0];
  if (!listener) {
    throw new Error('Listener does not exist.');
  }
  return removeListener(listener.ListenerArn);
})
.then((res) =&gt; {
  console.log('Listener Removed!');
  return getTargetGroups();
})
.then((res) =&gt; {
  const targets = res.TargetGroups.filter((group) =&gt; {
    return group.TargetGroupName.includes(SHORT_GIT_HASH);
  });
  if (!targets.length) {
    throw new Error('Targets do not exist.');
  }
  const promises = targets.map((target) =&gt; {
    return removeTargetGroup(target.TargetGroupArn);
  });
  return Promise.all(promises);
})
.then(() =&gt; {
  console.log('Target Groups Removed!');
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<h3>(3) Remove Services</h3>

<p>Finally, add the following functions to remove the Services:</p>

<pre><code class="javascript">function updateServiceCount(serviceName) {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      service: serviceName,
      desiredCount: 0,
      cluster: CLUSTER_NAME
    };
    ecs.updateService(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}

function removeService(serviceName) {
  return new Promise((resolve, reject) =&gt; {
    var params = {
      service: serviceName,
      cluster: CLUSTER_NAME
    };
    ecs.deleteService(params, (err, data) =&gt; {
      if (err) { reject(err); }
      resolve(data);
    });
  });
}
</code></pre>

<p>Add the variables to the top:</p>

<pre><code class="javascript">const CLUSTER_NAME = 'microservicemovies-review';
const ecs = new AWS.ECS();
</code></pre>

<p>Then, update the promise chain:</p>

<pre><code class="javascript">// main

return ensureAuthenticated()
.then((data) =&gt; {
  console.log(`Welcome ${data.User.UserName}!`);
  return getListeners();
})
.then((res) =&gt; {
  const listener = res.Listeners.filter((listener) =&gt; {
    return parseInt(listener.Port) === parseInt(ARGS[0]);
  })[0];
  if (!listener) {
    throw new Error('Listener does not exist.');
  }
  return removeListener(listener.ListenerArn);
})
.then((res) =&gt; {
  console.log('Listener Removed!');
  return getTargetGroups();
})
.then((res) =&gt; {
  const targets = res.TargetGroups.filter((group) =&gt; {
    return group.TargetGroupName.includes(SHORT_GIT_HASH);
  });
  if (!targets.length) {
    throw new Error('Targets do not exist.');
  }
  const promises = targets.map((target) =&gt; {
    return removeTargetGroup(target.TargetGroupArn);
  });
  return Promise.all(promises);
})
.then(() =&gt; {
  console.log('Target Groups Removed!');
  return updateServiceCount(`${SHORT_GIT_HASH}-users`);
})
.then(() =&gt; {
  console.log('Service Updated!');
  return removeService(`${SHORT_GIT_HASH}-users`);
})
.then(() =&gt; {
  console.log('Service Removed!');
  return updateServiceCount(`${SHORT_GIT_HASH}-movies`);
})
.then(() =&gt; {
  console.log('Service Updated!');
  return removeService(`${SHORT_GIT_HASH}-movies`);
})
.then((res) =&gt; {
  console.log('Service Removed!');
  return updateServiceCount(`${SHORT_GIT_HASH}-web`);
})
.then((res) =&gt; {
  console.log('Service Updated!');
  return removeService(`${SHORT_GIT_HASH}-web`);
})
.then((res) =&gt; {
  console.log('Service removed!');
})
.catch((err) =&gt; { console.log(err); });
</code></pre>

<p>Test it out again:</p>

<pre><code class="sh">$ node ecs/scripts/teardown.js LISTENER_PORT COMMIT_SHA
</code></pre>

<p>You should see:</p>

<pre><code class="sh">Welcome AWS_USERNAME!
Listener Removed!
Target Groups Removed!
Service Updated!
Service Removed!
Service Updated!
Service Removed!
Service Updated!
Service removed!
</code></pre>

<p>Make sure all associated AWS Resources were removed as well.</p>

<h2>Conclusion and Next Steps</h2>

<p>That&rsquo;s it!</p>

<h3>Development Workflow</h3>

<p>Let&rsquo;s quickly review the development workflow&hellip;</p>

<ol>
<li>Local development

<ul>
<li>Create a new feature branch from the master branch</li>
<li>Make code changes</li>
<li>Commit and push code to GitHub</li>
</ul>
</li>
<li>Continuous integration

<ul>
<li>Open a new PR against the development branch</li>
<li>A new build is then triggered on Circle CI</li>
<li>If the build passes, manually merge the PR</li>
<li>A new build is triggered again on Circle CI</li>
<li>If the build passes, deployment occurs&hellip;</li>
</ul>
</li>
<li>Deployment on AWS via deployment scripts</li>
<li>Testing

<ul>
<li>Update then run the end-to-end tests</li>
</ul>
</li>
<li>Teardown

<ul>
<li>Run the teardown script</li>
</ul>
</li>
</ol>


<h3>What&rsquo;s next?</h3>

<p>Did you test out the Swagger docs? They don&rsquo;t work. What&rsquo;s happening? Fix this on your own.</p>

<p>Developers will inevitably forget to run the teardown script. Configure an <a href="AWS%20Lambda">AWS Lambda</a> function to run nightly to tear down all AWS resources associated with the on-demand test environments.</p>

<p>Add <a href="https://www.vaultproject.io/">Vault</a> and <a href="https://www.consul.io/">Consul</a> into the mix to handle secrets and environment variables.</p>

<p>Grab the final code from the <a href="https://github.com/mjhea0/microservice-movies/releases/tag/v4">v4</a> tag of the <a href="https://github.com/mjhea0/microservice-movies">microservice-movies</a> repo. Please add questions and/or comments below. Cheers!</p>
]]></content>
  </entry>
  
</feed>
