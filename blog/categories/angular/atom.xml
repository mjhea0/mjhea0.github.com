<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: angular | Michael Herman]]></title>
  <link href="http://mjhea0.github.com/blog/categories/angular/atom.xml" rel="self"/>
  <link href="http://mjhea0.github.com/"/>
  <updated>2015-04-09T11:38:01-06:00</updated>
  <id>http://mjhea0.github.com/</id>
  <author>
    <name><![CDATA[Michael Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing AngularJS with Protractor and Karma - part 1]]></title>
    <link href="http://mjhea0.github.com/blog/2015/04/09/testing-angularjs-with-protractor-and-karma-part-1/"/>
    <updated>2015-04-09T09:06:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2015/04/09/testing-angularjs-with-protractor-and-karma-part-1</id>
    <content type="html"><![CDATA[<p><strong>This article details how to test a simple AngularJS application using unit tests and end-to-end (E2E) tests.</strong></p>

<div style="text-align:center;">
  <img src="https://raw.githubusercontent.com/mjhea0/angular-testing-tutorial/master/img/angular-karma.png" style="max-width: 100%; border:0;" alt="angular + karma">
</div>




<br>


<ul>
<li>Part 1 - In the first part we'll look at unit tests, which ensure that small, isolated pieces of code (e.g., a unit) behave as expected <strong>(current)</strong>.</li>
<li>Part 2 - In part two we'll address E2E tests, which verify that all the pieces of code (units) fit together by simulating the user experience through browser automation (coming soon!).</li>
</ul>


<p><em>Contents</em>:</p>

<ol>
<li><a href="#project-setup">Project Setup</a></li>
<li><a href="#config-files">Configuration Files</a></li>
<li><a href="#unit-tests">Unit Tests</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>


<p>To accomplish this we will be using <a href="http://karma-runner.github.io/">Karma</a> v0.12.31 (test runner) and <a href="http://chaijs.com/">Chai</a> v2.2.0 (assertions) for the unit tests (along with <a href="https://github.com/karma-runner/karma-mocha">Karma-Mocha</a>) and <a href="http://angular.github.io/protractor/#/">Protractor</a> v2.0.0 for the E2E tests. This article also uses <a href="https://angularjs.org/">Angular</a> v1.3.15. Be sure to take note of all dependencies and their versions in the <em>package.json</em> and <em>bower.json</em> files in the <a href="https://github.com/mjhea0/angular-testing-tutorial">repo</a>.</p>

<p>The repo includes the following tags:</p>

<ol>
<li><em>v1</em> - <a href="https://github.com/mjhea0/angular-testing-tutorial/releases/tag/v1">project boilerplate</a></li>
<li><em>v2</em> - <a href="https://github.com/mjhea0/angular-testing-tutorial/releases/tag/v2">adds testing boilerplate/configuration</a></li>
<li><em>v3</em> - <a href="https://github.com/mjhea0/angular-testing-tutorial/releases/tag/v3">adds unit tests</a></li>
<li><em>v4</em> - adds E2E tests (coming soon!)</li>
</ol>


<h2> <a name="project-setup">Project Setup</a></h2>


<p>Start by cloning the repo, checkout out the first tag, and then install the dependencies:</p>

<p><code>sh
$ git clone https://github.com/mjhea0/angular-testing-tutorial.git
$ cd angular-testing-tutorial
$ git checkout tags/v1
$ npm install &amp;&amp; bower install
</code></p>

<p>Run the app:</p>

<p><code>sh
$ gulp
</code></p>

<p>Navigate to <a href="http://localhost:8888">http://localhost:8888</a> to view the live app.</p>

<div style="text-align:center;">
  <img src="https://raw.githubusercontent.com/mjhea0/angular-testing-tutorial/master/img/live-app.png" style="max-width: 100%; border:0;" alt="angular app">
</div>




<br>


<p>Test it out. Once done, kill the server and checkout the second tag:</p>

<p><code>sh
$ git checkout tags/v2
</code></p>

<p>There should now be a "tests" folder and a few more tasks in the Gulpfile.</p>

<p>Run the unit tests:</p>

<p><code>sh
$ gulp unit
</code></p>

<p>They should pass:</p>

<p><code>sh
[05:28:02] Using gulpfile ~/angular-testing-tutorial/Gulpfile.js
[05:28:02] Starting 'unit'...
INFO [karma]: Karma v0.12.31 server started at http://localhost:9876/
INFO [launcher]: Starting browser Chrome
INFO [Chrome 41.0.2272 (Mac OS X 10.10.2)]: Connected on socket JBQp0aEyu8KSqUfGoxsd with id 94772581
Chrome 41.0.2272 (Mac OS X 10.10.2): Executed 2 of 2 SUCCESS (0.061 secs / 0.002 secs)
[05:28:05] Finished 'unit' after 3.23 s
</code></p>

<p>Now for the e2e tests:</p>

<ol>
<li>1st terminal window: <code>webdriver-manager start</code></li>
<li>2nd terminal window: <code>gulp</code></li>
<li>3rd terminal window: <code>gulp e2e</code></li>
</ol>


<p>They should pass as well:</p>

<p>```sh
[05:29:45] Using gulpfile ~/angular-testing-tutorial/Gulpfile.js
[05:29:45] Starting 'e2e'...
Using the selenium server at http://localhost:4444/wd/hub
[launcher] Running 1 instances of WebDriver
.</p>

<p>Finished in 0.921 seconds
1 test, 1 assertion, 0 failures</p>

<p>[launcher] 0 instance(s) of WebDriver still running
[launcher] chrome #1 passed
```</p>

<p>So, what's happening here...</p>

<h2><a name="config-files">Configuration Files</a></h2>


<p>There are two configuration files in the "tests" folder - one for Karma and the other for Protractor.</p>

<h3>Karma</h3>

<p><a href="http://karma-runner.github.io/">Karma</a> is a test runner built by the AngularJS team that executes the unit tests and reports the results.</p>

<p>Let's look the config file, <em>karma.conf.js</em>:</p>

<p>```javascript
module.exports = function(config) {
  config.set({</p>

<pre><code>// base path that will be used to resolve all patterns
basePath: '.',

// frameworks to use
frameworks: ['mocha', 'chai'],

// list of files / patterns to load in the browser
files: [
  '../app/bower_components/angular/angular.js',
  '../app/bower_components/jquery/dist/jquery.js',
  '../app/bower_components/angular-strap/dist/angular-strap.js',
  '../app/bower_components/angular-strap/dist/angular-strap.tpl.js',
  '../app/bower_components/angular-mocks/angular-mocks.js',
  '../app/bower_components/angular-route/angular-route.js',
  './unit/*.js',
  '../app/app.js'
],

// test result reporter
reporters: ['progress'],

// web server port
port: 9876,

// enable / disable colors in the output (reporters and logs)
colors: true,

// level of logging
logLevel: config.LOG_INFO,

// enable / disable watching file and executing tests whenever any file changes
autoWatch: true,

// start these browsers
browsers: ['Chrome'],

// Continuous Integration mode
singleRun: false
</code></pre>

<p>  });
};
```</p>

<blockquote><p>You can also tun <code>karma init</code> to be guided through the creation of a config file.</p></blockquote>

<p>Be sure to read over the comments for an overview of each config option. For more information, review the <a href="http://karma-runner.github.io/0.12/config/configuration-file.html">official documentation</a>.</p>

<h3>Protractor</h3>

<p><a href="http://angular.github.io/protractor/#/">Protractor</a> provides a nice wrapper around <a href="http://seleniumhq.github.io/selenium/docs/api/javascript/">Selenium Webdriver</a> to run tests against an AngularJS application running live in a browser.</p>

<p>Turn your attention to the Protractor config file, <em>protractor.conf.js</em>:</p>

<p><code>javascript
exports.config = {
  seleniumAddress: 'http://localhost:4444/wd/hub',
  specs: ['tests/e2e/*.js']
};
</code></p>

<p>This tells protractor where to find the test files (called specs) and specifies the address that the Selenium server is running on. Simple.</p>

<p>Ready to start testing?</p>

<h2><a name="unit-tests">Unit Tests</a></h2>


<p>We'll start with unit tests since they are much easier to write, debug, and maintain.</p>

<p>Keep in mind that unit tests, by definition, only test isolated units of code so they rely heavily on mocking fake data. This can add much complexity to your tests and can decrease the effectiveness of the actual tests. For example, if you're mocking out an HTTP request to a back-end API, then you're not really testing your application. Instead you're simulating the request and then using fake JSON data to simulate the response back. The tests may run faster, but they are much less effective. Unfortunately, there is no right answer here.</p>

<p>When starting out, mock out only the most expensive requests and make the actual API call in other situations. Over time you will develop a better sense of which requests should be mocked and which should not.</p>

<p>Finally, if you decide not to mock a request in a specific test, then the test is no longer a unit test since it's not testing an isolated unit of code. Instead you are testing multiple units, which is an integration test. For simplicity, we will continue to refer to such tests as unit tests.</p>

<p>With that, let's create some tests, broken up by controller!</p>

<h3>TestOneController</h3>

<p>Take a look at the code in the first controller:</p>

<p>```javascript
myApp.controller('TestOneController', function($scope) {
  $scope.greeting = "Hello, World!";
  $scope.newText = undefined;
  $scope.changeGreeting = function() {</p>

<pre><code>$scope.greeting = $scope.newText;
</code></pre>

<p>  };
});
```</p>

<p>What's happening here? Confirm your answer by running your app and watching what happens. Now, what can/should we test?</p>

<ol>
<li><code>greeting</code> has an initial value of <code>"Hello, World!"</code>, and</li>
<li>The <code>changeGreeting</code> function updates <code>greeting</code>.</li>
</ol>


<p>You probably noticed that we are already testing this in the spec:</p>

<p>```javascript
describe('TestOneController', function () {</p>

<p>  var controller = null;
  $scope = null;</p>

<p>  beforeEach(function () {</p>

<pre><code>module('myApp');
</code></pre>

<p>  });</p>

<p>  beforeEach(inject(function ($controller, $rootScope) {</p>

<pre><code>$scope = $rootScope.$new();
controller = $controller('TestOneController', {
  $scope: $scope
});
</code></pre>

<p>  }));</p>

<p>  it('initially has a greeting', function () {</p>

<pre><code>assert.equal($scope.greeting, "Hello, World!");
</code></pre>

<p>  });</p>

<p>  it('clicking the button changes the changes the greeting', function () {</p>

<pre><code>$scope.newText = "Hi!";
$scope.changeGreeting();
assert.equal($scope.greeting, "Hi!");
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>What's happening?</p>

<ol>
<li>The <code>describe</code> block is used to group similar tests.</li>
<li>The module, <code>myApp</code>, is loaded, into each test, in the first <code>beforeEach</code> block, which instantiates a clean testing environment.</li>
<li>The dependencies are injected, a new scope is created, and the controller is instantiated in the second <code>beforeEach</code>.</li>
<li>Each <code>it</code> function is a separate test, which includes a title, in human readable form, and a function with the actual test code.</li>
<li>The first test asserts that the initial state of <code>greeting</code> is <code>"Hello, World!"</code>.</li>
<li>Meanwhile, the second test assets that the <code>changeGreeting()</code> function actually changes the value of <code>greeting</code>.</li>
</ol>


<p>Make sense?</p>

<p><em>In most cases, unit tests simply change the scope and assert that the results are what we expected.</em></p>

<blockquote><p>In general, when testing controllers, you inject then register the controller with a <code>beforeEach</code> block, along with the <code>$rootScope</code> and then test that the functions within the controller act as expected.</p></blockquote>

<p>Run the tests again to ensure they still pass - <code>gulp unit</code>.</p>

<p>What else could we test? How about if <code>newText</code> doesn't change - e.g., if the user submits the button without entering any text in the input box - then the value of <code>greeting</code> should stay the same. Try writing this on your own, before you look at my answer:</p>

<p><code>javascript
it('clicking the button does not change the greeting if text is not inputed', function () {
  $scope.changeGreeting();
  assert.equal($scope.greeting, "Hello, World!");
});
</code></p>

<p>Try running this. It should fail.</p>

<p><code>sh
Chrome 41.0.2272 (Mac OS X 10.10.2) TestOneController clicking the button does not change the greeting FAILED
  AssertionError: expected undefined to equal 'Hello, World!'
</code></p>

<p>So, we've revealed a bug. We could fix this by adding validation to the input box to ensure the end user enters a value or we could update <code>changeGreeting</code> to only update <code>greeting</code> if <code>newText</code> is not <code>undefined</code>. Let's go with the latter.</p>

<p>```javascript
$scope.changeGreeting = function() {
  if ($scope.newText !== undefined) {</p>

<pre><code>$scope.greeting = $scope.newText;
</code></pre>

<p>  }
};
```</p>

<p>Save the code, and then run the tests again:</p>

<p><code>sh
$ gulp unit
[08:28:18] Using gulpfile ~/angular-testing-tutorial/Gulpfile.js
[08:28:18] Starting 'unit'...
INFO [karma]: Karma v0.12.31 server started at http://localhost:9876/
INFO [launcher]: Starting browser Chrome
INFO [Chrome 41.0.2272 (Mac OS X 10.10.2)]: Connected on socket HGnVC5-cAXOZjAsrSCWj with id 83240025
Chrome 41.0.2272 (Mac OS X 10.10.2): Executed 3 of 3 SUCCESS (0.065 secs / 0.001 secs)
[08:28:21] Finished 'unit' after 3.13 s
</code></p>

<p>Nice!</p>

<blockquote><p>Since controllers are used to bind data to the template (via scope), unit tests are perfect for testing the controller logic - e.g., what happens to the scope as the controller runs - while E2E tests ensure that the template is updated accordingly.</p></blockquote>

<h3>TestTwoController</h3>

<p>Start by analyzing the code:</p>

<p>```javascript
myApp.controller('TestTwoController', function($scope) {
  $scope.total = 6;
  $scope.newItem = undefined;
  $scope.items = [1, 2, 3];
  $scope.add = function () {</p>

<pre><code>$scope.items.push($scope.newItem);
$scope.total = 0;
for(var i = 0; i &lt; $scope.items.length; i++){
  $scope.total += parseInt($scope.items[i]);
}
</code></pre>

<p>  };
});
```</p>

<p>What should we test? Take out a pen and paper and write down everything that should be tested. Once done, write the code. Check your code against mine.</p>

<p>Be sure to start with the following boilerplate:</p>

<p>```javascript
describe('TestTwoController', function () {</p>

<p>  var controller = null;
  $scope = null;</p>

<p>  beforeEach(function () {</p>

<pre><code>module('myApp');
</code></pre>

<p>  });</p>

<p>  beforeEach(inject(function ($controller, $rootScope) {</p>

<pre><code>$scope = $rootScope.$new();
controller = $controller('TestTwoController', {
  $scope: $scope
});
</code></pre>

<p>  }));</p>

<p>});
```</p>

<h4>Test 1: The initial value of <code>total</code></h4>

<p><code>javascript
it('initially has a total', function () {
  assert.equal($scope.total, 6);
});
</code></p>

<h4>Test 2: The initial value of <code>items</code></h4>

<p><code>javascript
it('initially has items', function () {
  assert.isArray($scope.items);
  assert.deepEqual($scope.items, [1, 2, 3]);
});
</code></p>

<h4>Test 3: The <code>add</code> function updates the <code>total</code> and <code>items</code> array when a value is added</h4>

<p><code>javascript
it('the `add` function updates the `total` and `items` array when a value is added', function () {
  $scope.newItem = 7;
  $scope.add();
  assert.equal($scope.total, 13);
  assert.deepEqual($scope.items, [1, 2, 3, 7]);
});
</code></p>

<h4>Test 4: The <code>add</code> function does not update the <code>total</code> and <code>items</code> array when an empty value is added</h4>

<p><code>javascript
it('does not update the `total` and `items` array when an empty value is added', function () {
  $scope.newItem = undefined;
  $scope.add();
  assert.equal($scope.total, 6);
  assert.deepEqual($scope.items, [1, 2, 3]);
  $scope.newItem = 22;
  $scope.add();
  assert.equal($scope.total, 28);
  assert.deepEqual($scope.items, [1, 2, 3, 22]);
});
</code></p>

<h4>Run</h4>

<p>Each test should be straightforward. Run the tests. There should be one failure:</p>

<p><code>javascript
Chrome 41.0.2272 (Mac OS X 10.10.2) TestTwoController does not update the `total` and `items` array when an empty value is added FAILED
  AssertionError: expected NaN to equal 6
</code></p>

<p>Update the code, adding a conditional again:</p>

<p>```javascript
$scope.add = function () {
  if(typeof $scope.newItem == 'number') {</p>

<pre><code>$scope.items.push($scope.newItem);
$scope.total = 0;
for(var i = 0; i &lt; $scope.items.length; i++){
  $scope.total += parseInt($scope.items[i]);
}
</code></pre>

<p>  }
```</p>

<p>Also update the partial:</p>

<p><code>html
&lt;input type="number" ng-model="newItem"&gt;
</code></p>

<p>Run it again:</p>

<p><code>sh
$ gulp unit
[09:56:10] Using gulpfile ~/angular-testing-tutorial/Gulpfile.js
[09:56:10] Starting 'unit'...
INFO [karma]: Karma v0.12.31 server started at http://localhost:9876/
INFO [launcher]: Starting browser Chrome
INFO [Chrome 41.0.2272 (Mac OS X 10.10.2)]: Connected on socket Lbv1sROpYrEHgotlmJZf with id 91008249
Chrome 41.0.2272 (Mac OS X 10.10.2): Executed 7 of 7 SUCCESS (0.082 secs / 0.003 secs)
[09:56:13] Finished 'unit' after 3.05 s
</code></p>

<p>Success!</p>

<p>Did I miss anything? Comment below.</p>

<h3>TestThreeController</h3>

<p>Again, check out the code in <em>app.js</em>:</p>

<p><code>javascript
myApp.controller('TestThreeController', function($scope) {
  $scope.modal = {title: 'Hi!', content: 'This is a message!'};
});
</code></p>

<p>What can we test here?</p>

<p><code>javascript
it('initially has a modal', function () {
  assert.isObject($scope.modal);
  assert.deepEqual($scope.modal, {title: 'Hi!', content: 'This is a message!'});
});
</code></p>

<p>Perhaps a better question is: What <em>should</em> we test here? Is the above test really necessary? Probably not. But we may need to test it out more in the future if we build out the functionality. Let's go for it!</p>

<h4>Update <em>app.js</em>:</h4>

<p>```javascript
myApp.controller('TestThreeController', function($scope, $modal) {
  $scope.modalNumber = 1;
  var myModal = $modal({scope: $scope, template: 'modal.tpl.html', show: false});
  $scope.showModal = function() {</p>

<pre><code>myModal.$promise.then(myModal.show);
</code></pre>

<p>  };
  $scope.changeModalText = function() {</p>

<pre><code>$scope.modalNumber++;
};
</code></pre>

<p>});
```</p>

<p>Here we are defined a custom template, <code>modal.tpl.html</code>, to be used for the modal text and then we assigned <code>$scope.modalNumber</code> to <code>1</code> as well as function to iterate the number.</p>

<h4>Add <em>modal.tpl.html</em>:</h4>

<p>```html</p>

<div class="modal" tabindex="-1" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-body">
        <span>
          <button class="btn btn-default" ng-click="changeModalText()">Iterate</button>
          &nbsp;&#8594;&nbsp;
          <span></span>
        </span>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" ng-click="$hide()">Close</button>
      </div>
    </div>
  </div>
</div>


<p>```</p>

<p>Add this template to the "app" folder.</p>

<h4>Update <em>three.html</em>:</h4>

<p>Finally, update the partial:</p>

<p>```html</p>

<h2>Just a modal</h2>


<p><button type="button" class="btn btn-lg btn-default" data-template="modal.tpl.html" bs-modal="modal">
  Launch modal!
</button>
```</p>

<p>Run the app to make sure everything works, and then update the test...</p>

<h4>Test redux</h4>

<p>```javascript
describe('TestThreeController', function () {</p>

<p>  var controller = null;
  $scope = null;</p>

<p>  beforeEach(function () {</p>

<pre><code>module('myApp');
</code></pre>

<p>  });</p>

<p>  beforeEach(inject(function ($controller, $rootScope) {</p>

<pre><code>$scope = $rootScope.$new();
controller = $controller('TestThreeController', {
  $scope: $scope
});
</code></pre>

<p>  }));</p>

<p>  it('initially has a modalNumber', function () {</p>

<pre><code>assert.equal($scope.modalNumber, 1);
</code></pre>

<p>  });</p>

<p>  it('updates the <code>modalNumber</code> when a value is added', function () {</p>

<pre><code>$scope.changeModalText();
assert.equal($scope.modalNumber, 2);
$scope.changeModalText();
assert.equal($scope.modalNumber, 3);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Notice how we're no longer testing that a modal is present. We'll test that via the E2E tests.</p>

<h3>TestFourController</h3>

<p>Finally, let's test the AJAX request:</p>

<p>```sh
myApp.controller('TestFourController', function($scope, $http) {
  $scope.repos = [];
  $scope.loadRepos = function () {</p>

<pre><code>$http.get('https://api.github.com/repositories').then(function (repos) {
  $scope.repos = repos.data;
});
</code></pre>

<p>  };
});
```</p>

<p>Remember the discussion earlier on mocking HTTP requests? Well, here's probably a good place to actually use a mocking library since this request hits an external API. To do this, we can use the <code>$httpBackend</code> directive from the <a href="https://docs.angularjs.org/api/ngMock">angular-mocks</a> library.</p>

<p>First, let's first add the <em>mock.js</em> file found in the <a href="https://github.com/mjhea0/angular-testing-tutorial/tree/master/tests/mock">repo</a> into a new folder called "mock" within the "tests" folder. This module use <code>angular.module().value</code> to set a JSON value to use as the fake data.</p>

<p>Next, add the test:</p>

<p>```javascript
describe('TestFourController', function () {</p>

<p>  var controller = null;
  var $scope = null;
  var $httpBackend = null;
  var mockedDashboardJSON = null;</p>

<p>  beforeEach(function () {</p>

<pre><code>module('myApp', 'mockedDashboardJSON');
</code></pre>

<p>  });</p>

<pre><code>beforeEach(inject(function ($controller, $rootScope, _$httpBackend_, defaultJSON) {
  $httpBackend = _$httpBackend_;
  $scope = $rootScope.$new();
  $httpBackend.when('GET','https://api.github.com/repositories').respond(defaultJSON.fakeData);
  controller = $controller('TestFourController', {
      $scope: $scope
  });
}));

afterEach(function () {
  $httpBackend.verifyNoOutstandingExpectation();
  $httpBackend.verifyNoOutstandingRequest();
});
</code></pre>

<p>  it('initially has repos', function () {</p>

<pre><code>assert.isArray($scope.repos);
assert.deepEqual($scope.repos, []);
</code></pre>

<p>  });</p>

<p>  it('clicking the button updates the repos', function () {</p>

<pre><code>  $scope.loadRepos();
  $httpBackend.flush();
  assert.equal($scope.repos.length, 100);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>What's happening?</p>

<ol>
<li>Essentially, here we're injecting <code>defaultJSON</code> so that when the app tries to make the HTTP request, it triggers <code>$httpBackend</code>, which, in turn, uses the <code>defaultJSON</code> value.</li>
<li>Did you notice the underscores surrounding the <code>$httpBackend</code> directive? This is a hack that allows us to use the dependency in multiple tests. You can find more information on this from the <a href="https://docs.angularjs.org/api/ngMock/function/angular.mock.inject">official documentation</a>.</li>
<li>Finally, we're using an <code>afterEach</code> block to check that we're not missing any HTTP requests in our tests via the <code>verifyNoOutstandingExpectation()</code> and <code>verifyNoOutstandingRequest()</code> methods. Again, you can read more about these methods from the <a href="https://docs.angularjs.org/api/ngMock/service/$httpBackend">Angular docs</a>.</li>
</ol>


<p>Test it out!</p>

<h3>Routes</h3>

<p>How about the routes, templates, and partials?</p>

<p>```javascript
describe('routes', function(){</p>

<p>  beforeEach(function () {</p>

<pre><code>module('myApp');
</code></pre>

<p>  });</p>

<p>  beforeEach(inject(function (<em>$httpBackend</em>, <em>$route</em>, <em>$location</em>, $rootScope) {</p>

<pre><code>$httpBackend = _$httpBackend_;
$route = _$route_;
$location = _$location_;
$scope = $rootScope.$new();
</code></pre>

<p>  }));</p>

<p>  it('should load the one.html template', function(){</p>

<pre><code>$httpBackend.whenGET('partals/one.html').respond('...');
$scope.$apply(function() {
  $location.path('/one');
});
assert.equal($route.current.templateUrl, 'partials/one.html');
assert.equal($route.current.controller, 'TestOneController');
</code></pre>

<p>  });</p>

<p>});
```</p>

<ol>
<li>When the route is loaded, the <code>current</code> property is updated. We then test to ensure that the current controller and template are <code>TestOneController</code> and <code>partials/one.html</code>, respectively.</li>
<li>Did you notice that we wrapped the route change inside the <code>$apply</code> callback? Since unit tests don't run the full Angular app, we had to simulate it by triggering the <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest">digest cycle</a>.</li>
<li>Curious about <code>WhenGET</code>? Check out the <a href="https://docs.angularjs.org/api/ngMock/service/$httpBackend">Angular documentation</a>. Take note of <code>ExpectGET</code> as well. Can you re-write the above test to use <code>ExpectGET</code>?</li>
</ol>


<p>Make sure to run the tests one last time:</p>

<p><code>sh
$ gulp unit
[05:20:07] Using gulpfile ~/angular-testing-tutorial/Gulpfile.js
[05:20:07] Starting 'unit'...
INFO [karma]: Karma v0.12.31 server started at http://localhost:9876/
INFO [launcher]: Starting browser Chrome
INFO [Chrome 41.0.2272 (Mac OS X 10.10.2)]: Connected on socket R5qQUcjswAbpcvMK6JKu with id 67365006
Chrome 41.0.2272 (Mac OS X 10.10.2): Executed 12 of 12 SUCCESS (0.16 secs / 0.027 secs)
[05:20:10] Finished 'unit' after 3.44 s
</code></p>

<h2><a name="conclusion">Conclusion</a></h2>


<p>That's it for unit tests. In the next part (coming soon!), we'll test the entire application, front to back, using end-to-end (E2E) tests via Protractor.</p>

<p>Checkout the third tag, <code>v3</code>, to view all the completed unit tests:</p>

<p><code>sh
$ git checkout tags/v3
</code></p>

<p>Ready for more?</p>

<p>Try adding some <a href="http://mherman.org/blog/2014/06/12/primer-on-angularjs-service-types/">Factories/Services</a> and Filters to your app to continue practicing. Since the syntax is relatively the same for testing all parts of an Angular app, you should be able to extend your testing knowledge to both factories and filters. Take a look at this <a href="https://github.com/mjhea0/thinkful-mentor/tree/master/angular/projects/angular-unit-test-demo/app/components">example</a> for help getting started. Once you feel comfortable with factories, controllers, and filters, move on to testing more difficult components, like directives, resources, and animations. Good luck!</p>

<p>Comment below with questions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kickstarting Angular with Gulp and Browserify, Part 2 - Browserify]]></title>
    <link href="http://mjhea0.github.com/blog/2014/08/15/kickstarting-angular-with-gulp-and-browserify-part-2/"/>
    <updated>2014-08-15T09:56:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2014/08/15/kickstarting-angular-with-gulp-and-browserify-part-2</id>
    <content type="html"><![CDATA[<p>Hello. Welcome to the second half. <a href="http://mherman.org/blog/2014/08/14/kickstarting-angular-with-gulp">Last time</a>, we built a nice Angular starter project, utilizing Gulp and Bower. Let's take this a step further and add the power of <a href="http://browserify.org/">Browserify</a> into the mix. Before you read any further, check out the <a href="https://github.com/substack/browserify-handbook#introduction">Introduction</a> to the <a href="https://github.com/substack/browserify-handbook">Browserify Handbook</a> to learn about the problems that Browserify solves.</p>

<blockquote><p>Just want the code? Get it <a href="https://github.com/mjhea0/angular-gulp-browserify-seed">here</a>.</p></blockquote>

<h2>Install Dependencies</h2>

<p>Let's get Browserify installed...</p>

<h3>First, install Browserify globally</h3>

<p><code>sh
$ npm install -g browserify
</code></p>

<h3>Then install the Gulp dependencies locally</h3>

<p><code>sh
$ npm install gulp-browserify gulp-concat --save
</code></p>

<p>The <a href="https://github.com/deepak1556/gulp-browserify">former</a> dependency allows you to run Browserify from Gulp, while the <a href="https://github.com/wearefractal/gulp-concat">latter</a> concatenates all the Bowerserify dependencies into a single JS file.</p>

<h2>Update the Gulpfile</h2>

<h3>Update the requirements</h3>

<p><code>javascript
var browserify = require('gulp-browserify');
var concat = require('gulp-concat');
</code></p>

<h3>Add the following tasks</h3>

<p>```javascript
gulp.task('browserify', function() {
  gulp.src(['app/js/main.js'])
  .pipe(browserify({</p>

<pre><code>insertGlobals: true,
debug: true
</code></pre>

<p>  }))
  .pipe(concat('bundled.js'))
  .pipe(gulp.dest('./app/js'))
});
```</p>

<h3>Now update the default task</h3>

<p><code>javascript
// default task
gulp.task('default',
  ['lint', 'browserify', 'connect']
);
</code></p>

<h2>Update the HTML</h2>

<p>Change the included JS file in <em>index.html</em>.</p>

<p>From:</p>

<p>```html</p>

<script src="./js/main.js"></script>


<p>```</p>

<p>To:</p>

<p>```html</p>

<script src="./js/bundled.js"></script>


<p>```</p>

<h3>Test</h3>

<p>To recap:</p>

<ol>
<li>We added Browserify</li>
<li>Updated the build process so that a single JS file named <em>bundled.js</em> is created</li>
<li>Updated <em>index.html</em> to include that new JS file</li>
</ol>


<p><code>sh
$ gulp
</code></p>

<p>Navigate to <a href="http://localhost:8888/">http://localhost:8888/</a> and you should still see:</p>

<p>```
Angular-Gulp-Browserify-Starter</p>

<p>Testing...
```</p>

<p>Notice the <em>bundled.js</em> file. Again, this is generated by <code>concat('bundled.js')</code>. If you kill the server, then try to run it again, you'll get an error. Essentially, the <em>bundled.js</em> file needs to be removed before each run. So update the <code>clean</code> task:</p>

<p>```sh
gulp.task('clean', function() {</p>

<pre><code>gulp.src('./dist/*')
  .pipe(clean({force: true}));
gulp.src('./app/js/bundled.js')
  .pipe(clean({force: true}));
</code></pre>

<p>});
```</p>

<h2>Browserify</h2>

<p>Remember all those Bower components in the <em>index.js</em> file? Let's clean up that mess by requiring our app's dependencies with Browserify.</p>

<h3>Update the HTML (again)</h3>

<p>```html
&lt;!DOCTYPE html>
<html ng-app="SampleApp">
  <head lang="en"></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;
&lt;title&gt;Angular-Gulp-Browserify-Starter&lt;/title&gt;
&lt;!-- styles --&gt;
&lt;link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.css"/&gt;
&lt;link rel="stylesheet" href="bower_components/fontawesome/css/font-awesome.css"/&gt;
&lt;link rel="stylesheet" href="bower_components/animate.css/animate.css"/&gt;
&lt;link rel="stylesheet" href="css/main.css"/&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;div class="container"&gt;
  &lt;h1&gt;Angular-Gulp-Browserify-Starter&lt;/h1&gt;
  &lt;!-- views --&gt;
  &lt;div ng-view&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;!-- scripts --&gt;
&lt;script src="bower_components/jquery/dist/jquery.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;
&lt;script src="./js/bundled.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Now, we need to use Browserify to require the following depencies in our app:</p>

<ol>
<li><em>angular.js</em></li>
<li><em>angular-route.js</em></li>
<li><em>angular-animate.js</em></li>
</ol>


<blockquote><p>Why don't we replace all of our Bower components? It's good to use both Bower and Browserify in case NPM does not have a certain dependency that Bower may have. The point of this example is to show you how to use both.</p></blockquote>

<h3>Install Requirements</h3>

<p>Go ahead and install the requirements we need via NPM:</p>

<p><code>sh
$ npm install angular angular-route angular-animate --save
</code></p>

<h3>Update JS</h3>

<p>```javascript
(function () {</p>

<p>  'use strict';</p>

<p>  require('angular');
  require('angular-route');
  require('angular-animate');</p>

<p>  angular.module('SampleApp', ['ngRoute', 'ngAnimate'])</p>

<p>  .config([</p>

<pre><code>'$locationProvider',
'$routeProvider',
function($locationProvider, $routeProvider) {
  $locationProvider.hashPrefix('!');
  // routes
  $routeProvider
    .when("/", {
      templateUrl: "./partials/partial1.html",
      controller: "MainController"
    })
    .otherwise({
       redirectTo: '/'
    });
}
</code></pre>

<p>  ]);</p>

<p>  //Load controller
  angular.module('SampleApp')</p>

<p>  .controller('MainController', [</p>

<pre><code>'$scope',
function($scope) {
  $scope.test = "Testing...";
}
</code></pre>

<p>  ]);</p>

<p>}());
```</p>

<p>Now we can include various modules the "Node-way" using <code>require()</code> calls, giving you access to nearly 90,000 <a href="https://www.npmjs.org/">modules</a>.</p>

<h3>Controller</h3>

<p>Let's abstract out the controller to a file of its own.</p>

<p>First, update <em>main.js</em> again:</p>

<p>```javascript
(function () {</p>

<p>  'use strict';</p>

<p>  require('angular');
  require('angular-route');
  require('angular-animate');
  var mainCtrl = require('./controllers/mainctrl');</p>

<p>  angular.module('SampleApp', ['ngRoute', 'ngAnimate'])</p>

<p>  .config([</p>

<pre><code>'$locationProvider',
'$routeProvider',
function($locationProvider, $routeProvider) {
  $locationProvider.hashPrefix('!');
  // routes
  $routeProvider
    .when("/", {
      templateUrl: "./partials/partial1.html",
      controller: "MainController"
    })
    .otherwise({
       redirectTo: '/'
    });
}
</code></pre>

<p>  ])</p>

<p>  //Load controller
  .controller('MainController', ['$scope', mainCtrl]);</p>

<p>}());
```</p>

<p>Now create a new folder called "controllers" within "app/js". In the new folder add a new file called <em>mainctrl.js</em>:</p>

<p><code>javascript
module.exports = function($scope) {
  $scope.test = "Testing...";
  console.log("required!");
};
</code></p>

<p>This syntax should look familiar if you've worked with Node before. We use <code>exports</code> to expose the function, which we then have access to in <em>main.js</em> since it's part of the requirements.</p>

<h3>Test Again</h3>

<p><code>sh
$ gulp clean
$ gulp
</code></p>

<p>Navigate to <a href="http://localhost:8888/">http://localhost:8888/</a> to make sure everything still works.</p>

<h2>Update the Build</h2>

<p>Now that we have the <code>default</code> task working, let's update the build process so we can create a deployable build.</p>

<h3>Update the Gulpfile</h3>

<p>Add the following task to the <em>gulpfile</em>:</p>

<p>```javascript
gulp.task('browserifyDist', function() {
  gulp.src(['app/js/main.js'])
  .pipe(browserify({</p>

<pre><code>insertGlobals: true,
debug: true
</code></pre>

<p>  }))
  .pipe(concat('bundled.js'))
  .pipe(gulp.dest('./dist/js'))
});
```</p>

<p>This task simply updates where the <em>bundled.js</em> is stored after creation.</p>

<p>Finally, update the <code>build</code> task itself adding in the above task:</p>

<p><code>
// build task
gulp.task('build',
  ['lint', 'minify-css', 'browserifyDist', 'copy-html-files', 'copy-bower-components', 'connectDist']
);
</code></p>

<h3>Create a Build</h3>

<p><code>sh
$ gulp build
</code></p>

<p>Check out the live app at <a href="http://localhost:9999/#!/">http://localhost:9999/</a>. Deploy your app, if you'd like.</p>

<h3>Conclusion</h3>

<p>Let's recap. Over the past two posts, we've created a sample app that can be used as a seed for all of your Angular projects. Want to use this in your own projects?</p>

<ol>
<li>Clone the <a href="https://github.com/mjhea0/angular-gulp-browserify-seed">repo</a></li>
<li>Install the global requirements: <code>npm install -g gulp bower browserify</code></li>
<li>Install the local requirements: <code>npm install</code></li>
<li>Install the Bower components: <code>bower install</code></li>
<li>Run locally: <code>gulp</code></li>
<li>Create a build: <code>gulp build</code></li>
</ol>


<p>I encourage you to add your favorite libraries and modules, which is easy to do. Looking for a client side dependency? Be sure to check <a href="https://www.npmjs.org/">NPM</a> first before relying on Bower so you can take advantage of the simple <code>require</code> calls, via Browserify, which reduces code clutter and enables you to write modular, re-usable code.</p>

<p><strong>As always, I'd love to hear your feedback. How are you using Browserify in your projects? Comment below.</strong></p>

<p>Thanks for reading.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kickstarting Angular with Gulp and Browserify, Part 1 - Gulp and Bower]]></title>
    <link href="http://mjhea0.github.com/blog/2014/08/14/kickstarting-angular-with-gulp/"/>
    <updated>2014-08-14T08:17:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2014/08/14/kickstarting-angular-with-gulp</id>
    <content type="html"><![CDATA[<p>Let's develop an Angular boilerplate. Why? Despite the plethora of Angular seeds/generators/templates/boilerplates/starters/etc. on Github, none of them will ever do <em>exactly</em> what you want unless you build your own, piece by piece. By designing your own, you will better understand each component as well as how each fits into the greater project. Stop fighting against a boilerplate that just doesn't fit your needs and start from scratch. Keep it simple, as you learn the process.</p>

<p><strong>In this first part, we'll start with Angular and Gulp, getting a working project setup. Next <a href="http://mherman.org/blog/2014/08/15/kickstarting-angular-with-gulp-and-browserify-part-2/#.U-4co4BdUZ0">time</a> we'll add Browserify into the mix.</strong></p>

<blockquote><p>This tutorial assumes you have Node.js installed and have working knowledge of NPM and Angular. Just want the code? Get it <a href="https://github.com/mjhea0/angular-gulp-browserify-seed">here</a>.</p></blockquote>

<h2>Project Setup</h2>

<h3>Install Dependencies</h3>

<h4>Setup a project folder and create a <em>package.json</em> file:</h4>

<p><code>sh
$ mkdir project_name &amp;&amp; cd project_name
$ npm init
</code></p>

<p>The <code>npm init</code> command helps you create your project's base configuration through an interactive prompt. Be sure to update the 'entry point' to 'gulpfile.js'. You can just accept the defaults on the remaining prompts.</p>

<p>Do the same for Bower:</p>

<p><code>sh
$ bower init
</code></p>

<p>Accept all the defaults. After the file is created update the <code>ignore</code> list:</p>

<p><code>javascript
"ignore": [
  "**/.*",
  "node_modules",
  "app/bower_components",
  "test",
  "tests"
],
</code></p>

<h4>Install global dependencies:</h4>

<p><code>sh
$ npm install -g gulp bower
</code></p>

<h4>Bower install directory</h4>

<p>You can specify where you want the dependencies (commonly known as bower components) installed to by adding a <em>.bowerrc</em> file and adding the following code:</p>

<p><code>javascript
{
  "directory": "/app/bower_components"
}
</code></p>

<h4>Install local dependencies:</h4>

<p><em>NPM</em></p>

<p><code>sh
$ npm install gulp bower gulp-clean gulp-jshint gulp-uglify gulp-minify-css gulp-connect --save
</code></p>

<p><em>Bower</em></p>

<p><code>sh
$bower install angular angular-animate angular-route jquery animate.css bootstrap fontawesome --save
</code></p>

<blockquote><p>The <code>--save</code> flag adds the dependencies to the <em>package.json</em> and <em>bower.json</em> files, respectively.</p></blockquote>

<p>We'll address each of these dependencies shortly. For now, be sure you understand the project's core dependencies:</p>

<ul>
<li><strong><a href="http://gulpjs.com/">Gulp</a></strong> is a Javascript task runner, used to automate repetitive tasks (i.e., minifying, linting, testing, building, compiling) to simplify the build process.</li>
<li><strong><a href="http://bower.io/">Bower</a></strong> manages front-end dependencies.</li>
</ul>


<h3>Folder Structure</h3>

<p>Let's setup a base folder structure:</p>

<p><code>sh
.
├── app
│   ├── bower_components
│   ├── css
│   │    └── main.css
│   ├── img
│   ├── index.html
│   ├── partials
│   │    ├── partial1.html
│   │    └── partial2.html
│   └── js
│   │    └── main.js
├── .bowerrc
├── .gitignore
├── bower.json
├── gulpfile.js
├── node_modules
└── package.json
</code></p>

<p>Add the files and folders not already included. This structure is based on the popular <a href="https://github.com/angular/angular-seed">Angular Seed</a> boilerplate, developed by the Angular team.</p>

<h3>Gulp</h3>

<p>To start, we just need the following code:</p>

<p>```javascript
// gulp
var gulp = require('gulp');</p>

<p>// plugins
var connect = require('gulp-connect');</p>

<p>gulp.task('connect', function () {
  connect.server({</p>

<pre><code>root: 'app/',
port: 8888
</code></pre>

<p>  });
});
```</p>

<p>This allows us to serve our future Angular app on a development server running on port 8888.</p>

<h3>Test</h3>

<p>Let's test it out. Add the word 'hi' to the <em>index.html</em> file, then run the following command:</p>

<p><code>sh
$ gulp connect
</code></p>

<p>Navigate to <a href="http://localhost:8888/">http://localhost:8888/</a> and you should see 'hi' staring back at you. Let's build a quick sample app. Keep the server running...</p>

<h2>Develop a Sample App</h2>

<h3><em>index.html</em></h3>

<p>```html
&lt;!DOCTYPE html>
<html ng-app="SampleApp">
  <head lang="en"></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;
&lt;title&gt;Angular-Gulp-Browserify-Starter&lt;/title&gt;
&lt;!-- styles --&gt;
&lt;link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.css"/&gt;
&lt;link rel="stylesheet" href="bower_components/fontawesome/css/font-awesome.css"/&gt;
&lt;link rel="stylesheet" href="bower_components/animate.css/animate.css"/&gt;
&lt;link rel="stylesheet" href="css/main.css"/&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;div class="container"&gt;
  &lt;h1&gt;Angular-Gulp-Browserify-Starter&lt;/h1&gt;
  &lt;!-- views --&gt;
  &lt;div ng-view&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;!-- scripts --&gt;
&lt;script src="bower_components/jquery/dist/jquery.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular/angular.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular-route/angular-route.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular-animate/angular-animate.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;
&lt;script src="js/main.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>This should look familiar. The <code>ng-app</code> directive initiates an Angular app while <code>ng-view</code> sets the stage for routing.</p>

<h3><em>main.js</em></h3>

<p>```javascript
(function () {</p>

<p>'use strict';</p>

<p>  angular.module('SampleApp', ['ngRoute', 'ngAnimate'])</p>

<p>  .config([</p>

<pre><code>'$locationProvider',
'$routeProvider',
function($locationProvider, $routeProvider) {
  $locationProvider.hashPrefix('!');
  // routes
  $routeProvider
    .when("/", {
      templateUrl: "./partials/partial1.html",
      controller: "MainController"
    })
    .otherwise({
       redirectTo: '/'
    });
}
</code></pre>

<p>  ]);</p>

<p>  //Load controller
  angular.module('SampleApp')</p>

<p>  .controller('MainController', [</p>

<pre><code>'$scope',
function($scope) {
  $scope.test = "Testing...";
}
</code></pre>

<p>  ]);</p>

<p>}());
```</p>

<p>Again, this should be relatively straightforward. We setup the basic Angular code to establish a route handler along with a controller that passes the variable <code>test</code> to the template.</p>

<h3><em>partial1.html</em></h3>

<p>Now let's add the partial template:</p>

<p>
```html</p>

<p>{{ test }}</p>


<p>```
</p>

<h3>Test</h3>

<p>Back in your browser, refresh the page. You should see the text:</p>

<p>```
Angular-Gulp-Browserify-Starter</p>

<p>Testing...
```</p>

<h2>Create the Build</h2>

<p>Now that our app is working locally, let's modify our <em>gulpfile.js</em> to generate a deployable build. Kill the server.</p>

<p>```javascript
// gulp
var gulp = require('gulp');</p>

<p>// plugins
var connect = require('gulp-connect');
var jshint = require('gulp-jshint');
var uglify = require('gulp-uglify');
var minifyCSS = require('gulp-minify-css');
var clean = require('gulp-clean');</p>

<p>// tasks
gulp.task('lint', function() {
  gulp.src(['./app/<strong>/*.js', '!./app/bower_components/</strong>'])</p>

<pre><code>.pipe(jshint())
.pipe(jshint.reporter('default'))
.pipe(jshint.reporter('fail'));
</code></pre>

<p>});
gulp.task('clean', function() {</p>

<pre><code>gulp.src('./dist/*')
  .pipe(clean({force: true}));
</code></pre>

<p>});
gulp.task('minify-css', function() {
  var opts = {comments:true,spare:true};
  gulp.src(['./app/<strong>/*.css', '!./app/bower_components/</strong>'])</p>

<pre><code>.pipe(minifyCSS(opts))
.pipe(gulp.dest('./dist/'))
</code></pre>

<p>});
gulp.task('minify-js', function() {
  gulp.src(['./app/<strong>/*.js', '!./app/bower_components/</strong>'])</p>

<pre><code>.pipe(uglify({
  // inSourceMap:
  // outSourceMap: "app.js.map"
}))
.pipe(gulp.dest('./dist/'))
</code></pre>

<p>});
gulp.task('copy-bower-components', function () {
  gulp.src('./app/bower_components/**')</p>

<pre><code>.pipe(gulp.dest('dist/bower_components'));
</code></pre>

<p>});
gulp.task('copy-html-files', function () {
  gulp.src('./app/<em>*/</em>.html')</p>

<pre><code>.pipe(gulp.dest('dist/'));
</code></pre>

<p>});
gulp.task('connect', function () {
  connect.server({</p>

<pre><code>root: 'app/',
port: 8888
</code></pre>

<p>  });
});
gulp.task('connectDist', function () {
  connect.server({</p>

<pre><code>root: 'dist/',
port: 9999
</code></pre>

<p>  });
});</p>

<p>// default task
gulp.task('default',
  ['lint', 'connect']
);
// build task
gulp.task('build',
  ['lint', 'minify-css', 'minify-js', 'copy-html-files', 'copy-bower-components', 'connectDist']
);
```</p>

<p><strong>What's happening here?</strong></p>

<ol>
<li><a href="https://github.com/spenceralger/gulp-jshint">gulp-jshint</a> checks for code quality in the JS files. If there are any issues the build fails and all errors output to the console.</li>
<li><a href="https://github.com/peter-vilja/gulp-clean">gulp-clean</a> removes the entire build folder so that we start fresh every time we generate a new build.</li>
<li><a href="https://github.com/terinjokes/gulp-uglify">gulp-uglify</a> and <a href="https://github.com/jonathanepollack/gulp-minify-css">gulp-minify-css</a> minify JS and CSS, respectively.</li>
</ol>


<h3>Build commands</h3>

<p><strong>Default</strong></p>

<p>The default task, <code>gulp</code>, is a compound task that runs both the <code>lint</code> and <code>connect</code> tasks. Again, this just serves the files in the "app" folder on <a href="http://localhost:8888/">http://localhost:8888/</a>.</p>

<p><strong>Build</strong></p>

<p>The build task creates a new directory called "dist", runs the linter, minifies the CSS and JS files, and copies all the HTML files and Bower Components. You can then see what the final build looks like on <a href="http://localhost:9999/">http://localhost:9999/</a> before deployment. You should also run the <code>clean</code> task before you generate a build.</p>

<p>Test this out:</p>

<p><code>sh
$ gulp clean build
</code></p>

<h2>Conclusion</h2>

<p>Well, hopefully you now have a better understanding of how Gulp can greatly simply the build process, handling a number of repetitive tasks. Next time we'll clean up some of the mess that the Bower components leave behind by adding Browserify into the mix and detail a nice workflow that you can use for all your Angular projects.</p>

<p>Leave questions and comments below. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Primer on AngularJS Services]]></title>
    <link href="http://mjhea0.github.com/blog/2014/06/12/primer-on-angularjs-service-types/"/>
    <updated>2014-06-12T07:39:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2014/06/12/primer-on-angularjs-service-types</id>
    <content type="html"><![CDATA[<h2>What's a service ...</h2>

<p>Much to my surprise, the Angular <a href="https://docs.angularjs.org/guide/services">documentation</a> provides a great definition of a service:</p>

<blockquote><p>Angular services are substitutable objects that are wired together using dependency injection (DI). You can use services to organize and share code across your app.</p>

<p>Angular services are:</p>

<ol>
<li>Lazily instantiated – Angular only instantiates a service when an application component depends on it.</li>
<li>Singletons – Each component dependent on a service gets a reference to the single instance generated by the service factory.</li>
</ol>


<p>Angular offers several useful services (like $http), but for most applications you'll also want to create your own.</p></blockquote>

<p>Services are powerful in that they help keep your code DRY by encapsulating functionality. From an architecture standpoint alone, services help separate out concerns, ensuring that each object is responsible for a single piece of functionality. For example, it's common for beginners to put <em>all</em> of their app's functionality into the controller. This is fine for smaller apps, but just know that it's not a good practice and your controller will balloon quickly as your app scales.</p>

<p>Get in the habit early on to separate concerns. If your controller is handling more than just defining the scope or initial state of your app, connecting your models and views, then it's are <em>probably</em> doing too much.</p>

<p>We are all (err, I am) guilty of this. Let's look at a very simple app ...</p>

<h4>HTML:</h4>

<p>
```html
&lt;!doctype html>
<html lang="en" ng-app='myApp'>
<head>
  <meta charset="UTF-8">
  <title>Angular Boilerplate</title>
  <!-- styles -->
  <link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/yeti/bootstrap.min.css" rel="stylesheet" media="screen">
  <link href="main.css" rel="stylesheet" media="screen">
</head>
  <body></p>

<pre><code>&lt;div class="container"&gt;
  &lt;div ng-controller="myController"&gt;
    &lt;h1&gt;Enter Quantity:&lt;/h1&gt;
    &lt;input type="number" ng-model="quantity"&gt;&lt;/p&gt;
    &lt;h2&gt;Total Cost: {{calculate(quantity) | currency}}&lt;/h2&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;!-- scripts --&gt;
&lt;script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.16/angular.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;
&lt;script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;script src="main.js" type="text/javascript"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```
</p>

<h4>Javascript:</h4>

<p>```javascript
var app = angular.module('myApp', [])</p>

<p>app.controller('myController', function($scope) {
  $scope.quantity = 100;
  $scope.calculate = function(number) {</p>

<pre><code>return number * 10;
</code></pre>

<p>  }
});
```</p>

<blockquote><p>You can grab the code from <a href="https://github.com/mjhea0/thinkful-mentor/tree/master/angular/fundamentals/services">this</a> repo or from <a href="http://jsfiddle.net/mjhea0/fS4P6/">JSFiddle</a>.</p></blockquote>

<p>So, this just takes an input value (integer or floating point) and multiplies it by 10 in the <code>calculate()</code> function, which then updates the DOM. Not only is the controller defining scope - but it also calculates the total. Despite this being a small app, too much is happening in the controller. We should separate out the calculate <code>function()</code> into a separate service.</p>

<h2>Creating a custom service</h2>

<p>By moving the business logic out of the controller, abstracting much of the code, our controller becomes leaner. <em>It's a good practice to write fat services and lean controllers</em>.</p>

<p>To do this, we are will use a service type called a factory, which is the most common type.</p>

<blockquote><p>This is a good time to stop and learn the major service types - constants, values, services, providers, and decorators. Check out <a href="http://angular-tips.com/blog/2013/08/understanding-service-types/">this</a> excellent article for more on the various service types and how and when to use them. <strong>All are slightly different, but, in general, all are dependency injected modules of functionality</strong>.</p></blockquote>

<p>Within the same JS file add the following code beneath the controller:</p>

<p>```javascript
// Service
app.factory('calculateService', function(){
  return {</p>

<pre><code>calculate: function(number){
  return number * 10
}
</code></pre>

<p> }
});
```</p>

<p>This code creates a service called <code>calculateService</code>. You may be wondering why we have to use the <code>factory()</code> method for this instead of just a regular function. It's simple: That method registers the service with Angular; and with Angular aware of its existence, it can be dependency injected into the controller, giving us access to the defined functions - e.g, <code>calculate()</code> within the controller. We can now use this in multiple places within our application, allowing for easy code reuse.</p>

<p>So, we have simply abstracted the logic of taking the user inputted number and multiplying it by 10.</p>

<p>Now update the controller:</p>

<p>```javascript
app.controller('myController', function($scope, calculateService) {
  $scope.quantity = 100;
   $scope.calculate = function(number) {</p>

<pre><code>return calculateService.calculate(number);
</code></pre>

<p>  }
});
```</p>

<p>And you're app should be working. Test it out. <a href="http://jsfiddle.net/mjhea0/Q9b23/">JSFiddle</a></p>

<h2>Conclusion</h2>

<p>Hopefully, you now have a better sense as to -</p>

<ul>
<li>What a service is,</li>
<li>Why you should use them, and</li>
<li>How to use them.</li>
</ul>


<p>Want some practice? Create separate services for each piece of functionality in <a href="https://github.com/mjhea0/thinkful-mentor/tree/master/angular/projects/waitstaff-calc/waitstaff-flask">this</a> app's controller. Remember: The controller is responsible for defining scope, all else should be moved out of the controller altogether.</p>

<p>If you need help, start by creating a service that handles the actual API calls. Perhaps use a service name of <code>getData</code> then set up functions for the different HTTP requests - i.e., <code>readData()</code> for a GET request and <code>writeData()</code> for a POST. Then when you use dependency injection to add this service to your controller, you can simply use the following syntax for accessing the <code>readData()</code> function in the controller:</p>

<p><code>javascript
getData.readData(some_argument)
</code></p>

<p>Presumably you would pass in an argument supplied by the user. Now you can access that function from the controller without knowing anything about the actual service except for how you use it. The controller is cleaner because you abstracted out all the messy code for making API calls.</p>

<p>Good luck!</p>
]]></content>
  </entry>
  
</feed>
