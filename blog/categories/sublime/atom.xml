<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sublime | Michael Herman]]></title>
  <link href="http://mjhea0.github.com/blog/categories/sublime/atom.xml" rel="self"/>
  <link href="http://mjhea0.github.com/"/>
  <updated>2015-03-06T10:53:22-07:00</updated>
  <id>http://mjhea0.github.com/</id>
  <author>
    <name><![CDATA[Michael Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Node with Docker - continuous integration and delivery]]></title>
    <link href="http://mjhea0.github.com/blog/2015/03/06/node-with-docker-continuous-integration-and-delivery/"/>
    <updated>2015-03-06T08:05:00-07:00</updated>
    <id>http://mjhea0.github.com/blog/2015/03/06/node-with-docker-continuous-integration-and-delivery</id>
    <content type="html"><![CDATA[<p>Welcome.</p>

<p><strong>This is a quick start guide for spinning up Docker containers that run NodeJS and Redis. We’ll look at a basic development workflow to manage the local development of an app, on Mac OS X, as well as continuous integration and delivery, step by step.</strong></p>

<div class="center-text">
  <img class="no-border" src="https://raw.githubusercontent.com/mjhea0/node-docker-workflow/master/_presentation/images/logo.png" style="max-width: 100%;" alt="logo">
</div>




<br>


<blockquote><p>This tutorial is ported from <a href="https://realpython.com/blog/python/docker-in-action-fitter-happier-more-productive/">Docker in Action - Fitter, Happier, More Productive</a>.</p></blockquote>

<p>We'll be using the following tools, technologies, and services in this post:</p>

<ol>
<li><a href="http://nodejs.org/">NodeJS</a> v0.12.0</li>
<li><a href="http://expressjs.com/">Express</a> v3.4.8</li>
<li><a href="http://redis.io/">Redis</a> v2.8.19</li>
<li><a href="https://www.docker.com/">Docker</a> v1.5.0</li>
<li><a href="http://boot2docker.io/">boot2docker</a> v1.5.0</li>
<li><a href="https://docs.docker.com/compose/">Docker Compose</a> v1.1.0</li>
<li><a href="https://hub.docker.com/">Docker Hub</a></li>
<li><a href="https://circleci.com/">CircleCI</a></li>
<li><a href="https://www.digitalocean.com/">Digital Ocean</a></li>
<li><a href="https://www.tutum.co/">Tutum</a></li>
</ol>


<blockquote><p>There's slides too! Check them out <a href="http://realpython.github.io/fitter-happier-docker/node.html#/">here</a>, if interested.</p></blockquote>

<h2>Docker?</h2>

<p>Be sure you understand the Docker basics before diving into this tutorial. Check out the official <a href="https://www.docker.com/whatisdocker/">"What is Docker?"</a> guide for an excellent intro.</p>

<p>In short, with Docker, you can truly mimic your production environment on your local machine. No more having to debug environment specific bugs or worrying that your app will perform differently in production.</p>

<ol>
<li>Version control for infrastructure</li>
<li>Easily distribute/recreate your entire development environment</li>
<li>Build once, run anywhere – aka The Holy Grail!</li>
</ol>


<h3>Docker-specific terms</h3>

<ul>
<li>A <em>Dockerfile is a file that contains a set of instructions used to create an </em>image*.</li>
<li>An <em>image</em> is used to build and save snapshots (the state) of an environment.</li>
<li>A <em>container</em> is an instantiated, live <em>image</em> that runs a collection of processes.</li>
</ul>


<blockquote><p>Be sure to check out the Docker <a href="https://docs.docker.com/">documentation</a> for more info on <a href="https://docs.docker.com/reference/builder/">Dockerfiles</a>, <a href="https://docs.docker.com/terms/image/">images</a>, and <a href="https://docs.docker.com/terms/container/">containers</a>.</p></blockquote>

<h2>Local Setup</h2>

<p>Let's get your local development environment set up!</p>

<h3>Get Docker</h3>

<p>Follow the download instructions from the guide <a href="https://docs.docker.com/installation/mac/">Installing Docker on Mac OS X</a> to install both Docker and the official boot2docker package. <a href="http://boot2docker.io/">boot2docker</a> is a <em>lightweight</em> Linux distribution designed specifically to run Docker for Windows and Mac OS X users. In essence, it starts a small VM that’s configured to run Docker containers.</p>

<p>Once installed, run the following commands in your project directory to start boot2docker:</p>

<p><code>sh
$ boot2docker init
$ boot2docker up
$ $(boot2docker shellinit)
</code></p>

<h3>Get the Project</h3>

<p>Grab the base code from the <a href="https://github.com/mjhea0/node-docker-workflow/releases/tag/base">repo</a>, and add it to your project directory:</p>

<p>```sh
├── app
│   ├── Dockerfile
│   ├── index.js
│   ├── package.json
│   └── test
│       └── test.js
└── redis</p>

<pre><code>└── Dockerfile
</code></pre>

<p>```</p>

<h3>Compose Up!</h3>

<p><a href="https://github.com/docker/compose">Docker Compose</a> (Previously known as fig) is an orchestration framework that handles the building and running of multiple services, making it easy to link multiple services together running in different containers. Follow the installation instructions <a href="http://docs.docker.com/compose/install/#install-compose">here</a>, and then test it out to make sure all is well:</p>

<p><code>sh
$ docker-compose --version
docker-compose 1.1.0
</code></p>

<p>Now we just need to define the services - web (NodeJS) and persistence (Redis) in a configuration file called  <em>docker-compose.yml</em>:</p>

<p>```
web:
  build: ./app
  volumes:</p>

<pre><code>- "app:/src/app"
</code></pre>

<p>  ports:</p>

<pre><code>- "80:3000"
</code></pre>

<p>  links:
   - redis
redis:</p>

<pre><code>build: ./redis
ports:
    - "6379:6379"
</code></pre>

<p>```</p>

<p>Here we add the services that make up our basic stack:</p>

<ol>
<li><strong>web</strong>: First, we build the image based on the instructions in the <em>Dockerfile</em> - where we setup our Node environment, create a volume, install the required dependencies, and fire up the app running on port 3000. Then we forward that port in the container to port 80 on the host environment - e.g., the boot2docker VM.</li>
<li><strong>redis</strong>: Next, the Redis service is again built from the instructions in the <em>Dockerfile</em>. Port 6379 is exposed and forwarded.</li>
</ol>


<h3>Profit</h3>

<p>Run <code>docker-compose up</code> to build new images for the NodeJS/Express app and Redis services and then run both processes in new containers. Open your browser and navigate to the IP address associated the boot2docker VM (<code>boot2docker ip</code>). You should see the text, "You have viewed this page 1 times!" in your browser. Refresh. The page counter should increment.</p>

<p>Once done, kill the processes (Ctrl-C). Commit your changes locally, and then push to Github.</p>

<h3>Next Steps</h3>

<p>So, what did we accomplish?</p>

<p>We set up our local environment, detailing the basic process of building an <em>image</em> from a <em>Dockerfile</em> and then creating an instance of the image called a <em>container</em>. We then tied everything together with Docker Compose to build and connect different containers for both the NodeJS/Express app and Redis process.</p>

<p>Need the updated code? Grab it from the <a href="https://github.com/mjhea0/node-docker-workflow/releases/tag/compose">repo</a>.</p>

<p>Next, let’s talk about Continuous Integration...</p>

<h2>Continuous Integration</h2>

<p>We'll start with Docker Hub.</p>

<h3>Docker Hub</h3>

<p><a href="https://hub.docker.com/">Docker Hub</a> "manages the lifecycle of distributed apps with cloud services for building and sharing containers and automating workflows". It's the Github for Docker images.</p>

<ol>
<li><a href="https://hub.docker.com/account/signup/">Signup</a> using your Github credentials.</li>
<li><a href="http://docs.docker.com/docker-hub/builds/#about-automated-builds">Set up</a> a new automated build. And add your Github repo that you created and pushed to earlier. Just accept all the default options. Once added, Docker Hub will trigger an initial build.</li>
</ol>


<p>Each time you push to Github, Docker Hub will generate a new build from scratch.</p>

<p>Docker Hub acts much like a continuous integration server since it ensures you do not cause a regression that completely breaks the build process when the code base is updated. That said, Docker Hub should be the last test before deployment to either staging or production so let's use a <em>true</em> continuous integration server to fully test our code before it hits Docker Hub.</p>

<h3>CircleCI</h3>

<p><a href="https://circleci.com/">CircleCI</a> is a CI platform that supports Docker.</p>

<p>Given a Dockerfile, CircleCI builds an image, starts a new container (or containers), and then runs tests inside that container.</p>

<ol>
<li><a href="https://circleci.com/">Sign up</a> with your Github account.</li>
<li>Create a new project using the Github repo you created.</li>
</ol>


<p>Next we need to add a configuration file, called <em>circle.yml</em>, to the root folder of the project so that CircleCI can properly create the build.</p>

<p>```
machine:
  services:</p>

<pre><code>- docker
</code></pre>

<p>dependencies:
  override:</p>

<pre><code>- curl -L https://github.com/docker/compose/releases/download/1.1.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose
</code></pre>

<p>test:
  override:</p>

<pre><code>- docker-compose run -d --no-deps web
- cd app; mocha
</code></pre>

<p>```</p>

<p>Here, we install Docker Compose, then we create a new image, and run the container along with our unit tests.</p>

<blockquote><p>Notice how we’re using the command <code>docker-compose run -d --no-deps web</code>, to run the web process, instead of <code>docker-compose up</code>. This is because CircleCI already has Redis <a href="https://circleci.com/docs/environment#databases">running</a> and available to us for our tests. So, we just need to run the web process.</p></blockquote>

<p>Before we test this out, we need to change some settings on Docker Hub.</p>

<h3>Docker Hub (redux)</h3>

<p>Right now, each push to Github will create a new build. That's not what we want. Instead, we want CircleCI to run tests against the master branch then <em>after</em> they pass(and only after they pass), a new build should trigger on Docker Hub.</p>

<p>Open your repository on Docker Hub, and make the following updates:</p>

<ol>
<li>Under <em>Settings</em> click <em>Automated Build</em>.</li>
<li>Uncheck the Active box: “When active we will build when new pushes occur”. Save the changes.</li>
<li>Then once again under <em>Settings</em> click <em>Build Triggers</em>.</li>
<li>Change the status to on.</li>
<li>Copy the example curl command – i.e., <code>$ curl --data "build=true" -X POST https://registry.hub.docker.com/u/mjhea0/node-docker-workflow/trigger/84957124-2b85-410d-b602-b48193853b66/</code>.</li>
</ol>


<h3>CircleCI (redux)</h3>

<p>Back on CircleCI, let's add that curl command as an environment variable:</p>

<ol>
<li>Within the <em>Project Settings</em>, select <em>Environment variables</em>.</li>
<li>Add a new variable with the name "DEPLOY" and paste the curl command as the value.</li>
</ol>


<p>Then add the following code to the bottom of the <em>circle.yml</em> file:</p>

<p>```yaml
deployment:
  hub:</p>

<pre><code>branch: master
commands:
  - $DEPLOY
</code></pre>

<p>```</p>

<p>This simple fires the <code>$DEPLOY</code> variable after our tests pass on the master branch.</p>

<p>Now, let's test!</p>

<h3>Profit!</h3>

<p>Follow these steps...</p>

<ol>
<li>Create a new branch</li>
<li>Make changes locally</li>
<li>Issue a pull request</li>
<li>Manually merge once the tests pass</li>
<li>Once the second round passes, a new build is triggered on Docker Hub</li>
</ol>


<p>What's left? Deployment! Grab the updated <a href="https://github.com/mjhea0/node-docker-workflow/releases/tag/circle">code</a>, if necessary.</p>

<h2>Deployment</h2>

<p>Let's get our app running on <a href="https://www.digitalocean.com/">Digital Ocean</a>.</p>

<p>After you've signed up, create a new Droplet, choose “Applications” and then select the Docker Application.</p>

<p>Once setup, SSH into the server as the ‘root’ user:</p>

<p><code>sh
$ ssh root@&lt;some_ip_address&gt;
</code></p>

<p>Now you just need to clone the repo, install Docker compose, and then you can run your app:</p>

<p><code>sh
$ git clone https://github.com/mjhea0/node-docker-workflow.git
$ curl -L https://github.com/docker/compose/releases/download/1.1.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
$ chmod +x /usr/local/bin/docker-compose
$ docker-compose up -d
</code></p>

<p>Sanity check. Navigate to your Droplet’s IP address in the browser. You should see your app.</p>

<p>Nice!</p>

<p>But what about continuous delivery? Instead of having to SSH into the server and clone the new code, the process should be part of our workflow so that once a new build is generated on Docker Hub, the code is updated on Digital Ocean automatically.</p>

<p>Enter <a href="https://www.tutum.co/">Tutum</a>.</p>

<h2>Continuous Delivery</h2>

<p><a href="https://www.tutum.co/">Tutum</a> manages the orchestration and deployment of Docker images and containers. Setup is simple. After you've signed up (with Github), you need to add a <a href="https://support.tutum.co/support/solutions/articles/5000523221-your-first-node">Node</a>, which is just a Linux host. We'll use Digital Ocean.</p>

<p>Start by linking your Digital Ocean account within the "Account Info" area.</p>

<p>Now you can add a new Node. The process is straightforward, but if you need help, please refer to the <a href="https://support.tutum.co/support/solutions/articles/5000523221-your-first-node">official documentation</a>. Just add a name, select a region, and then you're good to go.</p>

<p>With a Node setup, we can now add a <a href="https://support.tutum.co/support/solutions/articles/5000569899-stacks">Stack</a> of services - <em>web</em> and <em>Redis</em>, in our case - that make up our tech stack. Next, create a new file called <em>tutum.yml</em>, and add the following code:</p>

<p>```yaml
web:
  image: mjhea0/node-docker-workflow
  autorestart: always
  ports:</p>

<pre><code>- "80:3000"
</code></pre>

<p>  links:
   - "redis:redis"
redis:</p>

<pre><code>image: redis
autorestart: always
ports:
    - "6379:6379"
</code></pre>

<p>```</p>

<p>Here, we are pulling the images from Docker Hub and building them just like we did with Docker Compose. Notice the difference here, between this file and the <em>docker-compose.yml</em> file. Here, we are not creating images, we're pulling them in from Docker Hub. It's essentially the same thing since the most updated build is on Docker Hub.</p>

<p>Now just create a new Stack, adding a name and uploading the <em>tutum.yml</em> file, and click "Create and deploy" to pull in the new images on the Node and then build and run the containers.</p>

<p>Once done, you can view your live app!</p>

<blockquote><p>Note: You lose the "magic" of Tutum when running things in a single host, as we're currently doing. In a real world scenario you'd want to deploy multiple web containers, load balance across them and have them live on different hosts, sharing a single REDIS cache. We may look at this in a future post, focusing solely on delivery.</p></blockquote>

<p>Before we call it quits, we need to sync Docker Hub with Tutum so that when a new build is created on Docker Hub, the services are rebuilt and redeployed on Tutum - automatically!</p>

<p>Tutum makes this simple.</p>

<p>Under the <em>Services</em> tab, click the <em>web</em> service, and, finally, click the <em>Webhooks tab</em>. To create a new hook, simply add a name and then click <em>Add</em>. Copy the URL, and then navigate back to Docker Hub. Once there, click the <em>Webhook</em> link and add a new hook, pasting in the URL.</p>

<p>Now after a build is created on Docker Hub, a POST request is sent to that URL, which, in turn, triggers a redeploy on Tutum. Boom!</p>

<h2>Conclusion</h2>

<p>As always comment below if you have questions. If you manage a different workflow for continuous integration and delivery, please post the details below. Grab the final code from the <a href="https://github.com/mjhea0/node-docker-workflow">repo</a>.</p>

<p>See you next time!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSQL and NodeJS]]></title>
    <link href="http://mjhea0.github.com/blog/2015/02/12/postgresql-and-nodejs/"/>
    <updated>2015-02-12T19:07:00-07:00</updated>
    <id>http://mjhea0.github.com/blog/2015/02/12/postgresql-and-nodejs</id>
    <content type="html"><![CDATA[<p><strong>Today we're going to build a CRUD todo single page application with Node, Express, Angular, and PostgreSQL.</strong></p>

<p><img src="https://raw.githubusercontent.com/mjhea0/node-postgres-todo/master/_blog/node-todo-postges.jpg" alt="node todo app" /></p>

<blockquote><p>Technologies/Tools used - <a href="http://nodejs.org/">Node</a> v0.10.36, <a href="https://www.npmjs.com/package/express">Express</a> v4.11.1, <a href="https://angularjs.org/">Angular</a> v1.3.12.</p></blockquote>

<h2>Project Setup</h2>

<p>Start by installing the <a href="http://expressjs.com/starter/generator.html">Express generator</a> if you don't already have it:</p>

<p><code>sh
$ npm install -g express-generator@4
</code></p>

<p>Then create a new project and install the dependencies:</p>

<p><code>sh
$ express node-postgres-todo
$ cd node-postgres-todo &amp;&amp; npm install
</code></p>

<p>Add <a href="https://github.com/isaacs/node-supervisor">Supervisor</a> to watch for code changes:</p>

<p><code>sh
$ npm install supervisor -g
</code></p>

<p>Update the ‘start’ script in the <em>package.json</em> file:</p>

<p><code>json
"scripts": {
  "start": "supervisor ./bin/www"
},
</code></p>

<p>Run the app:</p>

<p><code>sh
$ npm start
</code></p>

<p>Then navigate to <a href="http://localhost:3000/">http://localhost:3000/</a> in your browser. You should see the "Welcome to Express" text.</p>

<h2>Postgres Setup</h2>

<blockquote><p>Need to setup Postgres? On a Mac? Check out <a href="http://postgresapp.com/">Postgres.app</a>.</p></blockquote>

<p>With your Postgres server up and listening on port 5432, making a database connection is easy with the <a href="https://www.npmjs.com/package/pg">pg</a> library:</p>

<p><code>sh
$ npm install pg --save
</code></p>

<p>Now let’s set up a simple table creation script:</p>

<p>```javascript
var pg = require('pg');
var connectionString = process.env.DATABASE_URL || 'postgres://localhost:5432/todo';</p>

<p>var client = new pg.Client(connectionString);
client.connect();
var query = client.query('CREATE TABLE items(id SERIAL PRIMARY KEY, text VARCHAR(40) not null, complete BOOLEAN)');
query.on('end', function() { client.end(); });
```</p>

<p>Save this as <em>database.js</em> in a new folder called "models".</p>

<p>Here we create a new instance of <code>Client</code> to interact with the database and then establish communication with it via the <code>connect()</code> method. We then set run a SQL query via the <code>query()</code> method. Communication is closed via the <code>end()</code> method. Be sure to check out the <a href="https://github.com/brianc/node-postgres/wiki/Client">documentation</a> for more info.</p>

<p>Make sure you have a database called "todo" setup, and then run the script to setup the table and subsequent fields:</p>

<p><code>sh
$ node models/database.js
</code></p>

<p>Verify the table/schema creation in <a href="http://postgresguide.com/utilities/psql.html">psql</a>:</p>

<p>```sh
michaelherman=# \c todo
You are now connected to database "todo" as user "michaelherman".
todo=# \d+ items</p>

<pre><code>                                                 Table "public.items"
</code></pre>

<p>  Column  |         Type          |                     Modifiers                      | Storage  | Stats target | Description
----------+-----------------------+----------------------------------------------------+----------+--------------+-------------
 id       | integer               | not null default nextval('items_id_seq'::regclass) | plain    |              |
 text     | character varying(40) | not null                                           | extended |              |
 complete | boolean               |                                                    | plain    |              |
Indexes:</p>

<pre><code>"items_pkey" PRIMARY KEY, btree (id)
</code></pre>

<p>```</p>

<p>With the database connection setup along with the "items" table, we can now configure the CRUD portion of our app.</p>

<h2>Server-Side: Routes</h2>

<p>Let’s keep it simple by adding all endpoints to the <em>index.js</em> file within the "routes" folder. Make sure to update the imports:</p>

<p><code>javascript
var express = require('express');
var router = express.Router();
var pg = require('pg');
var connectionString = process.env.DATABASE_URL || 'postgres://localhost:5432/todo';
</code></p>

<p>Now, let’s add each endpoint.</p>

<table style="font-size:16px;border-spacing:10px 0px;border-collapse:separate;border:1px solid black;">
<thead>
<tr>
<th style="text-align:center"><strong>Function</strong></th>
<th style="text-align:center"><strong>URL</strong></th>
<th style="text-align:center"><strong>Action</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CREATE</td>
<td>/api/v1/todos</td>
<td>Create a single todo</td>
</tr>
<tr>
<td>READ</td>
<td>/api/v1/todos</td>
<td>Get all todos</td>
</tr>
<tr>
<td>UPDATE</td>
<td>/api/v1/todos/:todo_id</td>
<td>Update a single todo</td>
</tr>
<tr>
<td>DELETE</td>
<td>/api/v1/todos/:todo_id</td>
<td>Delete a single todo</td>
</tr>
</tbody>
</table>




<br>


<p>Follow along with the inline comments below for an explanation of what’s happening. Also, be sure to check out the <a href="https://github.com/brianc/node-postgres/wiki/Connection">pg documentation</a> to learn about connection pooling. How does that differ from <code>pg.Client</code>?</p>

<h3>Create</h3>

<p>```javascript
router.post('/api/v1/todos', function(req, res) {</p>

<pre><code>var results = [];

// Grab data from http request
var data = {text: req.body.text, complete: false};

// Get a Postgres client from the connection pool
pg.connect(connectionString, function(err, client, done) {

    // SQL Query &gt; Insert Data
    client.query("INSERT INTO items(text, complete) values($1, $2)", [data.text, data.complete]);

    // SQL Query &gt; Select Data
    var query = client.query("SELECT * FROM items ORDER BY id ASC");

    // Stream results back one row at a time
    query.on('row', function(row) {
        results.push(row);
    });

    // After all data is returned, close connection and return results
    query.on('end', function() {
        client.end();
        return res.json(results);
    });

    // Handle Errors
    if(err) {
      console.log(err);
    }

});
</code></pre>

<p>});
```</p>

<p>Test this out via Curl in your terminal:</p>

<p><code>sh
$ curl --data "text=test&amp;complete=false" http://127.0.0.1:3000/api/v1/todos
</code></p>

<p>Then confirm that the data was INSERT’ed correctly into the database via psql:</p>

<p><code>sh
todo=# SELECT * FROM items ORDER BY id ASC;
 id | text  | complete
----+-------+----------
  1 | test  | f
(1 row)
</code></p>

<h3>Read</h3>

<p>```javascript
router.get('/api/v1/todos', function(req, res) {</p>

<pre><code>var results = [];

// Get a Postgres client from the connection pool
pg.connect(connectionString, function(err, client, done) {

    // SQL Query &gt; Select Data
    var query = client.query("SELECT * FROM items ORDER BY id ASC;");

    // Stream results back one row at a time
    query.on('row', function(row) {
        results.push(row);
    });

    // After all data is returned, close connection and return results
    query.on('end', function() {
        client.end();
        return res.json(results);
    });

    // Handle Errors
    if(err) {
      console.log(err);
    }

});
</code></pre>

<p>});
```</p>

<p>Add a few more rows of data via Curl, and then test the endpoint out in your browser at <a href="http://localhost:3000/api/v1/todos">http://localhost:3000/api/v1/todos</a>. You should see an array of JSON objects:</p>

<p>```json
[</p>

<pre><code>{
    id: 1,
    text: "test",
    complete: false
},
{
    id: 2,
    text: "test2",
    complete: false
},
{
    id: 3,
    text: "test3",
    complete: false
}
</code></pre>

<p>]
```</p>

<h3>Update</h3>

<p>```javascript
router.put('/api/v1/todos/:todo_id', function(req, res) {</p>

<pre><code>var results = [];

// Grab data from the URL parameters
var id = req.params.todo_id;

// Grab data from http request
var data = {text: req.body.text, complete: req.body.complete};

// Get a Postgres client from the connection pool
pg.connect(connectionString, function(err, client, done) {

    // SQL Query &gt; Update Data
    client.query("UPDATE items SET text=($1), complete=($2) WHERE id=($3)", [data.text, data.complete, id]);

    // SQL Query &gt; Select Data
    var query = client.query("SELECT * FROM items ORDER BY id ASC");

    // Stream results back one row at a time
    query.on('row', function(row) {
        results.push(row);
    });

    // After all data is returned, close connection and return results
    query.on('end', function() {
        client.end();
        return res.json(results);
    });

    // Handle Errors
    if(err) {
      console.log(err);
    }

});
</code></pre>

<p>});
```</p>

<p>Again, test via Curl:</p>

<p><code>sh
$ curl -X PUT --data "text=test&amp;complete=true" http://127.0.0.1:3000/api/v1/todos/1
</code></p>

<p>Navigate to <a href="http://localhost:3000/api/v1/todos">http://localhost:3000/api/v1/todos</a> to make sure the data has been updated correctly.</p>

<p>```json
[</p>

<pre><code>{
    id: 1,
    text: "test",
    complete: true
},
{
    id: 2,
    text: "test2",
    complete: false
},
{
    id: 3,
    text: "test3",
    complete: false
}
</code></pre>

<p>]
```</p>

<h3>Delete</h3>

<p>```javascript
router.delete('/api/v1/todos/:todo_id', function(req, res) {</p>

<pre><code>var results = [];

// Grab data from the URL parameters
var id = req.params.todo_id;


// Get a Postgres client from the connection pool
pg.connect(connectionString, function(err, client, done) {

    // SQL Query &gt; Delete Data
    client.query("DELETE FROM items WHERE id=($1)", [id]);

    // SQL Query &gt; Select Data
    var query = client.query("SELECT * FROM items ORDER BY id ASC");

    // Stream results back one row at a time
    query.on('row', function(row) {
        results.push(row);
    });

    // After all data is returned, close connection and return results
    query.on('end', function() {
        client.end();
        return res.json(results);
    });

    // Handle Errors
    if(err) {
      console.log(err);
    }

});
</code></pre>

<p>});
```</p>

<p>Final Curl test:</p>

<p><code>sh
$ curl -X DELETE http://127.0.0.1:3000/api/v1/todos/3
</code></p>

<p>And you should now have:</p>

<p>```json</p>

<p>[</p>

<pre><code>{
    id: 1,
    text: "test",
    complete: true
},
{
    id: 2,
    text: "test2",
    complete: false
}
</code></pre>

<p>]
```</p>

<h2>Refactoring</h2>

<p>Before we jump to the client-side to add Angular, be aware that our code should be refactored to address a few issues. We’ll handle this later on in this tutorial, but this is an excellent opportunity to refactor the code on your own. Good luck!</p>

<h2>Client-Side: Angular</h2>

<p>Let’s dive right in to Angular.</p>

<blockquote><p>Keep in mind that this is not meant to be an exhaustive tutorial. If you’re new to Angular I suggest following my "AngularJS by Example" tutorial - <a href="https://github.com/mjhea0/thinkful-angular">Building a Bitcoin Investment Calculator</a>.</p></blockquote>

<h3>Module</h3>

<p>Create a file called <em>app.js</em> in the "public/javascripts" folder. This file will house our Angular module and controller:</p>

<p>```javascript
angular.module('nodeTodo', [])</p>

<p>.controller('mainController', function($scope, $http) {</p>

<pre><code>$scope.formData = {};
$scope.todoData = {};

// Get all todos
$http.get('/api/v1/todos')
    .success(function(data) {
        $scope.todoData = data;
        console.log(data);
    })
    .error(function(error) {
        console.log('Error: ' + error);
    });
</code></pre>

<p>});
```</p>

<p>Here we define our module as well as the controller. Within the controller we are using the <a href="https://docs.angularjs.org/api/ng/service/$http"><code>$http</code></a> service to make an AJAX request to the <code>'/api/v1/todos'</code> endpoint and then updating the scope accordingly.</p>

<p>What else is going on?</p>

<p>Well, we’re <a href="https://docs.angularjs.org/guide/di">injecting</a> the <code>$scope</code> and <code>$http</code> services. Also, we’re defining and updating <code>$scope</code> to handle <a href="https://docs.angularjs.org/guide/databinding">binding</a>.</p>

<h3>Update <code>/</code> Route</h3>

<p>Let’s update the main route in <em>index.js</em> within the "routes" folder:</p>

<p><code>javascript
router.get('/', function(req, res, next) {
  res.sendFile(path.join(__dirname, '../views', 'index.html'));
});
</code></p>

<p>So when the end user hits the main endpoint, we send the <em>index.html</em> file. This file will contain our HTML and Angular templates.</p>

<p>Make sure to add the following dependency as well:</p>

<p><code>javascript
var path = require('path');
</code></p>

<h3>View</h3>

<p>Now, let’s add our basic Angular view within <em>index.html</em>:</p>

<p>```html
&lt;!DOCTYPE html>
<html ng-app="nodeTodo">
  <head></p>

<pre><code>&lt;title&gt;Todo App - with Node + Express + Angular + PostgreSQL&lt;/title&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;link href="http://netdna.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css" rel="stylesheet" media="screen"&gt;
</code></pre>

<p>  </head>
  <body ng-controller="mainController"></p>

<pre><code>&lt;div class="container"&gt;
  &lt;ul ng-repeat="todo in todoData"&gt;
    &lt;li&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.2.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="http://netdna.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.3.12/angular.min.js"&gt;&lt;/script&gt;
&lt;script src="javascripts/app.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>This should all be straightforward. We bootstrap Angular - <code>ng-app="nodeTodo"</code>, define the scope of the controller - <code>ng-controller="mainController"</code> - and then use <code>ng-repeat</code> to loop through the <code>todoData</code> object, adding each individual todo to the page.</p>

<h3>Module (round two)</h3>

<p>Next, let’s update the module to handle the Create and Delete functions:</p>

<p>```javascript
// Create a new todo
$http.post('/api/v1/todos', $scope.formData)</p>

<pre><code>.success(function(data) {
    $scope.formData = {};
    $scope.todoData = data;
    console.log(data);
})
.error(function(error) {
    console.log('Error: ' + error);
});
</code></pre>

<p>// Delete a todo
$http.delete('/api/v1/todos/' + todoID)</p>

<pre><code>.success(function(data) {
    $scope.todoData = data;
    console.log(data);
})
.error(function(data) {
    console.log('Error: ' + data);
});
</code></pre>

<p>```</p>

<p>Now, let’s update our view…</p>

<h3>View (round two)</h3>

<p>Simply update each list item like so:</p>

<p><code>html
&lt;li&gt;&lt;input type="checkbox" ng-click="deleteTodo(todo.id)"&gt;&amp;nbsp;&lt;/li&gt;
</code></p>

<p>This uses the <a href="https://docs.angularjs.org/api/ng/directive/ngClick"><code>ng-click</code></a> directive to call the <code>deleteTodo()</code> function - which we still need to define - that takes a unique <code>id</code> associated with each todo as an argument.</p>

<h3>Module (round three)</h3>

<p>Update the controller:</p>

<p>```javascript
// Delete a todo
$scope.deleteTodo = function(todoID) {</p>

<pre><code>$http.delete('/api/v1/todos/' + todoID)
    .success(function(data) {
        $scope.todoData = data;
        console.log(data);
    })
    .error(function(data) {
        console.log('Error: ' + data);
    });
</code></pre>

<p>};
```</p>

<p>We simply wrapped the delete functionality in the <code>deleteTodo()</code> function. Test this out. Make sure that when you click a check box the todo is removed.</p>

<h3>View (round three)</h3>

<p>To handle the creation of a new todo, we need to add an HTML form:</p>

<p>```html</p>

<div class="container">

  <form>
    <div class="form-group">
      <input type="text" class="form-control input-lg" placeholder="Add a todo..." ng-model="formData.text">
    </div>
    <button type="submit" class="btn btn-primary btn-lg" ng-click="createTodo()">Add Todo</button>
  </form>

  <ul ng-repeat="todo in todoData">
    <li><input type="checkbox" ng-click="deleteTodo(todo.id)">&nbsp;</li>
  </ul>

</div>


<p>```</p>

<p>Again, we use <code>ng-click</code> to call a function in the controller.</p>

<h3>Module (round four)</h3>

<p>```javascript
// Create a new todo
$scope.createTodo = function(todoID) {</p>

<pre><code>$http.post('/api/v1/todos', $scope.formData)
    .success(function(data) {
        $scope.formData = {};
        $scope.todoData = data;
        console.log(data);
    })
    .error(function(error) {
        console.log('Error: ' + error);
    });
</code></pre>

<p>};
```</p>

<p>Test this out!</p>

<h2>View (round four)</h2>

<p>With the main functionality done, let’s update the front-end to make it look, well, presentable.</p>

<p><strong>HTML</strong>:</p>

<p>```html
&lt;!DOCTYPE html>
<html ng-app="nodeTodo">
  <head></p>

<pre><code>&lt;title&gt;Todo App - with Node + Express + Angular + PostgreSQL&lt;/title&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;!-- styles --&gt;
&lt;link href="http://netdna.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css" rel="stylesheet" media="screen"&gt;
&lt;link href="stylesheets/style.css" rel="stylesheet" media="screen"&gt;
</code></pre>

<p>  </head>
  <body ng-controller="mainController"></p>

<pre><code>&lt;div class="container"&gt;

  &lt;div class="header"&gt;
    &lt;h1&gt;Todo App&lt;/h1&gt;
    &lt;hr&gt;
    &lt;h1 class="lead"&gt;Node + Express + Angular + PostgreSQL&lt;/h1&gt;
  &lt;/div&gt;

  &lt;div class="todo-form"&gt;
    &lt;form&gt;
      &lt;div class="form-group"&gt;
        &lt;input type="text" class="form-control input-lg" placeholder="Enter text..." ng-model="formData.text"&gt;
      &lt;/div&gt;
      &lt;button type="submit" class="btn btn-primary btn-lg btn-block" ng-click="createTodo()"&gt;Add Todo&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;

  &lt;br&gt;

  &lt;div class="todo-list"&gt;
    &lt;ul ng-repeat="todo in todoData"&gt;
      &lt;li&gt;&lt;h3&gt;&lt;input class="lead" type="checkbox" ng-click="deleteTodo(todo.id)"&gt;&amp;nbsp;&lt;/li&gt;&lt;/h3&gt;&lt;hr&gt;
    &lt;/ul&gt;
  &lt;/div&gt;

&lt;/div&gt;

&lt;!-- scripts --&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.2.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="http://netdna.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.3.12/angular.min.js"&gt;&lt;/script&gt;
&lt;script src="javascripts/app.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p><strong>CSS</strong>:</p>

<p>```css
body {
  padding: 50px;
  font: 14px "Lucida Grande", Helvetica, Arial, sans-serif;
}</p>

<p>a {
  color: #00B7FF;
}</p>

<p>ul {
  list-style-type: none;
  padding-left: 10px;
}</p>

<p>.container {
  max-width: 400px;
  background-color: #eeeeee;
  border: 1px solid black;
}</p>

<p>.header {
  text-align: center;
}
```</p>

<p>How’s that? Not up to par? Continue working on it on your end.</p>

<h2>Refactoring (for real)</h2>

<p>Now that we added the front-end functionality, let’s update our application’s structure and refactor parts of the code.</p>

<h3>Structure</h3>

<p>Since our application is logically split between the client and server, let’s do the same for our project structure. So, make the following changes to your folder structure:</p>

<p>```sh
├── app.js
├── bin
│   └── www
├── client
│   ├── public
│   │   ├── javascripts
│   │   │   └── app.js
│   │   └── stylesheets
│   │       └── style.css
│   └── views
│       └── index.html
├── config.js
├── package.json
└── server</p>

<pre><code>├── models
│   └── database.js
└── routes
    └── index.js
</code></pre>

<p>```</p>

<p>Now, we need to make a few updates to the code:</p>

<p><em>server/routes/index.js</em>:</p>

<p><code>javascript
res.sendFile(path.join(__dirname, '../', '../', 'client', 'views', 'index.html'));
</code></p>

<p><em>app.js</em>:</p>

<p><code>javascript
var routes = require('./server/routes/index');
</code></p>

<p><em>app.js</em>:</p>

<p><code>javascript
app.use(express.static(path.join(__dirname, './client', 'public')));
</code></p>

<h3>Configuration</h3>

<p>Next, let’s move the <code>connectionString</code> variable - which specifies the database URI (<code>process.env.DATABASE_URL || 'postgres://localhost:5432/todo';</code>) - to a configuration file since we are reusing the same same connection throughout our application.</p>

<p>Create a file called <em>config.js</em> in the root directory, and then add the following code to it:</p>

<p>```javascript
var connectionString = process.env.DATABASE_URL || 'postgres://localhost:5432/todo';</p>

<p>module.exports = connectionString;
```</p>

<p>Then update the <code>connectionString</code> variable in both <em>server/models/database.js</em> and <em>server/routes/index.js</em>:</p>

<p><code>javascript
var connectionString = require(path.join(__dirname, '../', '../', 'config'));
</code></p>

<p>And make sure to add <code>var path = require('path');</code> to the former file as well.</p>

<h3>Utility Function</h3>

<p>Did you notice in our routes that we are reusing the same code in each of the CRUD functions:</p>

<p>```javascript
// SQL Query > Select Data
var query = client.query("SELECT * FROM items ORDER BY id ASC");</p>

<p>// Stream results back one row at a time
query.on('row', function(row) {</p>

<pre><code>results.push(row);
</code></pre>

<p>});</p>

<p>// After all data is returned, close connection and return results
query.on('end', function() {</p>

<pre><code>client.end();
return res.json(results);
</code></pre>

<p>});</p>

<p>// Handle Errors
if(err) {
  console.log(err);
}
```</p>

<p>We should abstract that out into a utility function so we're not duplicating code. Do this on your own, and then post a link to your code in the comments for review.</p>

<h2>Conclusion and next steps</h2>

<p>That's it! Now, since there's a number of moving pieces here, please review how each piece fits into the overall process and whether each is part of the client or server-side. Comment below with questions. Grab the code from the <a href="https://github.com/mjhea0/node-postgres-todo">repo</a>.</p>

<br><hr><br>


<p><strong>Finally, this app is far from finished. What else do we need to do?</strong></p>

<ol>
<li>Handle Permissions via <a href="http://passportjs.org/">passport.js</a></li>
<li>Add a task runner - like <a href="http://gulpjs.com/">Gulp</a></li>
<li>Test with <a href="http://mochajs.org/">Mocha</a> and <a href="http://chaijs.com/">Chai</a></li>
<li>Check test coverage with <a href="https://github.com/gotwarlost/istanbul">Istanbul</a></li>
<li>Add <a href="https://docs.angularjs.org/api/ng/service/$q">promises</a></li>
<li>Use <a href="http://bower.io/">Bower</a> for managing client-side dependencies</li>
<li>Utilize Angular <a href="https://docs.angularjs.org/api/ngRoute/provider/$routeProvider">Routing</a>, <a href="https://docs.angularjs.org/guide/forms">form validation</a>, <a href="https://docs.angularjs.org/guide/services">Services</a>, and <a href="https://docs.angularjs.org/guide/templates">Templates</a></li>
<li>Handle updates/PUT requests</li>
<li>Update the Express <a href="http://expressjs.com/guide/using-template-engines.html">View Engine</a> to HTML</li>
<li>Better manage the database layer by adding an ORM - like <a href="http://sequelizejs.com/">Sequelize</a> - and a means of managing <a href="https://sequelize.readthedocs.org/en/latest/docs/migrations/">migrations</a></li>
</ol>


<p>What else? Comment below.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text for Web Developers]]></title>
    <link href="http://mjhea0.github.com/blog/2015/02/05/sublime-text-for-web-developers/"/>
    <updated>2015-02-05T19:07:00-07:00</updated>
    <id>http://mjhea0.github.com/blog/2015/02/05/sublime-text-for-web-developers</id>
    <content type="html"><![CDATA[<p><a href="http://www.sublimetext.com/3">Sublime Text 3</a> (ST3) is a powerful editor just as it is. But if you want to step up your game, you need to take advantage of all that ST3 has to offer by learning the keyboard shortcuts and customizing the editor to meet your individual needs...</p>

<blockquote><p><strong>NOTE</strong>: This tutorial is meant for Mac OS X users, utilizing HTML, CSS, and JavaScript/jQuery.</p></blockquote>

<p>Be sure to <a href="https://realpython.com/blog/python/setting-up-sublime-text-3-for-full-stack-python-development/#customizing-sublime-text-3">set up</a> the <code>subl</code> command line tool, which can be used to open a single file or an entire project directory of files and folders, before moving on.</p>

<h2>Keyboard Shortcuts</h2>

<p>Goal: Never take your hands off the keyboard!</p>

<ol>
<li><p><strong>Command Palette</strong> (<em>CMD-SHIFT-P</em>) - Accesses the all-powerful <em><a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/command_palette.html">Command Palette</a></em>, where you can run toolbar actions - setting the code syntax, accessing package control, renaming a file, etc..</p>

<p> <img src="https://raw.githubusercontent.com/mjhea0/sublime-javascript/master/img/command_palette.png" alt="Command Palette" /></p></li>
<li><p><strong>Goto Anything</strong> (<em>CMD-P</em>) - Searches for a file within the current project or a line or definition in the current file. It's fuzzy so you don't need to match the name exactly.</p>

<ul>
<li><code>@</code> - Definition - class, method, function</li>
<li><code>:</code> - Line #</li>
</ul>
</li>
<li><p><strong>Distraction Free Mode</strong> (<em>CMD-CTRL-SHIFT-F</em>) - Eliminates distractions!</p>

<p> <img src="https://raw.githubusercontent.com/mjhea0/sublime-javascript/master/img/distraction_free.png" alt="Command Palette" /></p></li>
<li><p><strong>Hide/Show the Sidebar</strong> (<em>CMD-K</em>, <em>CMD-B</em>) - Toggles the sidebar.</p></li>
<li><strong>Comment Your Code</strong> (<em>CMD-/</em>) - Highlight the code you want to comment out, then comment it out. If you do not highlight anything, this command will comment out the current line.</li>
<li><strong>Highlight an entire line</strong> (<em>CMD-L</em>)</li>
<li><strong>Delete an entire line</strong> (<em>CMD-SHIFT-K</em>)</li>
<li><strong>Multi-Edit</strong> (<em>CMD+D</em>) - Simply select the word you want to edit, and press <em>CMD-D</em> repeatedly until you have selected all the words you want to change/update/etc..</li>
</ol>


<p>Grab the cheat sheet in <a href="https://github.com/mjhea0/sublime-javascript/raw/master/sublime_text_keyboard_shortcuts.pdf">PDF</a>.</p>

<h2>Configuration</h2>

<p>You can customize <em>almost</em> anything in ST3 by updating the config settings.</p>

<p>Config settings can be set at the global/default-level or by user, project, package, and/or syntax. Setting files are <a href="http://www.sublimetext.com/docs/3/settings.html">loaded</a> in the following order:</p>

<ul>
<li><code>Packages/Default/Preferences.sublime-settings</code></li>
<li><code>Packages/User/Preferences.sublime-settings</code></li>
<li><code>Packages/&lt;syntax&gt;/&lt;syntax&gt;.sublime-settings</code></li>
<li><code>Packages/User/&lt;syntax&gt;.sublime-settings</code></li>
</ul>


<p><strong>Always apply your custom configuration settings to at the <em>User</em> level, since they will not get overridden when you update Sublime and/or a specific package.</strong></p>

<ol>
<li><strong>Base User Settings</strong>: <em>Sublime Text 3 > Preferences > Settings â€“ User</em></li>
<li><strong>Package User Specific</strong>: <em>Sublime Text 3 > Preferences > Package Settings > PACKAGE NAME > Settings â€“ User</em></li>
<li><strong>Syntax User Settings</strong>: <em>Sublime Text 3 > Preferences > Settings â€“ More > Syntax Specific - User</em></li>
</ol>


<h3>Base User Settings</h3>

<p>Don't know where to start?</p>

<p><code>json
{
  "draw_white_space": "all",
  "rulers": [80],
  "tab_size": 2,
  "translate_tabs_to_spaces": true,
  "trim_trailing_white_space_on_save": true,
  "word_wrap": true
}
</code></p>

<p>Add this to <em>Sublime Text 3 > Preferences > Settings â€“ User</em>.</p>

<p><strong>What's happening?</strong></p>

<ol>
<li>We convert tabs to two spaces. Now when you press tab, it actually indents two spaces. This is perfect for HTML, CSS, and JavaScript. This creates cleaner, easier to read code.</li>
<li>The ruler is a simple reminder to keep your code concise (for readability).</li>
<li>We added white space markers and trimmed any trailing (err, unnecessary) white space on save.</li>
<li>Finally, word wrapping is automatically applied</li>
</ol>


<p>What else can you update? Start with the <strong>theme</strong>.</p>

<p>For example -</p>

<p><code>javascript
"color_scheme": "Packages/User/Flatland Dark (SL).tmTheme",
</code></p>

<p>Simply add this to that same file.</p>

<p>You can find and test themes online before applying them <a href="http://colorsublime.com/">here</a>.</p>

<blockquote><p>Advanced users should look into customizing <a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/key_bindings.html">key bindings</a>, <a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/extensibility/macros.html">macros</a>, and <a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/extensibility/snippets.html">code snippets</a>.</p></blockquote>

<h2>Packages</h2>

<p>Want more features? There's a ton of extensions used to, well, extend ST3's functionality written by the community. <em>"There's a package for that".</em></p>

<h3>Package Control</h3>

<p><a href="https://packagecontrol.io/">Package Control</a> <em>must</em> be installed manually, then, once installed, you can use it to install other ST3 packages. To install, copy the Python code for found <a href="https://packagecontrol.io/installation">here</a>. Then open your console (<em>CTRL-`</em>), paste the code, press ENTER. Then Reboot ST3.</p>

<p><img src="https://raw.githubusercontent.com/mjhea0/sublime-javascript/master/img/package_control.png" alt="Command Palette" /></p>

<p>Now you can easily install packages by entering the <em>Command Palette</em> (remember the keyboard shortcut?).</p>

<ol>
<li>Type "install". Press ENTER when <em>Package Control: Install Package</em> is highlighted</li>
<li>Search for a package. Boom!</li>
</ol>


<p>Let's look at some packages...</p>

<h3>Sublime Linter</h3>

<p><a href="http://www.sublimelinter.com/en/latest/">SublimeLinter</a> is a framework for Sublime Text linters.</p>

<p>After you install the base package, you need to install linters separately via Package Control, which are easily searchable as they adhere to the following naming syntax - <em>SublimeLinter-[linter_name]</em>. You can view all the official linters <a href="https://github.com/SublimeLinter">here</a>.</p>

<p>Start with the following linters:</p>

<ol>
<li><a href="https://packagecontrol.io/packages/SublimeLinter-jshint">SublimeLinter-jshint</a></li>
<li><a href="https://packagecontrol.io/packages/SublimeLinter-csslint">SublimeLinter-csslint</a></li>
<li><a href="https://packagecontrol.io/packages/SublimeLinter-html-tidy">SublimeLinter-html-tidy</a></li>
<li><a href="https://packagecontrol.io/packages/SublimeLinter-json">SublimeLinter-json</a></li>
</ol>


<h3>Sidebar Enhancements</h3>

<p><a href="https://sublime.wbond.net/packages/SideBarEnhancements">Sidebar Enhancements</a> extends the number of menu options in the sidebar, adding file explorer actions - i.e., Copy, Cut, Paste, Delete, Rename. This package also adds the same commands/actions to the Command Palette.</p>

<p><img src="https://raw.githubusercontent.com/mjhea0/sublime-javascript/master/img/sidebar_enhancements.png" alt="Command Palette" /></p>

<h3>JsFormat</h3>

<p><a href="https://packagecontrol.io/packages/JsFormat">JsFormat</a> beautifies your JavaScript/jQuery Code!</p>

<p>Press <em>CTRL-ALT-F</em> to turn this mess...</p>

<p>```javascript
function peopleFromBoulder(arr) {return arr.filter(function(val) {return val.city == 'Boulder';})</p>

<pre><code>.map(function(val) {return val.name + ' is from Boulder';});}
</code></pre>

<p>```</p>

<p>...into...</p>

<p>```javascript
function peopleFromBoulder(arr) {</p>

<pre><code>return arr.filter(function(val) {
        return val.city == 'Boulder';
    })
    .map(function(val) {
        return val.name + ' is from Boulder';
    });
</code></pre>

<p>}
```</p>

<h3>DocBlockr</h3>

<p><a href="https://packagecontrol.io/packages/DocBlockr">DocBlockr</a> creates comment blocks based on the context.</p>

<p>Try it!</p>

<p>```javascript
function refactorU (student) {</p>

<pre><code>if (student === "Zach") {
    var str = student + " is awesome!";
} else {
    var str = student + " is NOT awesome!";
}
return str;
</code></pre>

<p>}
```</p>

<p>Now add an opening comment block - <code>/**</code> - and as soon as you press tab, it will create a dummy-documentation-comment automatically.</p>

<p>```javascript
/<em>*
 * [refactorU description]
 * @param  {[type]}
 * @return {[type]}
 </em>/
function refactorU (student) {</p>

<pre><code>if (student === "Zach") {
    return student + " is awesome!";
} else {
    return student + " is NOT awesome!";
}
</code></pre>

<p>}
```</p>

<p>Yay!</p>

<h3>GitGutter</h3>

<p><a href="https://packagecontrol.io/packages/GitGutter">GitGutter</a> displays icons in the "gutter" area (next to the line numbers) indicating whether an individual line has been modified since your last commit.</p>

<p><img src="https://raw.githubusercontent.com/mjhea0/sublime-javascript/master/img/gitgutter.png" alt="GitGutter" /></p>

<h3>Emmet</h3>

<p>With <a href="https://packagecontrol.io/packages/Emmet">Emmet</a> you can turn a symbol or code abbreviation into a HTML or CSS code snippet. It's by <em>far</em> the best plugin for increasing your productivity and efficiency as a web developer.</p>

<p>Try this out: Once installed, start a new HTML file, type a bang, <code>!</code>, and then press tab.</p>

<p>```html
&lt;!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body></p>

<p></body>
</html>
```</p>

<p>Boom!</p>

<p>Check the official <a href="http://docs.emmet.io/abbreviations/">docs</a> to see all the expressions/symbols/abbreviations that can be used for generating snippets.</p>

<h2>Conclusion</h2>

<p><em>Go pimp your editor.</em></p>

<blockquote><p>Want a package? It's just Python. Hire <a href="http://mherman.org">me</a>!</p></blockquote>

<p>Comment below. Check out the <a href="https://github.com/mjhea0/sublime-javascript">repo</a> for my Sublime dotfiles. Cheers!</p>

<h2>Additional Resources</h2>

<ol>
<li><a href="http://sublimetexttips.com/">Sublime Text Tips Newsletter</a> - awesome tips, tricks</li>
<li><a href="http://docs.sublimetext.info/en/latest/index.html">Community-maintained documentation</a></li>
<li><a href="https://packagecontrol.io/docs">Package Manager documentation</a></li>
<li><a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/reference.html">Unofficial documentation reference</a></li>
<li><a href="https://realpython.com/blog/python/setting-up-sublime-text-3-for-full-stack-python-development/">Setting Up Sublime Text 3 for Full Stack Python Development</a> - my other ST3 post</li>
</ol>

]]></content>
  </entry>
  
</feed>
