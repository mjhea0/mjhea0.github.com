<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Michael Herman]]></title>
  <link href="http://mjhea0.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://mjhea0.github.com/"/>
  <updated>2015-04-20T08:05:57-06:00</updated>
  <id>http://mjhea0.github.com/</id>
  <author>
    <name><![CDATA[Michael Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Adding a Captcha to Sinatra to Minimize Spam]]></title>
    <link href="http://mjhea0.github.com/blog/2014/05/04/adding-a-captcha-to-sinatra-to-minimize-spam/"/>
    <updated>2014-05-04T18:43:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2014/05/04/adding-a-captcha-to-sinatra-to-minimize-spam</id>
    <content type="html"><![CDATA[<p>Spam is irritating.</p>

<p>It's been especially irritating on a <a href="http://sinatra-sings.herokuapp.com/">blog</a> I created for a Sinatra <a href="http://mherman.org/blog/2013/06/08/designing-with-class-sinatra-plus-postgresql-plus-heroku">tutorial</a> hosted on Heroku where the database was filling up so quickly I had to run a <a href="https://github.com/mjhea0/sinatra-blog/blob/master/reset.rb">script</a> to delete all rows once a week. Ugh.</p>

<p>So, let’s add a <a href="https://github.com/bmizerany/sinatra-captcha">captcha</a> to our blog in just five simple steps that will take less than five minutes element in order to help prevent so much spam.</p>

<h2>Steps:</h2>

<h3>1. Add the following gem to your <em>Gemfile</em>:</h3>

<p><code>ruby
gem 'sinatra-captcha'
</code></p>

<h3>2. Update your gems and their dependencies:</h3>

<p><code>
$ bundle install
</code></p>

<h3>3. Update <em>app.rb</em>:</h3>

<p>```ruby
...</p>

<p>require 'sinatra/captcha'</p>

<p>...</p>

<p>post "/posts" do
  halt(401, "invalid captcha") unless captcha_pass?
  @post = Post.new(params[:post])
  if @post.save</p>

<pre><code>redirect "posts/#{@post.id}", :notice =&gt; 'Congrats! Love the new post. (This message will disapear in 4 seconds.)'
</code></pre>

<p>  else</p>

<pre><code>redirect "posts/create", :error =&gt; 'Something went wrong. Try again. (This message will disapear in 4 seconds.)'
</code></pre>

<p>  end
end</p>

<p>...
```</p>

<h3>4. Update the form in the <em>create.erb</em> view:</h3>

<p>```ruby
<form action="/posts" method="post"role="form"></p>

<div class="form-group">
  <label for="post_title">Title:</label>
  <br>
  <input id="post_title" class="form-control" name="post[title]" type="text" value="<%= @post.title %>" style="width=90%"/>
</div>


<div class="form-group">
  <label for="post_body">Body:</label>
  <br>
  <textarea id="post_body" name="post[body]" class="form-control" rows="10"><%= @post.body %></textarea>
  <br>
  <div><%= captcha_image_tag %></div>
  <br>
  <label>Captcha:</label>
  <%= captcha_answer_tag %>
</div>


<p><button type="submit" class="btn btn-success">Submit</button></p>

<br>


<p></form>
```</p>

<h3>5. Preview locally before updating Heroku:</h3>

<p><code>
$ ruby app.rb
</code></p>

<p>Navigate to <a href="http://localhost:4567/posts/create">http://localhost:4567/posts/create</a> and you should see:</p>

<p><img src="https://raw.githubusercontent.com/mjhea0/sinatra-blog/master/sinatra_blog_captcha.png" alt="sinatra_blog_captcha" /></p>

<h2>Conclusion</h2>

<p>From now on to post a new post, visitors have to complete the word verification. Keep in mind that this won't completely halt all spam - but it will greatly reduce it.</p>

<p><strong>Links:</strong></p>

<ul>
<li>My app: <a href="http://sinatra-sings.herokuapp.com/">http://sinatra-sings.herokuapp.com/</a></li>
<li>Git Repo: <a href="https://github.com/mjhea0/sinatra-blog">https://github.com/mjhea0/sinatra-blog</a></li>
<li>Previous tutorial: <a href="http://mherman.org/blog/2013/06/08/designing-with-class-sinatra-plus-postgresql-plus-heroku/#.U2bp4K1dWYU">Designing With Class: Sinatra + PostgreSQL + Heroku</a></li>
</ul>


<p>Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Up and Running with Espresso: Rapid web development in the browser]]></title>
    <link href="http://mjhea0.github.com/blog/2013/06/13/up-and-running-with-espresso-rapid-web-development-in-the-browser/"/>
    <updated>2013-06-13T08:06:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2013/06/13/up-and-running-with-espresso-rapid-web-development-in-the-browser</id>
    <content type="html"><![CDATA[<p><strong>Please note: The developer of Espresso is no longer maintaining the project. I revived it for the sake of this tutorial, but I will not be maintaining it either. If you wish to take on this awesome project, please contact me. Cheers!</strong></p>

<p>In this tutorial we'll be developing a simple application with <a href="https://github.com/mjhea0/espresso">Espresso</a>, a minimalist Ruby web framework, in the typical MVC fashion. We will also be using <a href="https://rubygems.org/gems/e">Enginery</a> and <a href="https://rubygems.org/gems/frontline">Frontline</a> to speed up the development process by developing straight from the browser.</p>

<h2>Espresso + Enginery</h2>

<p>Create a new project directory:</p>

<p><code>sh
$ mkdir espresso
</code></p>

<p>Install Espresso and Enginery:</p>

<p><code>ruby
$ gem install espresso-framework
$ gem install enginery
</code></p>

<p>Create a new application utilizing DataMapper:</p>

<p><code>sh
$ enginery g orm:dm
</code></p>

<p>Watch your terminal window. Enginery is generating a project structure, adding the required Gems ('data_mapper' and 'dm-sqlite-adapter') to the Gemfile, updating the Rakefile and configuration file, and finally running bundler to install the Gems.</p>

<p>Essentially, Enginery is similar to the Rails' Scaffolding functionality, allowing rapid development of a project built around the MCV-style architecture. It logically separates the project into Models, Views, and Controllers, and defines basic defaults - which can be modified to fit your particular application.</p>

<p>Next, generate your first model:</p>

<p><code>sh
$ enginery g:m Tasks column:name column:description:text
</code></p>

<p>This generates a Tasks model with 3 columns in it:
- <strong>id:</strong> primary key, generated automatically by DataMapper
- <strong>name:</strong> string, which is the default data type
- <strong>description:</strong>  text</p>

<p>Now we need to create a table for our Tasks model by migrating up the initialization migration. When we created our model, this generated a serial number associated with the migration. You can find the migrations within your project structure.</p>

<p>For example:</p>

<p><code>sh
base/migrations/tasks/1.2013-06-12_19-34-15.initializing-Tasks-model.rb
</code></p>

<p>This particular migration has a serial number of 1.</p>

<p>Let's finish the migration:</p>

<p><code>sh
$ enginery m:up 1
</code></p>

<p>With a table now associated with the database, let's add some tasks!</p>

<p>Fire up the server:</p>

<p><code>sh
$ ruby app.rb
</code></p>

<p>Then navigate to <a href="http://localhost:5252/admin">http://localhost:5252/admin</a>, click Tasks and add a few in. Get creative.</p>

<p>Fast, right? Let's get even faster with Frontline.</p>

<h2>Espresso + Enginery + Frontline</h2>

<p>Frontline is is a front-end manager for Enginery, which allows you to fully manage applications within the browser. Yes, you heard that right.</p>

<p>Install it:</p>

<p><code>sh
$ gem install frontline
</code></p>

<p>Run it:</p>

<p><code>sh
$ frontline
</code></p>

<p>Rock it: <a href="http://localhost:5000">http://localhost:5000</a></p>

<p>Boom! Is any explanation needed? Perhaps ...</p>

<p>Load your existing app using the project name, <code>espresso</code>, and the path, <code>/Users/michaelherman/desktop/espresso</code> (customize for your app and path). From here you have total control over setting up and maintaining your application. You can even put it under version control.</p>

<p>Let's update the base view. Click the "Maintenance" menu and select "layout.erb". Update the code:</p>

<p>```html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;title&gt;Espresso + Enginery + Frontline&lt;/title&gt;
&lt;link href="http://twitter.github.io/bootstrap/assets/css/bootstrap.css" rel="stylesheet"&gt;
&lt;link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'&gt;
</code></pre>

<p>  </head>
  <body style="padding-top: 50px;"></p>

<pre><code>&lt;div class="navbar navbar-fixed-top"&gt;
  &lt;div class="navbar-inner"&gt;
    &lt;div class="container"&gt;
      &lt;a class="brand" href="#"&gt;Espresso + Enginery + Frontline&lt;/a&gt;
        &lt;ul class="nav"&gt;
        &lt;/ul&gt;
        &lt;ul class="nav pull-right"&gt;
          &lt;li&gt;&lt;a href="http://mjhea0.github.com/"&gt;Home&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>  <div class="container"></p>

<pre><code>  &lt;%= yield %&gt;
</code></pre>

<p>  </div>
  </body>
</html>
```</p>

<p>Now let's add some controllers, routes, and additional views. Enginery already generated the <code>Index</code> controller with an <code>index</code> route in it. Let's create a new route within the <code>Index</code> controller. Click "Controllers" => "Index" => "New Actions". For the action name, enter "list" and click the arrow to the right to process.</p>

<p>Let's add some logic to the new route. Click "Index Action", and then "list". Add the following code to the <em>list.rb</em> file:</p>

<p>```ruby
class Index
  # action-specific setups</p>

<p>  def list</p>

<pre><code>@tasks = Tasks.all
render
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Then add the following code to <em>list.erb</em>:</p>

<p>```html</p>

<br/>


<ul>
<% @tasks.each do |task| %>
  <li>
  <h4><%= task.name %></h4>
  <p><%= task.description %></p>
  </li>
<% end %>
</ul>


<p>```</p>

<p>Then check out your live app at <a href="http://localhost:5252/list">http://localhost:5252/list</a></p>

<p><img src="http://content.screencast.com/users/Mike_Extentech/folders/Jing/media/45d09f61-b994-4ee4-a8ac-6034723747ff/00000164.png" alt="image" /></p>

<p>Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing with Class: Sinatra + PostgreSQL +  Heroku]]></title>
    <link href="http://mjhea0.github.com/blog/2013/06/08/designing-with-class-sinatra-plus-postgresql-plus-heroku/"/>
    <updated>2013-06-08T07:37:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2013/06/08/designing-with-class-sinatra-plus-postgresql-plus-heroku</id>
    <content type="html"><![CDATA[<p><strong>Change Log</strong>:</p>

<ol>
<li>September 29, 2013: bootstrap 3, jQuery, css</li>
<li>November 21, 2013: added the ability to edit posts, demonstarted how to escape HTML</li>
<li>May 4, 2014: added a captcha to the new post form to help prevent spam (see blog post <a href="http://mherman.org/blog/2014/05/04/adding-a-captcha-to-sinatra-to-minimize-spam/">here</a>)</li>
</ol>


<br>


<p>Know a little Ruby? Ready to start web development? Before jumping to Rails, get your hands dirty with Sinatra. It's the perfect learning tool. My recommendation: Start with a basic dynamic website, backed with SQLite. Create and manage your database tables with raw SQL. Practice deploying on Heroku. Practice.</p>

<p>Once you feel good, add another step. Perhaps switch to DataMapper or ActiveRecord for managing your database with objects. Add a more complex database, such as  PostgreSQL.</p>

<p>Finally, get familiar with front-end. Start with Bootstrap. Play around with JavaScript.</p>

<h2>In this tutorial ...</h2>

<p>… we'll be hitting the middle ground. You'll be creating a basic blog app. Before you yawn and move on, we will be using some awesome tools/gems for rapid development:</p>

<ul>
<li><strong>Sinatra</strong>: the web framework, of course</li>
<li><strong>PostgreSQL</strong>: the database management system</li>
<li><strong>ActiveRecord</strong>: the ORM</li>
<li><strong>sinatra-activerecord</strong>: ports ActiveRecord for Sinatra</li>
<li><strong>Tux</strong>: provides a Shell for Sinatra so we can interact with our application</li>
</ul>


<blockquote><p>This tutorial assumes you are running a Unix-based environment - e.g, Mac OSX, straight Linux, or Linux VM through Windows. I will also be using Sublime 2 as my text editor.</p></blockquote>

<h3>Let's get Sinatra singing!</h3>

<h2>Getting started</h2>

<h3>Start by creating a project directory somewhere on your file system:</h3>

<p><code>sh
$ mkdir sinatra-blog
</code></p>

<h3>Setup your gems using a Gemfile. Create the following <em>Gemfile</em> (no extension) within your main directory:</h3>

<p>```ruby</p>

<h1>Gemfile</h1>

<p>source 'https://rubygems.org'
ruby "2.0.0"</p>

<p>gem "sinatra"
gem "activerecord"
gem "sinatra-activerecord"
gem 'sinatra-flash'
gem 'sinatra-redirect-with-flash'</p>

<p>group :development do
 gem 'sqlite3'
 gem "tux"
end</p>

<p>group :production do
 gem 'pg'
end
```</p>

<p>Notice how we're using SQLite3 for our development environment and PostgreSQL for production, in order to simply the dev process.</p>

<h3>Install the gems:</h3>

<p><code>sh
$ bundle install
</code></p>

<p>This will create <em>Gemfile.lock</em>, displaying the exact versions of each gem that were installed.</p>

<h3>Create a <em>config.ru</em> file, which is a standard convention that Heroku looks for.</h3>

<p>```ruby</p>

<h1>config.ru</h1>

<p>require './app'
run Sinatra::Application
```</p>

<h2>Model</h2>

<h3>Create a file called <em>environments.rb</em> and include the following code for our database configuration:</h3>

<p>```ruby
configure :development do
 set :database, 'sqlite:///dev.db'
 set :show_exceptions, true
end</p>

<p>configure :production do
 db = URI.parse(ENV['DATABASE_URL'] || 'postgres:///localhost/mydb')</p>

<p> ActiveRecord::Base.establish_connection(
   :adapter  => db.scheme == 'postgres' ? 'postgresql' : db.scheme,
   :host     => db.host,
   :username => db.user,
   :password => db.password,
   :database => db.path[1..-1],
   :encoding => 'utf8'
 )
end
```</p>

<h3>Next, create the main application file, "app.rb". Make sure to include the required gems and the <em>environments.rb</em> file we just created.</h3>

<p>```ruby</p>

<h1>app.rb</h1>

<p>require 'sinatra'
require 'sinatra/activerecord'
require './environments'</p>

<p>class Post &lt; ActiveRecord::Base
end
```</p>

<h3>Create a <em>Rakefile</em> (again, no extension) so we can use migrations for setting up the data model:</h3>

<p>```ruby</p>

<h1>Rakefile</h1>

<p>require './app'
require 'sinatra/activerecord/rake'
```</p>

<h3>Now run the following command to setup the migration files:</h3>

<p><code>sh
$ rake db:create_migration NAME=create_posts
</code></p>

<p>If you look at your project structure. You'll see a new folder called "db" and within that folder another folder called "migrate." You should then see a Ruby script with a timestamp. This is a migration file. The timestamp tells ActiveRecord the order in which to apply the migrations in case there is more than one file.</p>

<h3>Essentially, these migration files are used for setting up your database tables. Edit the file now.</h3>

<blockquote><p>The up method is used when we complete the migration (<code>rake db:migrate</code>), while the down method is ran when we rollback the last migration (<code>rake db:rollback</code>).</p></blockquote>

<p>```ruby  <br/>
class CreatePosts &lt; ActiveRecord::Migration
 def self.up
   create_table :posts do |t|</p>

<pre><code> t.string :title
 t.text :body
 t.timestamps
</code></pre>

<p>   end
 end</p>

<p> def self.down
   drop_table :posts
 end
end
```</p>

<h3>Run the migration</h3>

<p><code>sh
$ rake db:migrate
</code></p>

<p>Just so you know, ActiveRecord created these table columns: <code>id</code>, <code>title</code>, <code>body</code>, <code>created_at</code>, <code>updated_at</code></p>

<p>When you create a new post, you only need to specify the title and body; the remaining fields are generated automatically with ActiveRecord's magic! Pretty cool, eh?</p>

<h3>Use tux in order to add some data to the database.</h3>

<p>```sh
$ tux</p>

<blockquote><blockquote><p>Post.create(title: 'Testing the title', body: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum venenatis eros eget lectus hendrerit, sed mattis quam pretium. Aenean accumsan eget leo non cursus. Aliquam sagittis luctus mi, quis suscipit neque venenatis et. Pellentesque vitae elementum diam. Quisque iaculis eget neque mattis fermentum. Donec et luctus eros. Suspendisse egestas pharetra elit vel bibendum.')</p>

<p>Post.all
D, [2013-06-08T12:26:44.929333 #42914] DEBUG -- :   Post Load (0.2ms)  SELECT "posts".* FROM "posts"
=> [#<Post id: 1, title: "Testing the title", body: "Lorem ipsum dolor sit amet, consectetur adipiscing ...", created_at: "2013-06-08 12:24:12", updated_at: "2013-06-08 12:24:12">]
```</p></blockquote></blockquote>

<p>Did you notice the actual SQL syntax used for each command? No? Look again.</p>

<p>Add a few more posts. Then exit:</p>

<p>```sh</p>

<blockquote><blockquote><blockquote><p>exit
```</p></blockquote></blockquote></blockquote>

<h2>Version Control</h2>

<h3>Before moving on, let's get this app under version control.</h3>

<p><code>sh
$ git init
$ git add .
$ git commit -am "initial commit"
</code></p>

<h2>Templates and views</h2>

<h3>Add the following code to <em>app.rb</em> to setup the first route:</h3>

<p><code>ruby
get "/" do
  @posts = Post.order("created_at DESC")
  @title = "Welcome."
  erb :"posts/index"
end
</code></p>

<p>This maps the <code>/</code> url to the template <em>index.html</em> (or <em>index.erb</em> in Ruby terms), found in ""views/posts/" directory.</p>

<blockquote><p>Note: The <em>app.rb</em> file is the controller in MVC-style architecture.</p></blockquote>

<p>Add the helper for the title variable:</p>

<p>```ruby  <br/>
helpers do
  def title</p>

<pre><code>if @title
  "#{@title}"
else
  "Welcome."
end
</code></pre>

<p>  end
end
```</p>

<p>Fire up the dev server:</p>

<p><code>ruby
$ ruby app.rb
</code></p>

<p>Then navigate to <a href="http://localhost:4567/">http://localhost:4567/</a>. You should see an error indicating the template can't be found - "/sinatra-blog/views/posts/index.erb". In other words, the URL routing is working; we just need to set up a template.</p>

<p>First create two new directories - "views/posts" ...</p>

<h3>Now, setup the associated template called <em>index.erb</em>:</h3>

<p>```html</p>

<ul>
<% @posts.each do |post| %>
 <li>
   <h4><a href="http://mjhea0.github.com/posts/<%= post.id %>"><%= post.title %></a></h4>
   <p>Created: <%= post.created_at %></p>
 </li>
<% end %>
</ul>


<p>```</p>

<p>Save this file within the "posts" directory.</p>

<h3>Now set up the <em>layout.erb</em> template, which is used as the parent template for all other templates. This is just a convention used to speed up development. Child templates, such as <em>index.erb</em> inherent the HTML and CSS (common code) from the parent template.</h3>

<p><code>html
&lt;html&gt;
&lt;head&gt;
 &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
 &lt;ul&gt;
   &lt;li&gt;&lt;a href="http://mjhea0.github.com/"&gt;Home&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href="http://mjhea0.github.com/posts/create"&gt;New Post&lt;/a&gt;&lt;/li&gt;
 &lt;/ul&gt;
 &lt;%= yield %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>Save this file within the "views" directory.</p>

<blockquote><p>The yield method indicates where templates are embedded.</p></blockquote>

<h3>Kill the server. Fire it back up. Go back to <a href="http://localhost:4567/">http://localhost:4567/</a>. Refresh. You should see your basic blog. Click on a link for one of the posts. Since we don't have a route associated with that URL, Sinatra gives us a little suggestion.</h3>

<h3>Route and template for viewing each post.</h3>

<p>Route:</p>

<p><code>ruby            
get "/posts/:id" do
 @post = Post.find(params[:id])
 @title = @post.title
 erb :"posts/view"
end
</code></p>

<p>Template (called <em>view.erb</em>):</p>

<p>```html</p>

<h1><%= @post.title %></h1>


<p><%= @post.body %></p>
```

### Route and template for adding new posts.

Route:

```ruby    
get "/posts/create" do
 @title = "Create post"
 @post = Post.new
 erb :"posts/create"
end
```
        
Template (called *create.erb*):

```html   
<h2>Create Post</h2>
<br/>
<form action="/posts" method="post"role="form">
 <div class="form-group">
   <label for="post_title">Title:</label>
   <br>
   <input id="post_title" class="form-control" name="post[title]" type="text" value="<%= @post.title %>" style="width=90%"/>
 </div>
 <div class="form-group">
   <label for="post_body">Body:</label>
   <br>
   <textarea id="post_body" name="post[body]" class="form-control" rows="10"><%= @post.body %></textarea>
 </div>
 <button type="submit" class="btn btn-success">Submit</button>
</form>
```
        
### We also need a route for handling the POST requests.

```ruby
post "/posts" do
 @post = Post.new(params[:post])
 if @post.save
   redirect "posts/#{@post.id}"
 else
   erb :"posts/create"
 end
end
```
        
### Test this out. Did it work? If you get this error "Couldn't find Post with ID=new" you need to put the last two routes above the route for viewing each post:

```ruby
# app.rb

require 'sinatra'
require 'sinatra/activerecord'
require './environments'


class Post < ActiveRecord::Base
end

get "/" do
  @posts = Post.order("created_at DESC")
  @title = "Welcome."
  erb :"posts/index"
end

helpers do
  def title
    if @title
      "#{@title}"
    else
      "Welcome."
    end
  end
end

get "/posts/create" do
 @title = "Create post"
 @post = Post.new
 erb :"posts/create"
end

post "/posts" do
 @post = Post.new(params[:post])
 if @post.save
   redirect "posts/#{@post.id}"
 else
   erb :"posts/create"
 end
end

get "/posts/:id" do
 @post = Post.find(params[:id])
 @title = @post.title
 erb :"posts/view"
end
```

## Validation and Flash Messages


### Add some basic validation to *app.rb*:

```ruby
class Post < ActiveRecord::Base
 validates :title, presence: true, length: { minimum: 5 }
 validates :body, presence: true
end
```
    
So, both the title and body cannot be null, and the title has to be at least 5 characters long.        

### Navigate to [http://localhost:4567/posts/create](http://localhost:4567/posts/create). Try to submit a blank post and then submit a real one. It's a bit confusing to the user when a blank post is submitted and nothing happens, so add some messages indicating that an error has occurred.

### First, add this to the top of *app.rb*:

```ruby
require 'sinatra/flash'
require 'sinatra/redirect_with_flash'

enable :sessions
```
        
### Update the POST request route:

```ruby
post "/posts" do
 @post = Post.new(params[:post])
 if @post.save
   redirect "posts/#{@post.id}", :notice => 'Congrats! Love the new post. (This message will disapear in 4 seconds.)'
 else
   redirect "posts/create", :error => 'Something went wrong. Try again. (This message will disapear in 4 seconds.)'
 end
end
```
        
### Add the following code to the *layout.erb* template just above the yield method:

```ruby
<% if flash[:notice] %>
 <p class="alert alert-success"><%= flash[:notice] %>
<% end %>
<% if flash[:error] %>
 <p class="alert alert-error"><%= flash[:error] %>
<% end %>  
```
        
Now test it again!

## Styles

The app is ugly. Add some quick bootstrap styling. 

### Updated *layout.erb*:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <title><%= title %></title>
    <link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body {
        padding-top: 75px;
      }
      .starter-template {
        padding: 40px 15px;
        text-align: center;
      }
      .container {
        max-width:1000px;
      }  
    </style>
  </head>

  <body>

    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="http://mjhea0.github.com/">Sinatra Sings</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="http://mjhea0.github.com/">Home</a></li>
            <li><a href="http://mjhea0.github.com/posts/create">New Post</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>


    <div class="container">

      <% if flash[:notice] %>
        <p class="alert alert-success"><%= flash[:notice] %>
      <% end %>
      <% if flash[:error] %>
        <p class="alert alert-warning"><%= flash[:error] %>
      <% end %> 
      <%= yield %>

    </div><!-- /.container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="http://getbootstrap.com/dist/js/bootstrap.min.js"></script>
    <script>
    //** removes alerts after 4 seconds */
    window.setTimeout(function() {
        $(".alert").fadeTo(4500, 0).slideUp(500, function(){
            $(this).remove(); 
        });
    }, 4000);
    </script>
  </body>
</html>
```

Looking good? Well, a little better.

```sh
$ git add .
$ git commit -am "updated"
```

## Edit Posts

Alright. We need to be able to edit live posts.

### Update app.rb

```ruby
# app.rb

require 'sinatra'
require 'sinatra/activerecord'
require './environments'
require 'sinatra/flash'
require 'sinatra/redirect_with_flash'

enable :sessions


class Post < ActiveRecord::Base
  validates :title, presence: true, length: { minimum: 5 }
  validates :body, presence: true
end

helpers do
  def title
    if @title
      "#{@title}"
    else
      "Welcome."
    end
  end
end

# get ALL posts
get "/" do
  @posts = Post.order("created_at DESC")
  @title = "Welcome."
  erb :"posts/index"
end

# create new post
get "/posts/create" do
  @title = "Create post"
  @post = Post.new
  erb :"posts/create"
end
post "/posts" do
  @post = Post.new(params[:post])
  if @post.save
    redirect "posts/#{@post.id}", :notice => 'Congrats! Love the new post. (This message will disapear in 4 seconds.)'
  else
    redirect "posts/create", :error => 'Something went wrong. Try again. (This message will disapear in 4 seconds.)'
  end
end

# view post
get "/posts/:id" do
  @post = Post.find(params[:id])
  @title = @post.title
  erb :"posts/view"
end

# edit post
get "/posts/:id/edit" do
  @post = Post.find(params[:id])
  @title = "Edit Form"
  erb :"posts/edit"
end
put "/posts/:id" do
  @post = Post.find(params[:id])
  @post.update(params[:post])
  redirect "/posts/#{@post.id}"
end
```

### Add an edit template

```html
<h2>Edit Post</h2>
<br/>
<form action="/posts/<%= @post.id %>" method="post">
 <div class="form-group">
  <input type="hidden" name="_method" value="put" /> 
  <label for="post_title">Title:</label>
  <br>
  <input id="post_title" class="form-control" name="post[title]" type="text" value="<%= @post.title %>" />
 </div>
 <div class="form-group">
  <label for="post_body">Body:</label>
  <br>
  <textarea id="post_body" name="post[body]" class="form-control" rows="5"><%= @post.body %></textarea>
 </div>
  <button type="submit" class="btn btn-success">Submit</button>
</form>
```

### Update the view template

```html
<h1><%= @post.title %></h1>
<p><%= @post.body %></p>
<br>
<a href="http://mjhea0.github.com/posts/<%= @post.id %>/edit">Edit Post</a>
```

## Test and Commit to Git

Yes, test to ensure you can edit posts locally, then add and commit to Git.

## Properly Escaping

Currently, you can enter really anything into the input boxes for the title and body, including HTML. Test this out. Enter these code snippets in the title and/or or body:

1. `<strong>Very, very strong</strong>`
2. `<script>alert('happy birthday');</script>`

See the issue? We need to escape the text properly in order to avoid this. 

### Update app.rb

Add the following helper:

```ruby
helpers do
  include Rack::Utils
  alias_method :h, :escape_html
end
```

### Update the view template

```html
<h1><%=h @post.title %></h1>
<p><%=h @post.body %></p>
<br>
<a href="http://mjhea0.github.com/posts/<%= @post.id %>/edit">Edit Post</a>
```

### Update the edit template

```html
<h2>Edit Post</h2>
<br/>
<form action="/posts/<%= @post.id %>" method="post">
 <div class="form-group">
  <input type="hidden" name="_method" value="put" /> 
  <label for="post_title">Title:</label>
  <br>
  <input id="post_title" class="form-control" name="post[title]" type="text" value="<%=h @post.title %>" />
 </div>
 <div class="form-group">
  <label for="post_body">Body:</label>
  <br>
  <textarea id="post_body" name="post[body]" class="form-control" rows="5"><%=h @post.body %></textarea>
 </div>
  <button type="submit" class="btn btn-success">Submit</button>
</form>
```

### Update the index template

```html
<ul>
<% @posts.each do |post| %>
 <li>
   <h4><a href="http://mjhea0.github.com/posts/<%= post.id %>"><%=h post.title %></a></h4>
   <p>Created: <%=h post.created_at %></p>
 </li>
<% end %>
</ul>
```

Now try to enter `<strong>Very, very strong</strong>`. Notice the difference? See [this](http://www.sinatrarb.com/faq.html#escape_html) page for further explanation.

Commit to Git again.

## Deploy

Finally, let's get this app live on Heroku!

### Create an account on Heroku. (if needed)
### Install the gem - `sudo gem install heroku` (if needed)
### Generate an SSH key. (if needed)
### Push to Heroku:

```sh
$ heroku create <my-app-name>.
$ git push heroku master
```
        
### Rake the remote database:

```sh
$ heroku rake db:migrate
```

### Boom! Check out your live app.

Links:

- My app: [http://sinatra-sings.herokuapp.com/](http://sinatra-sings.herokuapp.com/)
- Git Repo: [https://github.com/mjhea0/sinatra-blog](https://github.com/mjhea0/sinatra-blog)

*Sinatra has ended his set (crowd applauds as he exits the main stage).*

## Add a captcha

Help elimiante spam by adding a captcha to the new post form. View the blog post - [Adding a Captcha to Sinatra to Minimize Spam](http://mherman.org/blog/2014/05/04/adding-a-captcha-to-sinatra-to-minimize-spam/).



   
    

]]></content>
  </entry>
  
</feed>
