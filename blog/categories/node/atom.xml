<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Node | Michael Herman]]></title>
  <link href="http://mherman.org/blog/categories/node/atom.xml" rel="self"/>
  <link href="http://mherman.org/"/>
  <updated>2016-08-16T08:21:10-06:00</updated>
  <id>http://mherman.org/</id>
  <author>
    <name><![CDATA[Michael Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swagger and NodeJS]]></title>
    <link href="http://mherman.org/blog/2016/05/26/swagger-and-nodejs/"/>
    <updated>2016-05-26T07:22:46-06:00</updated>
    <id>http://mherman.org/blog/2016/05/26/swagger-and-nodejs</id>
    <content type="html"><![CDATA[<p><strong>This tutorial details how to describe a RESTFul API using <a href="http://swagger.io/">Swagger</a> along with Node and Express.</strong></p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/node-swagger.png" style="max-width: 100%; border:0; box-shadow: none;" alt="node swagger api">
</div>


<p><br></p>

<p>By the end of this tutorial, you will be able to&hellip;</p>

<ol>
<li>Describe the purpose of Swagger</li>
<li>Generate a <a href="http://swagger.io/specification/">Swagger Spec</a> based on an existing RESTful API developed with Node, Express, and Postgres</li>
<li>Set up the <a href="https://github.com/swagger-api/swagger-ui">Swagger UI</a> for testing and interacting with the API</li>
</ol>


<h2>Swagger</h2>

<p>Swagger is a <a href="http://swagger.io/specification/">specification</a> for describing, producing, consuming, testing, and visualizing a RESTful API. It provides a number of <a href="http://swagger.io/tools/">tools</a> for automatically generating documentation based on a given endpoint.</p>

<p>Now when you make changes to your code, your documentation is updated and synchronized with the API so that consumers can quickly learn which resources are available, how to access them, and what to expect (status code, content-type, etc.) when interacting with the various endpoints.</p>

<h2>Getting Started</h2>

<h3>Starting a New Project</h3>

<p>If you&rsquo;re starting a new project, you can easily generate the <a href="http://swagger.io/specification/">Swagger Specification</a> and project boilerplate using the <a href="http://swagger.io/swagger-editor/">Swagger Editor</a>. Test it out <a href="http://editor.swagger.io/#/">here</a>.</p>

<p>If you don&rsquo;t like the generated project structure, you can just export the JSON (or YAML) spec file and then use a custom generator, like <a href="https://github.com/krakenjs/swaggerize-express">Swaggerize Express</a>, to generate the boilerplate. Then when you need to make changes to the API, you can just update the spec file. Simple.</p>

<h3>Updating an Existing Project</h3>

<p>For this tutorial, we will be generating the Swagger spec based on the code from a previously created project that has the following RESTful endpoints:</p>

<table style="font-size:18px;border-spacing:12px 0px;border-collapse:separate;border:1px solid black;">
<thead>
<tr>
<th style="text-align:center"><strong>URL</strong></th>
<th style="text-align:center"><strong>HTTP Verb</strong></th>
<th style="text-align:center"><strong>Action</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>/api/puppies</td>
<td>GET</td>
<td>Return ALL puppies</td>
</tr>
<tr>
<td>/api/puppies/:id</td>
<td>GET</td>
<td>Return a SINGLE puppy</td>
</tr>
<tr>
<td>/api/puppies</td>
<td>POST</td>
<td>Add a puppy</td>
</tr>
<tr>
<td>/api/puppies/:id</td>
<td>PUT</td>
<td>Update a puppy</td>
</tr>
<tr>
<td>/api/puppies/:id</td>
<td>DELETE</td>
<td>Delete a puppy</td>
</tr>
</tbody>
</table>


<p>Clone down the project:</p>

<pre><code class="sh">$ git clone https://github.com/mjhea0/node-postgres-promises.git node-swagger-api
$ cd node-swagger-api
$ git checkout tags/v1 -b swagger
$ npm install
</code></pre>

<blockquote><p>Want to learn how this project was created? Check out the <a href="http://mherman.org/blog/2016/03/13/designing-a-restful-api-with-node-and-postgres/#.V0N4PZMrJE4">Designing a RESTful API With Node and Postgres</a> post.</p></blockquote>

<p>This project uses Postgres, so run create the database and apply the schema:</p>

<pre><code class="sh">$ psql -f puppies.sql
</code></pre>

<p>Run the server, and then navigate to <a href="http://localhost:3000/api/puppies">http://localhost:3000/api/puppies</a> in your browser of choice. You should see:</p>

<pre><code class="json">{
  status: "success",
  data: [
    {
      id: 1,
      name: "Tyler",
      breed: "Shih-tzu",
      age: 3,
      sex: "M"
    }
  ],
  message: "Retrieved ALL puppies"
}
</code></pre>

<p>Test out each endpoint to make sure everything works before moving on.</p>

<h2>Generating the Swagger Spec</h2>

<p>To generate the <a href="http://swagger.io/specification/">Swagger specification</a>, we will be using <a href="https://github.com/Surnet/swagger-jsdoc">swagger-jsdoc</a>.</p>

<p>Install swagger-jsdoc:</p>

<pre><code class="sh">$ npm install swagger-jsdoc@1.3.0 --save
</code></pre>

<p>Add the requirement to <em>app.js</em>:</p>

<pre><code class="javascript">var swaggerJSDoc = require('swagger-jsdoc');
</code></pre>

<p>Then add the following code to <em>app.js</em> just below <code>var app = express();</code>:</p>

<pre><code class="javascript">// swagger definition
var swaggerDefinition = {
  info: {
    title: 'Node Swagger API',
    version: '1.0.0',
    description: 'Demonstrating how to describe a RESTful API with Swagger',
  },
  host: 'localhost:3000',
  basePath: '/',
};

// options for the swagger docs
var options = {
  // import swaggerDefinitions
  swaggerDefinition: swaggerDefinition,
  // path to the API docs
  apis: ['./routes/*.js'],
};

// initialize swagger-jsdoc
var swaggerSpec = swaggerJSDoc(options);
</code></pre>

<p>Take note of the comments above. This code essentially initializes swagger-jsdoc and adds the appropriate metadata to the Swagger specification.</p>

<p>Add the route to serve up the Swagger spec:</p>

<pre><code class="javascript">// serve swagger
app.get('/swagger.json', function(req, res) {
  res.setHeader('Content-Type', 'application/json');
  res.send(swaggerSpec);
});
</code></pre>

<p>Fire up the server and navigate to <a href="http://localhost:3000/swagger.json">http://localhost:3000/swagger.json</a> to see the basic spec:</p>

<pre><code class="json">{
  info: {
    title: "Node Swagger API",
    version: "1.0.0",
    description: "Demonstrating how to describe a RESTful API with Swagger"
  },
  host: "localhost:3000",
  basePath: "/",
  swagger: "2.0",
  paths: { },
  definitions: { },
  responses: { },
  parameters: { },
  securityDefinitions: { }
}
</code></pre>

<p>Now we need to update the routes&hellip;</p>

<h2>Updating the Route Handlers</h2>

<p>swagger-jsdoc uses <a href="http://usejsdoc.org/">JSDoc</a>-style comments to generate the Swagger spec. So, add such comments, in YAML, to the route handlers that describe their functionality.</p>

<h3>GET ALL</h3>

<p>Add the comments in <em>/routes/index.js</em> just above the handler, like so:</p>

<pre><code class="javascript">/**
 * @swagger
 * /api/puppies:
 *   get:
 *     tags:
 *       - Puppies
 *     description: Returns all puppies
 *     produces:
 *       - application/json
 *     responses:
 *       200:
 *         description: An array of puppies
 *         schema:
 *           $ref: '#/definitions/Puppy'
 */
router.get('/api/puppies', db.getAllPuppies);
</code></pre>

<p>This should be fairly self-explanatory. We have an <code>/api/puppies</code> endpoint that returns a 200 response to a GET request. The <code>$ref</code> is used to re-use definitions to keep the code DRY.</p>

<p>Add the following code above the previous code:</p>

<pre><code class="javascript">/**
 * @swagger
 * definition:
 *   Puppy:
 *     properties:
 *       name:
 *         type: string
 *       breed:
 *         type: string
 *       age:
 *         type: integer
 *       sex:
 *         type: string
 */
</code></pre>

<p>Now we can use that definition for each of the HTTP methods.</p>

<p>For more information and examples, please see the <a href="http://swagger.io/specification/">Swagger Specification</a>.</p>

<h3>GET Single</h3>

<pre><code class="javascript">/**
 * @swagger
 * /api/puppies/{id}:
 *   get:
 *     tags:
 *       - Puppies
 *     description: Returns a single puppy
 *     produces:
 *       - application/json
 *     parameters:
 *       - name: id
 *         description: Puppy's id
 *         in: path
 *         required: true
 *         type: integer
 *     responses:
 *       200:
 *         description: A single puppy
 *         schema:
 *           $ref: '#/definitions/Puppy'
 */
</code></pre>

<h3>POST</h3>

<pre><code class="javascript">/**
 * @swagger
 * /api/puppies:
 *   post:
 *     tags:
 *       - Puppies
 *     description: Creates a new puppy
 *     produces:
 *       - application/json
 *     parameters:
 *       - name: puppy
 *         description: Puppy object
 *         in: body
 *         required: true
 *         schema:
 *           $ref: '#/definitions/Puppy'
 *     responses:
 *       200:
 *         description: Successfully created
 */
</code></pre>

<h3>PUT</h3>

<pre><code class="javascript">/**
 * @swagger
 * /api/puppies/{id}:
 *   put:
 *     tags: Puppies
 *     description: Updates a single puppy
 *     produces: application/json
 *     parameters:
 *       name: puppy
 *       in: body
 *       description: Fields for the Puppy resource
 *       schema:
 *         type: array
 *         $ref: '#/definitions/Puppy'
 *     responses:
 *       200:
 *         description: Successfully updated
 */
</code></pre>

<h3>DELETE</h3>

<pre><code class="javascript">/**
 * @swagger
 * /api/puppies/{id}:
 *   delete:
 *     tags:
 *       - Puppies
 *     description: Deletes a single puppy
 *     produces:
 *       - application/json
 *     parameters:
 *       - name: id
 *         description: Puppy's id
 *         in: path
 *         required: true
 *         type: integer
 *     responses:
 *       200:
 *         description: Successfully deleted
 */
</code></pre>

<p>Check out the updated spec at <a href="http://localhost:3000/swagger.json">http://localhost:3000/swagger.json</a>.</p>

<h2>Adding Swagger UI</h2>

<p>Finally, download the <a href="https://github.com/swagger-api/swagger-ui">Swagger UI repo</a>, add the &ldquo;dist&rdquo; folder from the downloaded repo to the &ldquo;public&rdquo; folder in the project directory, and then rename the directory to &ldquo;api-docs&rdquo;.</p>

<p>Now within <em>index.html</em> inside the &ldquo;api-docs&rdquo; directory just update this line-</p>

<pre><code class="html">url = "http://petstore.swagger.io/v2/swagger.json";
</code></pre>

<p>To-</p>

<pre><code class="html">url = "http://localhost:3000/swagger.json";
</code></pre>

<p>Finally, navigate to <a href="http://localhost:3000/api-docs/">http://localhost:3000/api-docs/</a> in your browser to test out the API endpoints:</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/swagger-ui.png" style="max-width: 100%; border:0; box-shadow: none;" alt="Swagger UI">
</div>


<p><br><hr><br></p>

<p>Download the <a href="https://github.com/mjhea0/node-swagger-api">code</a> from the repo. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Driven Development With Node, Postgres, and Knex (Red/Green/Refactor)]]></title>
    <link href="http://mherman.org/blog/2016/04/28/test-driven-development-with-node/"/>
    <updated>2016-04-28T08:07:39-06:00</updated>
    <id>http://mherman.org/blog/2016/04/28/test-driven-development-with-node</id>
    <content type="html"><![CDATA[<p><strong>Today we will be developing a RESTful API with <a href="https://nodejs.org">Node</a>, <a href="http://expressjs.com/">Express</a>, <a href="http://knexjs.org/">Knex</a> - a SQL query builder - and <a href="http://www.postgresql.org/">PostgreSQL</a> using test driven development (TDD).</strong></p>

<p>This post assumes prior knowledge of:</p>

<ul>
<li>SQL</li>
<li>Node/Express</li>
<li>NPM Packages</li>
</ul>


<h2>Getting Started</h2>

<p>Before we can start testing and writing code we need to set up our project, a database, and all the required dependencies&hellip;</p>

<h3>Project Setup</h3>

<p>First, we need to create a basic boilerplate Express application. To do this, first install the <a href="http://expressjs.com/en/starter/generator.html">Express-Generator</a> globally:</p>

<pre><code class="sh">$ npm install express-generator@4.13.1 -g
</code></pre>

<p>We can now generate a basic Express application boilerplate:</p>

<pre><code class="sh">$ express mocha-chai-knex
$ cd mocha-chai-knex
$ npm install
</code></pre>

<p>Run <code>npm start</code> to ensure the application works. Once the server is running, navigate to <a href="http://localhost:3000/">http://localhost:3000/</a>, and you should see &lsquo;Welcome to Express&rsquo; on the main page.</p>

<h3>Database Setup</h3>

<p>Start by installing <a href="http://www.postgresql.org/">PostgreSQL</a> from the official <a href="http://www.postgresql.org/download/">download page</a>.</p>

<blockquote><p>If you&rsquo;re on a Mac we recommend using <a href="http://postgresapp.com/">Postgress.app</a>.</p></blockquote>

<p>As noted, we&rsquo;ll be using <a href="http://knexjs.org/">Knex</a> to interact with our database. Knex is a SQL query builder that we can use with PostgreSQL to handle migrations, manage the schema, and query the database.</p>

<p>Let&rsquo;s start by installing <a href="http://knexjs.org/">Knex</a> and <a href="https://github.com/brianc/node-postgres">pg</a>, a module for interacting with Postgres.</p>

<pre><code class="sh">$ npm install pg@4.5.3 knex@0.10.0 --save
$ npm install knex@0.10.0 -g
</code></pre>

<p>Next, we need to create two new databases, one for developing and the other for testing. Open <a href="http://www.postgresql.org/docs/9.5/static/app-psql.html">psql</a> in the terminal, and create a new database:</p>

<pre><code class="sh">$ psql
psql (9.4.5)
Type "help" for help.

# CREATE DATABASE mocha_chai_tv_shows;
CREATE DATABASE
# CREATE DATABASE mocha_chai_tv_shows_test;
CREATE DATABASE
# \q
</code></pre>

<p>With out database created we can initialize Knex.</p>

<h3>Knex Setup</h3>

<p>Run the following command to create <em>knexfile.js</em>, the <a href="http://knexjs.org/#knexfile">Knex configuration file</a>:</p>

<pre><code class="sh">$ knex init
Created ./knexfile.js
</code></pre>

<p>Update the default info to:</p>

<pre><code class="javascript">module.exports = {
  test: {
    client: 'pg',
    connection: 'postgres://localhost/mocha_chai_tv_shows_test',
    migrations: {
      directory: __dirname + '/db/migrations'
    },
    seeds: {
      directory: __dirname + '/db/seeds/test'
    }
  },
  development: {
    client: 'pg',
    connection: 'postgres://localhost/mocha_chai_tv_shows',
    migrations: {
      directory: __dirname + '/db/migrations'
    },
    seeds: {
      directory: __dirname + '/db/seeds/development'
    }
  },
  production: {
    client: 'pg',
    connection: process.env.DATABASE_URL,
    migrations: {
      directory: __dirname + '/db/migrations'
    },
    seeds: {
      directory: __dirname + '/db/seeds/production'
    }
  }
};
</code></pre>

<p>This sets up three different settings for our databases:</p>

<ol>
<li><code>test</code> - for testing on the local environment</li>
<li><code>development</code> - for developing, again on the local environment</li>
<li><code>production</code> - for the production environment</li>
</ol>


<p>Now, we can add schema migrations. <a href="https://en.wikipedia.org/wiki/Schema_migration">Migrations</a> allow us to define and update the database schema. We can create migrations in the terminal like so:</p>

<pre><code class="sh">$ knex migrate:make tv_shows
</code></pre>

<p>Now, knex has automatically added in a &ldquo;db/migrations&rdquo; folder, with a timestamped file inside of it. Here is where we define our schema. It should just contain two empty functions at the moment.</p>

<p> Let&rsquo;s add in our code to create and drop tables.</p>

<pre><code class="javascript">exports.up = function(knex, Promise) {
  return knex.schema.createTable('shows', function(table){
    table.increments();
    table.string('name').notNullable().unique();
    table.string('channel').notNullable();
    table.string('genre').notNullable();
    table.integer('rating').notNullable();
    table.boolean('explicit').notNullable();
  });
};

exports.down = function(knex, Promise) {
  return knex.schema.dropTable('shows');
};
</code></pre>

<p>Here, the <code>up</code> function creates the <code>shows</code> table while the <code>down</code> function drops the table. So we now have a schema defined, and a migration file ready to create that schema.</p>

<p>Create a new file called <em>knex.js</em> inside the &ldquo;db&rdquo; folder. In this file we specify the environment (<code>test</code>, <code>development</code>, or <code>production</code>), require the <em>knexfile.js</em>, and export the configuration (based on the environment) for our database:</p>

<pre><code class="javascript">var environment = process.env.NODE_ENV || 'development';
var config = require('../knexfile.js')[environment];

module.exports = require('knex')(config);
</code></pre>

<p>Apply the migrations to both databases:</p>

<pre><code class="sh">$ knex migrate:latest --env development
$ knex migrate:latest --env test
</code></pre>

<h3>Knex Seeds</h3>

<p><a href="https://en.wikipedia.org/wiki/Database_seeding">Seeding</a> is simply the process of populating the database with initial data. Knex utilizes <a href="http://knexjs.org/#Seeds-CLI">seed files</a> for this.</p>

<p>Run the following in your terminal to create a seed for development:</p>

<pre><code class="sh">$ knex seed:make shows_seed --env development
</code></pre>

<p>This will generate a folder called &ldquo;seeds/development&rdquo; in the &ldquo;db&rdquo; directory of your project, and in that file there will be a boilerplate setup for inserting data into the database:</p>

<pre><code class="javascript">exports.seed = function(knex, Promise) {
  return Promise.join(
    // Deletes ALL existing entries
    knex('table_name').del(),

    // Inserts seed entries
    knex('table_name').insert({id: 1, colName: 'rowValue'}),
    knex('table_name').insert({id: 2, colName: 'rowValue2'}),
    knex('table_name').insert({id: 3, colName: 'rowValue3'})
  );
};
</code></pre>

<p>Let&rsquo;s change the file so we&rsquo;re inserting relevant data. Notice how there&rsquo;s also built-in promises so that the data will be seeded in the order that we specify:</p>

<pre><code class="javascript">exports.seed = function(knex, Promise) {
  return knex('shows').del() // Deletes ALL existing entries
    .then(function() { // Inserts seed entries one by one in series
      return knex('shows').insert({
        name: 'Suits',
        channel: 'USA Network',
        genre: 'Drama',
        rating: 3,
        explicit: false
      });
    }).then(function () {
      return knex('shows').insert({
        name: 'Game of Thrones',
        channel: 'HBO',
        genre: 'Fantasy',
        rating: 5,
        explicit: true
      });
    }).then(function () {
      return knex('shows').insert({
        name: 'South Park',
        channel: 'Comedy Central',
        genre: 'Comedy',
        rating: 4,
        explicit: true
      });
    }).then(function () {
      return knex('shows').insert({
        name: 'Mad Men',
        channel: 'AMC',
        genre: 'Drama',
        rating: 3,
        explicit: false
      });
    });
};
</code></pre>

<p>Since JavaScript is asynchronous, the order that data is inserted can sometimes change. We want to make sure that the data is in the same order each time we run our seed file(s).</p>

<p>Run the seed file:</p>

<pre><code class="sh">$ knex seed:run --env development
</code></pre>

<p>Before moving on, follow the same process for the test seed. Just use the same data as the development seed.</p>

<h3>Mocha/Chai Setup</h3>

<p>With the database set up with data in it, we can start setting up our tests. Start by installing <a href="http://mochajs.org/">Mocha</a> (test runner) and <a href="http://chaijs.com/">Chai</a> (<a href="https://en.wikipedia.org/wiki/Assertion_(software_development">assertion</a>) as well as <a href="https://github.com/chaijs/chai-http">ChaiHTTP</a> (HTTP request module for integration testing). Make sure to also install mocha globally, so that we can run tests from the command line.</p>

<pre><code class="sh">$ npm install mocha@2.4.5 -g
$ npm install mocha@2.4.5 chai@3.5.0 chai-http@2.0.1 --save-dev
</code></pre>

<p>By default, Mocha searches for tests with a &ldquo;test&rdquo; folder.</p>

<blockquote><p>This configuration can be changed with a <a href="https://mochajs.org/#mochaopts">mocha.opts</a> file</p></blockquote>

<p>Add a &ldquo;test&rdquo; folder to the root directory, and in that folder add a file called <em>routes.spec.js</em>. Then update <em>routes/index.js</em>:</p>

<pre><code class="javascript">var express = require('express');
var router = express.Router();


// *** GET all shows *** //
router.get('/shows', function(req, res, next) {
  res.send('send shows back');
});


module.exports = router;
</code></pre>

<p>Then within <em>app.js</em> update this line-</p>

<pre><code class="javascript">app.use('/', routes);
</code></pre>

<p>-to-</p>

<pre><code class="javascript">app.use('/api/v1', routes);
</code></pre>

<p>Now every single route in that file will be prefixed with &lsquo;/api/v1&rsquo; Try it out. Fire up the server, and navigate to <a href="http://localhost:3000/api/v1/shows">http://localhost:3000/api/v1shows</a>. You should see the string &lsquo;send shows back&rsquo; in the browser.</p>

<p>Finally, update this line in <em>app.js</em>-</p>

<pre><code class="javascript">app.use(logger('dev'));
</code></pre>

<p>-to-</p>

<pre><code class="javascript">if (process.env.NODE_ENV !== 'test') {
  app.use(logger('dev'));
}
</code></pre>

<p>This <a href="http://stackoverflow.com/a/22710649/1799408">prevents</a> application log messages from displaying in the stdout when the tests are ran, making it much easier to read the output.</p>

<p>And make sure the error handlers return JSON:</p>

<pre><code class="javascript">// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
  app.use(function(err, req, res, next) {
    res.status(err.status || 500);
    res.json({
      message: err.message,
      error: err
    });
  });
}

// production error handler
// no stacktraces leaked to user
app.use(function(err, req, res, next) {
  res.status(err.status || 500);
  res.json({
    message: err.message,
    error: {}
  });
});
</code></pre>

<h2>Developing via TDD</h2>

<p>The premise behind Test Driven Development (TDD) is that you write tests first that fail which you then make pass. This process is often referred to as <a href="https://github.com/mjhea0/flaskr-tdd#test-driven-development">Red/Green/Refactor</a>.</p>

<h3>Test Setup</h3>

<p>In our test file, we&rsquo;ll need to start by including the necessary requirements for testing:</p>

<pre><code class="javascript">process.env.NODE_ENV = 'test';

var chai = require('chai');
var should = chai.should();
var chaiHttp = require('chai-http');
var server = require('../app');



chai.use(chaiHttp);

describe('API Routes', function() {

});
</code></pre>

<p>The first line sets the <code>NODE_ENV</code> to <code>test</code> so that the correct Knex config is used from <em>knexfile.js</em>. The next line requires <code>chai</code>, the assertion module, giving us access to all the <code>chai</code> methods - like <code>should()</code>.</p>

<blockquote><p>By utilizing <code>should()</code> we are using the <a href="http://chaijs.com/guide/styles/#should">should</a> assertion style. This is a personal preference. You could also use <a href="http://chaijs.com/guide/styles/#expect">expect</a> or <a href="http://chaijs.com/guide/styles/#assert">assert</a>.</p></blockquote>

<p>Then we require <code>chai-http</code>. This module allows us make http requests from within our test file. Next, we link to our app so that we can test the request-response cycle. Finally, the <code>describe</code> block underneath the requirements is the wrapper for the tests. Keep in mind that you can nest <code>describe</code> <a href="http://samwize.com/2014/02/08/a-guide-to-mochas-describe-it-and-setup-hooks/">blocks</a> to better organize your test structure by grouping similar tests together.</p>

<h3>GET all shows</h3>

<h4>Red</h4>

<p>In the first test case, which is nested inside the first <code>describe</code> block, we want to get ALL shows in our database:</p>

<pre><code class="javascript">describe('GET /api/v1/shows', function() {
  it('should return all shows', function(done) {
    chai.request(server)
    .get('/api/v1/shows')
    .end(function(err, res) {
    res.should.have.status(200);
    res.should.be.json; // jshint ignore:line
    res.body.should.be.a('array');
    res.body.length.should.equal(4);
    res.body[0].should.have.property('name');
    res.body[0].name.should.equal('Suits');
    res.body[0].should.have.property('channel');
    res.body[0].channel.should.equal('USA Network');
    res.body[0].should.have.property('genre');
    res.body[0].genre.should.equal('Drama');
    res.body[0].should.have.property('rating');
    res.body[0].rating.should.equal(3);
    res.body[0].should.have.property('explicit');
    res.body[0].explicit.should.equal(false);
    done();
    });
  });
});
</code></pre>

<p>So, we have a <code>describe</code> block, and within that block, we have a single <code>it</code> statement. An <code>it</code> statement defines a specific test case. Here we hit the route &lsquo;/api/v1/shows&rsquo; with a GET request and test that the actual response is the same as the expected response.</p>

<p>Let&rsquo;s break this test down&hellip;</p>

<p>First, by removing the test conditions, we can look at the basic test structure:</p>

<pre><code class="javascript">it('should return all shows', function(done) {
  chai.request(server)
  .get('/api/v1/shows')
  .end(function(err, res) {
    done();
  });
});
</code></pre>

<p>Since this is an asynchronous test, we need some way of telling the callback function that the test is complete. This is where the <code>done()</code> callback method comes into play. Once called (or if a two second timer is exceeded), Mocha knows that the test is finished running, and it can move on to the next test.</p>

<p>Now let&rsquo;s look at the assertions:</p>

<pre><code class="javascript">res.should.have.status(200);
res.should.be.json; // jshint ignore:line
res.body.should.be.a('array');
res.body.length.should.equal(4);
res.body[0].should.have.property('name');
res.body[0].name.should.equal('Suits');
res.body[0].should.have.property('channel');
res.body[0].channel.should.equal('USA Network');
res.body[0].should.have.property('genre');
res.body[0].genre.should.equal('Drama');
res.body[0].should.have.property('rating');
res.body[0].rating.should.equal(3);
res.body[0].should.have.property('explicit');
res.body[0].explicit.should.equal(false);
</code></pre>

<p>The first thing we generally want to do, is test that the response has a status of 200. After that, these tests will change depending on what we return in the route handler. In this case, we are expecting that the content type is JSON and that the response body will be an array (of objects) and have a length equal to four (since there are four rows in the database). Finally, we are testing the keys and values within the first object of the array.</p>

<p>Try it out:</p>

<pre><code class="sh">$ mocha
</code></pre>

<p>If all went well you should see this:</p>

<pre><code class="sh">  API Routes
    GET /api/v1/shows
      1) should return all shows


  0 passing (59ms)
  1 failing

  1) API Routes GET /api/v1/shows should return all shows:
     Uncaught AssertionError: expected 'text/html; charset=utf-8'
     to include 'application/json'
</code></pre>

<p>Essentially, the second assertion - <code>res.should.be.json;</code> - failed since we are sending plain text back. This is good! Remember: Red-Green-Refactor!</p>

<p>We just need to update the route to get the test to pass.</p>

<h4>Green</h4>

<p>Before updating the route, let&rsquo;s create a queries module for handling, well, the database queries. Create a new file called <em>queries.js</em> with the &ldquo;db&rdquo; folder, and add the following code:</p>

<pre><code class="javascript">var knex = require('./knex.js');

function Shows() {
  return knex('shows');
}

// *** queries *** //

function getAll() {
  return Shows().select();
}


module.exports = {
  getAll: getAll
};
</code></pre>

<p>Here, we made a reference to our database via the Knex config file, added a helper function for simplifying each individual query, and finally queried the database to get ALL shows.</p>

<p>Update the route:</p>

<pre><code class="javascript">var express = require('express');
var router = express.Router();

var queries = require('../db/queries');


// *** GET all shows *** //
router.get('/shows', function(req, res, next) {
  queries.getAll()
  .then(function(shows) {
    res.status(200).json(shows);
  })
  .catch(function(error) {
    next(error);
  });
});


module.exports = router;
</code></pre>

<p>Run mocha again and see what happens:</p>

<pre><code class="sh">API Routes
  GET /api/v1/shows
    ✓ should return all shows (128ms)


1 passing (164ms)
</code></pre>

<p>Awesome! Just don&rsquo;t forget the last step - refactor.</p>

<h4>Refactor</h4>

<p>What&rsquo;s happening in the test database?</p>

<pre><code class="sh"># psql
psql (9.4.5)
Type "help" for help.

# \c mocha_chai_tv_shows_test
You are now connected to database "mocha_chai_tv_shows".
mocha_chai_tv_shows=# SELECT * FROM shows;
 id |      name       |    channel     |  genre  | rating | explicit
----+-----------------+----------------+---------+--------+----------
  1 | Suits           | USA Network    | Drama   |      3 | f
  2 | Game of Thrones | HBO            | Fantasy |      5 | t
  3 | South Park      | Comedy Central | Comedy  |      4 | t
  4 | Mad Men         | AMC            | Drama   |      3 | f
(4 rows)

#\q
</code></pre>

<p>Since we seeded the database earlier, there&rsquo;s data already in there, which could affect other tests (especially when rows are added, changed, and/or dropped). In the test, we are asserting that the length of the array is four. Well, if we add an item then that&rsquo;s going to change the length, and that first test will fail.</p>

<p>Tests should be isolated from each other. So, we really should rollback the migrations before and after each test is ran, and then apply the migrations and re-seed the database before the next test is ran.</p>

<p>This is where <code>beforeEach</code> and <code>afterEach</code> come into play:</p>

<pre><code class="javascript">process.env.NODE_ENV = 'test';

var chai = require('chai');
var chaiHttp = require('chai-http');
var server = require('../app');
var knex = require('../db/knex');

var should = chai.should();

chai.use(chaiHttp);

describe('API Routes', function() {

  beforeEach(function(done) {
    knex.migrate.rollback()
    .then(function() {
      knex.migrate.latest()
      .then(function() {
        return knex.seed.run()
        .then(function() {
          done();
        });
      });
    });
  });

  afterEach(function(done) {
    knex.migrate.rollback()
    .then(function() {
      done();
    });
  });

  describe('Get all shows', function() {
    it('should get all shows', function(done) {
      chai.request(server)
      .get('/api/v1/shows')
      .end(function(err, res) {
        res.should.have.status(200);
        res.should.be.json; // jshint ignore:line
        res.body.should.be.a('array');
        res.body.length.should.equal(4);
        res.body[0].should.have.property('name');
        res.body[0].name.should.equal('Suits');
        res.body[0].should.have.property('channel');
        res.body[0].channel.should.equal('USA Network');
        res.body[0].should.have.property('genre');
        res.body[0].genre.should.equal('Drama');
        res.body[0].should.have.property('rating');
        res.body[0].rating.should.equal(3);
        res.body[0].should.have.property('explicit');
        res.body[0].explicit.should.equal(false);
        done();
      });
    });
  });

});
</code></pre>

<p>Now, the migrations will run and the database will be re-seeded before each nested <code>describe</code> block, and the migrations will be rolled back after each block (which will also drop the data).</p>

<blockquote><p>Why rollback before each test? If any errors occur during a test, it won&rsquo;t reach the <code>afterEach</code> block. So we want to make sure that if an error occurs we still rollback the database.</p></blockquote>

<p>Run the tests again:</p>

<pre><code class="sh">API Routes
  GET /api/v1/shows
    ✓ should return all shows (52ms)


1 passing (325ms)
</code></pre>

<p>1 down, 4 to go!!!</p>

<blockquote><p>Did you notice how the overall time is slightly slower? 325ms vs 164ms. This is because of the <code>beforeEach</code> and <code>afterEach</code>. Think about what&rsquo;s happening, and why this would slow down the tests.</p></blockquote>

<h3>GET single show</h3>

<p>We have our route and test built to get All shows, so the next step is to just get one show back.</p>

<h4>Red</h4>

<p>Based on our test seed, the first show that should (you never know for certain with async code) is <code>Suits</code>:</p>

<pre><code class="javascript">{
  name: 'Suits',
  channel: 'USA Network',
  genre: 'Drama',
  rating: 3,
  explicit: false
}
</code></pre>

<p>We can write out a test for a new route that will return just a single show and the meta information about it. Remember our last test? It returned an array of objects. This time it should be a <em>single</em> object since we will be searching for a <em>single</em> item in the database.</p>

<pre><code class="javascript">describe('GET /api/v1/shows/:id', function() {
  it('should return a single show', function(done) {
    chai.request(server)
    .get('/api/v1/shows/1')
    .end(function(err, res) {
      res.should.have.status(200);
      res.should.be.json; // jshint ignore:line
      res.body.should.be.a('object');
      res.body.should.have.property('name');
      res.body.name.should.equal('Suits');
      res.body.should.have.property('channel');
      res.body.channel.should.equal('USA Network');
      res.body.should.have.property('genre');
      res.body.genre.should.equal('Drama');
      res.body.should.have.property('rating');
      res.body.rating.should.equal(3);
      res.body.should.have.property('explicit');
      res.body.explicit.should.equal(false);
      done();
    });
  });
});
</code></pre>

<p>This is very similar to the previous test. We&rsquo;re still testing for a status code of 200, and the response should be JSON. This time, we expect that <code>res.body</code> is an object. Each of the properties afterwards should be the properties of the item with id &lsquo;1&rsquo; in the database. So now if we run the tests, the first assertion should fail because we haven&rsquo;t written our route yet:</p>

<pre><code class="sh">API Routes
  GET /api/v1/shows
    ✓ should return all shows
  GET /api/v1/shows/:id
    1) should return a single show


1 passing (383ms)
1 failing

1) API Routes GET /api/v1/shows/:id should return a single show:
   Uncaught AssertionError: expected { Object (domain, _events, ...) }
   to have status code 200 but got 404
</code></pre>

<h4>Green</h4>

<p>Add the query to <em>queries.js</em>, making sure to update <code>module.exports</code>:</p>

<pre><code class="javascript">function getSingle(showID) {
  return Shows().where('id', parseInt(showID)).first();
}


module.exports = {
  getAll: getAll,
  getSingle: getSingle
};
</code></pre>

<p>Then build out the route:</p>

<pre><code class="javascript">// *** GET single show *** //
router.get('/shows/:id', function(req, res, next) {
  queries.getSingle(req.params.id)
  .then(function(show) {
    res.status(200).json(show);
  })
  .catch(function(error) {
    next(error);
  });
});
</code></pre>

<p>Now run mocha, and let&rsquo;s see if that worked:</p>

<pre><code class="sh">API Routes
  GET /api/v1/shows
    ✓ should return all shows (54ms)
  GET /api/v1/shows/:id
    ✓ should return a single show


2 passing (499ms)
</code></pre>

<p>Two routes down, two tests passing.</p>

<h3>POST</h3>

<p>We now want to add an item to our database.</p>

<h4>Red</h4>

<p>For time&rsquo;s sake, write the test assuming you will get a JSON object back that contains the data added to the database:</p>

<pre><code class="javascript">describe('POST /api/v1/shows', function() {
  it('should add a show', function(done) {
    chai.request(server)
    .post('/api/v1/shows')
    .send({
      name: 'Family Guy',
      channel : 'Fox',
      genre: 'Comedy',
      rating: 4,
      explicit: true
    })
    .end(function(err, res) {
      res.should.have.status(200);
      res.should.be.json; // jshint ignore:line
      res.body.should.be.a('object');
      res.body.should.have.property('name');
      res.body.name.should.equal('Family Guy');
      res.body.should.have.property('channel');
      res.body.channel.should.equal('Fox');
      res.body.should.have.property('genre');
      res.body.genre.should.equal('Comedy');
      res.body.should.have.property('rating');
      res.body.rating.should.equal(4);
      res.body.should.have.property('explicit');
      res.body.explicit.should.equal(true);
      done();
    });
  });
  });
</code></pre>

<p>You can see here that our test block is slightly different than the previous two since we need to send information with the request to replicate how a client might send information to the server.</p>

<h4>Green</h4>

<p>With the test written and failing (did you remember to run the tests?), we can write the query and add the route (notice the pattern yet?).</p>

<p>Query:</p>

<pre><code class="javascript">function add() {
  return Shows().insert(show, 'id');
}
</code></pre>

<p>Route:</p>

<pre><code class="javascript">// *** add show *** //
router.post('/shows', function(req, res, next) {
  queries.add(req.body)
  .then(function(showID) {
    return queries.getSingle(showID);
  })
  .then(function(show) {
    res.status(200).json(show);
  })
  .catch(function(error) {
    next(error);
  });
});
</code></pre>

<p><code>.insert()</code> returns an array containing the unique ID of the newly added item, so in order to return the actual data, we utilized the <code>getSingle()</code> query. This also ensures that the data has been inserted into the database correctly.</p>

<p>Do the tests pass?</p>

<pre><code class="sh">API Routes
  GET /api/v1/shows
    ✓ should return all shows (50ms)
  GET /api/v1/shows/:id
    ✓ should return a single show
  POST /api/v1/shows
    ✓ should add a show (71ms)


3 passing (791ms)
</code></pre>

<p>Excellent. Just two routes left to go.</p>

<h3>PUT</h3>

<p>We need to test the edit route.</p>

<h4>Red</h4>

<p>Similar to our POST route we will need to send data to the server. In this case, we&rsquo;ll utilize the ID of an existing show in the database and send along an object with the updated fields. Then we&rsquo;ll assert that the show has been updated correctly.</p>

<pre><code class="javascript">describe('PUT /api/v1/shows/:id', function() {
  it('should update a show', function(done) {
    chai.request(server)
    .put('/api/v1/shows/1')
    .send({
      rating: 4,
      explicit: true
    })
    .end(function(err, res) {
      res.should.have.status(200);
      res.should.be.json; // jshint ignore:line
      res.body.should.be.a('object');
      res.body.should.have.property('name');
      res.body.name.should.equal('Suits');
      res.body.should.have.property('channel');
      res.body.channel.should.equal('USA Network');
      res.body.should.have.property('genre');
      res.body.genre.should.equal('Drama');
      res.body.should.have.property('rating');
      res.body.rating.should.equal(4);
      res.body.should.have.property('explicit');
      res.body.explicit.should.equal(true);
      done();
    });
  });
});
</code></pre>

<p>So here we are stating that the response body should contain the updated object from the database.</p>

<h4>Green</h4>

<p>You know the drill - Start with the query:</p>

<pre><code class="javascript">function update(showID, updates) {
  return Shows().where('id', parseInt(showID)).update(updates);
}
</code></pre>

<p>Then update the route:</p>

<pre><code class="javascript">// *** update show *** //
router.put('/shows/:id', function(req, res, next) {
  queries.update(req.params.id, req.body)
  .then(function() {
    return queries.getSingle(req.params.id);
  })
  .then(function(show) {
    res.status(200).json(show);
  })
  .catch(function(error) {
    next(error);
  });
});
</code></pre>

<p>Here, we again make two calls to the database. Once we&rsquo;ve updated the item, we then nest another query to get that same item - which we then check to ensure that it has in fact been updated correctly.</p>

<p>The tests should pass.</p>

<h4>Refactor</h4>

<p>What happens if we try to change the ID? Update the test:</p>

<pre><code class="javascript">describe('PUT /api/v1/shows/:id', function() {
  it('should update a show', function(done) {
    chai.request(server)
    .put('/api/v1/shows/1')
    .send({
      id: 20,
      rating: 4,
      explicit: true
    })
    .end(function(err, res) {
      res.should.have.status(200);
      res.should.be.json; // jshint ignore:line
      res.body.should.be.a('object');
      res.body.should.have.property('name');
      res.body.name.should.equal('Suits');
      res.body.should.have.property('channel');
      res.body.channel.should.equal('USA Network');
      res.body.should.have.property('genre');
      res.body.genre.should.equal('Drama');
      res.body.should.have.property('rating');
      res.body.rating.should.equal(4);
      res.body.should.have.property('explicit');
      res.body.explicit.should.equal(true);
      done();
    });
  });
});
</code></pre>

<p>Run the tests now and they should fail:</p>

<pre><code class="sh">API Routes
  GET /api/v1/shows
    ✓ should return all shows (43ms)
  GET /api/v1/shows/:id
    ✓ should return a single show
  POST /api/v1/shows
    ✓ should add a show (50ms)
  PUT /api/v1/shows/:id
    1) should update a show


3 passing (804ms)
1 failing

1) API Routes PUT /api/v1/shows/:id should update a show:
   Uncaught AssertionError: expected '' to be an object
</code></pre>

<p>Why? Because the updated ID of the test does not equal the ID passed in as a query parameter. What does this all mean? The unique ID should never change (unless it&rsquo;s removed altogether).</p>

<pre><code class="javascript">// *** update show *** //
router.put('/shows/:id', function(req, res, next) {
  if(req.body.hasOwnProperty('id')) {
    return res.status(422).json({
      error: 'You cannot update the id field'
    });
  }
  queries.update(req.params.id, req.body)
  .then(function() {
    return queries.getSingle(req.params.id);
  })
  .then(function(show) {
    res.status(200).json(show);
  })
  .catch(function(error) {
    next(error);
  });
});
</code></pre>

<p>Now, let&rsquo;s revert the changes in the test, by removing <code>id: 20,</code>,  and add a new test:</p>

<pre><code class="javascript">describe('PUT /api/v1/shows/:id', function() {
  it('should update a show', function(done) {
    chai.request(server)
    .put('/api/v1/shows/1')
    .send({
      rating: 4,
      explicit: true
    })
    .end(function(err, res) {
      res.should.have.status(200);
      res.should.be.json; // jshint ignore:line
      res.body.should.be.a('object');
      res.body.should.have.property('name');
      res.body.name.should.equal('Suits');
      res.body.should.have.property('channel');
      res.body.channel.should.equal('USA Network');
      res.body.should.have.property('genre');
      res.body.genre.should.equal('Drama');
      res.body.should.have.property('rating');
      res.body.rating.should.equal(4);
      res.body.should.have.property('explicit');
      res.body.explicit.should.equal(true);
      done();
    });
  });
  it('should NOT update a show if the id field is part of the request', function(done) {
    chai.request(server)
    .put('/api/v1/shows/1')
    .send({
      id: 20,
      rating: 4,
      explicit: true
    })
    .end(function(err, res) {
      res.should.have.status(422);
      res.should.be.json; // jshint ignore:line
      res.body.should.be.a('object');
      res.body.should.have.property('error');
      res.body.error.should.equal('You cannot update the id field');
      done();
    });
  });
});
</code></pre>

<p>Run the tests:</p>

<pre><code class="sh">API Routes
  GET /api/v1/shows
    ✓ should return all shows (49ms)
  GET /api/v1/shows/:id
    ✓ should return a single show
  POST /api/v1/shows
    ✓ should add a show (51ms)
  PUT /api/v1/shows/:id
    ✓ should update a show
    ✓ should NOT update a show if the id field is part of the request
</code></pre>

<p>Boom!</p>

<h3>DELETE</h3>

<p>Now on to the final test - the delete.</p>

<h4>Red</h4>

<p>Again, let&rsquo;s use the ID of the first item in our database as the starting point for the test:</p>

<pre><code class="javascript">describe('DELETE /api/v1/shows/:id', function() {
  it('should delete a show', function(done) {
    chai.request(server)
    .delete('/api/v1/shows/1')
    .end(function(error, response) {
      response.should.have.status(200);
      response.should.be.json; // jshint ignore:line
      response.body.should.be.a('object');
      response.body.should.have.property('name');
      response.body.name.should.equal('Suits');
      response.body.should.have.property('channel');
      response.body.channel.should.equal('USA Network');
      response.body.should.have.property('genre');
      response.body.genre.should.equal('Drama');
      response.body.should.have.property('rating');
      response.body.rating.should.equal(3);
      response.body.should.have.property('explicit');
      response.body.explicit.should.equal(false);
      chai.request(server)
      .get('/api/v1/shows')
      .end(function(err, res) {
        res.should.have.status(200);
        res.should.be.json; // jshint ignore:line
        res.body.should.be.a('array');
        res.body.length.should.equal(3);
        res.body[0].should.have.property('name');
        res.body[0].name.should.equal('Game of Thrones');
        res.body[0].should.have.property('channel');
        res.body[0].channel.should.equal('HBO');
        res.body[0].should.have.property('genre');
        res.body[0].genre.should.equal('Fantasy');
        res.body[0].should.have.property('rating');
        res.body[0].rating.should.equal(5);
        res.body[0].should.have.property('explicit');
        res.body[0].explicit.should.equal(true);
        done();
      });
    });
  });
});
</code></pre>

<p>The test ensure that the deleted show is returned and that the database no longer contains the show.</p>

<h4>Green</h4>

<p>Query:</p>

<pre><code class="javascript">function deleteItem(showID) {
  return Shows().where('id', parseInt(showID)).del();
}
</code></pre>

<p>Route:</p>

<pre><code class="javascript">// *** delete show *** //
router.delete('/shows/:id', function(req, res, next) {
  queries.getSingle(req.params.id)
  .then(function(show) {
    queries.deleteItem(req.params.id)
    .then(function() {
      res.status(200).json(show);
    })
    .catch(function(error) {
      next(error);
    });
  }).catch(function(error) {
    next(error);
  });
});
</code></pre>

<p>The Knex <code>delete()</code> function returns a number indicating the number of rows in the database that have been affected, so to return the deleted object, we must query for it first.</p>

<p>Let&rsquo;s run those tests!!</p>

<pre><code class="sh">API Routes
  GET /api/v1/shows
    ✓ should return all shows (69ms)
  GET /api/v1/shows/:id
    ✓ should return a single show
  POST /api/v1/shows
    ✓ should add a show (54ms)
  PUT /api/v1/shows/:id
    ✓ should update a show
    ✓ should NOT update a show if the id field is part of the request
  DELETE /api/v1/shows/:id
    ✓ should delete a show


6 passing (1s)
</code></pre>

<p>6 tests written. 5 routes built. All tests passing!</p>

<h2>Conclusion</h2>

<p>So there you have it: A test-first approach to developing a RESTful API. Are we done? Not quite since we are not handling or testing for all possible errors.</p>

<p>For example, what would happen if we tried to POST an item without all the required fields? Or if we tried to delete an item that isn&rsquo;t in the database? Sure the <code>catch()</code> methods will handle these, but they are simply passing the request to the built-in error handlers. We should handle these better in the routes and throw back appropriate error messages and status codes.</p>

<p>Try this out on your own. Be sure to grab the code from the <a href="https://github.com/mjhea0/mocha-chai-knex">repository</a>. Cheers!</p>

<p><br></p>

<p style="font-size: 14px;">
  <em>Edits made by <a href="https://www.linkedin.com/in/bbouley">Bradley Bouley</a>. Thank you!</em>
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing a RESTful API With Node and Postgres]]></title>
    <link href="http://mherman.org/blog/2016/03/13/designing-a-restful-api-with-node-and-postgres/"/>
    <updated>2016-03-13T07:56:00-06:00</updated>
    <id>http://mherman.org/blog/2016/03/13/designing-a-restful-api-with-node-and-postgres</id>
    <content type="html"><![CDATA[<p><strong>In this tutorial we&rsquo;ll create a RESTful web service with JavaScript, Node, Express, Postgres, and pg-promise.</strong></p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/node-restful-api.png" style="max-width: 100%; border:0; box-shadow: none;" alt="node restful api">
</div>


<p><br><hr></p>

<p>Our app will include the following endpoints:</p>

<table style="font-size:18px;border-spacing:12px 0px;border-collapse:separate;border:1px solid black;">
<thead>
<tr>
<th style="text-align:center"><strong>URL</strong></th>
<th style="text-align:center"><strong>HTTP Verb</strong></th>
<th style="text-align:center"><strong>Action</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>/api/puppies</td>
<td>GET</td>
<td>Return ALL puppies</td>
</tr>
<tr>
<td>/api/puppies/:id</td>
<td>GET</td>
<td>Return a SINGLE puppy</td>
</tr>
<tr>
<td>/api/puppies</td>
<td>POST</td>
<td>Add a puppy</td>
</tr>
<tr>
<td>/api/puppies/:id</td>
<td>PUT</td>
<td>Update a puppy</td>
</tr>
<tr>
<td>/api/puppies/:id</td>
<td>DELETE</td>
<td>Delete a puppy</td>
</tr>
</tbody>
</table>


<p><br></p>

<blockquote><p>This tutorial uses the following tools and technologies - Node.js v<a href="https://nodejs.org/en/blog/release/v4.3.1/">4.3.1</a>, express-generator v<a href="https://github.com/expressjs/generator/releases/tag/v4.13.1">4.13.1</a>, pg-promise v<a href="https://github.com/vitaly-t/pg-promise/releases/tag/v.3.2.3">3.2.3</a>, PostgreSQL v<a href="http://www.postgresql.org/docs/9.4/static/release.html">9.4</a>, and Bluebird v<a href="http://bluebirdjs.com">3.3.4</a></p></blockquote>

<h2>Project setup</h2>

<p>Install the Express Generator (if necessary):</p>

<pre><code class="sh">$ npm install express-generator@4.13.1 -g
</code></pre>

<p>Create a new project and install the required dependencies:</p>

<pre><code class="sh">$ express node-postgres-promises
$ cd node-postgres-promises
$ npm install
</code></pre>

<p>Test!</p>

<pre><code class="sh">$ npm start
</code></pre>

<p>Navigate to <a href="http://localhost:3000">http://localhost:3000</a> in your browser, and you should see the familiar &ldquo;Welcome to Express&rdquo; text. Kill the server when done. Now let&rsquo;s set up the Postgres bindings via <a href="https://www.npmjs.com/package/pg-promise">pg-promise</a>&hellip;</p>

<p>Install <code>pg-promise</code></p>

<pre><code class="sh">$ npm install pg-promise@3.2.3 --save
</code></pre>

<p>Why <code>pg-promise</code> instead of <code>pg</code>? Put simply, pg-promise abstracts away much of the difficult, low-level connection management, allowing you to focus on the business logic. Further, the library includes a powerful <a href="https://www.npmjs.com/package/pg-promise#queries-and-parameters">query formatting engine</a> and support for <a href="https://www.npmjs.com/package/pg-promise#transactions">automated transactions</a>.</p>

<p>Finally, create a new file in the project root called <em>queries.js</em>:</p>

<pre><code class="javascript">var promise = require('bluebird');

var options = {
  // Initialization Options
  promiseLib: promise
};

var pgp = require('pg-promise')(options);
var connectionString = 'postgres://localhost:5432/puppies';
var db = pgp(connectionString);

// add query functions

module.exports = {
  getAllPuppies: getAllPuppies,
  getSinglePuppy: getSinglePuppy,
  createPuppy: createPuppy,
  updatePuppy: updatePuppy,
  removePuppy: removePuppy
};
</code></pre>

<p>Here, we created an instance of <code>pg-promise</code> and assigned it to a variable, <code>pgp</code>.</p>

<p>Did you notice that we passed an object, <code>options</code>, during the initialization process? This is required, even if you do not pass any properties/<a href="https://www.npmjs.com/package/pg-promise#initialization-options">initialization options</a> to the object. In this case, we <a href="https://www.npmjs.com/package/pg-promise#promiselib">overrode</a> pg-promise&rsquo;s default promise library - ES6 Promises - with <a href="http://bluebirdjs.com">Bluebird</a> by setting the <code>promiseLib</code> property in the <code>options</code> object.</p>

<blockquote><p>Why Bluebird? It&rsquo;s loaded with features and reputed to be <a href="http://programmers.stackexchange.com/questions/278778/why-are-native-es6-promises-slower-and-more-memory-intensive-than-bluebird">faster</a> than ES6 Promises.</p></blockquote>

<p>Don&rsquo;t forget to install Bluebird:</p>

<pre><code class="sh">$ npm install bluebird@3.3.4 --save
</code></pre>

<p>Next, we defined a connection string, and then passed it to the pg-promise instance to create a global connection instance.</p>

<p>Done!</p>

<h2>Postgres setup</h2>

<p>Create a new file also in the root called <em>puppies.sql</em> and then add the following code:</p>

<pre><code class="sql">DROP DATABASE IF EXISTS puppies;
CREATE DATABASE puppies;

\c puppies;

CREATE TABLE pups (
  ID SERIAL PRIMARY KEY,
  name VARCHAR,
  breed VARCHAR,
  age INTEGER,
  sex VARCHAR
);

INSERT INTO pups (name, breed, age, sex)
  VALUES ('Tyler', 'Retrieved', 3, 'M');
</code></pre>

<p>Run the file to create the database, apply the schema, and add one row to the newly created database:</p>

<pre><code class="sh">$ psql -f puppies.sql

DROP DATABASE
CREATE DATABASE
CREATE TABLE
INSERT 0 1
</code></pre>

<h2>Routes</h2>

<p>Now we can set up the route handlers in <em>index.js</em>:</p>

<pre><code class="javascript">var express = require('express');
var router = express.Router();

var db = require('../queries');


router.get('/api/puppies', db.getAllPuppies);
router.get('/api/puppies/:id', db.getSinglePuppy);
router.post('/api/puppies', db.createPuppy);
router.put('/api/puppies/:id', db.updatePuppy);
router.delete('/api/puppies/:id', db.removePuppy);


module.exports = router;
</code></pre>

<h2>Queries</h2>

<p>Next, let&rsquo;s add the SQL queries to the <em>queries.js</em> file&hellip;</p>

<h3>GET All Puppies</h3>

<pre><code class="javascript">function getAllPuppies(req, res, next) {
  db.any('select * from pups')
    .then(function (data) {
      res.status(200)
        .json({
          status: 'success',
          data: data,
          message: 'Retrieved ALL puppies'
        });
    })
    .catch(function (err) {
      return next(err);
    });
}
</code></pre>

<p>In the above code, we utilized the <code>any</code> <a href="https://www.npmjs.com/package/pg-promise#query-result-mask">Query Result Mask</a> to query the database, which returns a promise object. This method is used to indicate that we are expecting any number of results back. Success and failures are then handled by <code>.then()</code> and <code>.catch()</code>.</p>

<p>Besides, <code>any</code>, you can use the following <a href="https://www.npmjs.com/package/pg-promise#query-result-mask">Query Result Masks</a> (just to name a few):</p>

<ul>
<li><code>one</code> - a single row is expected</li>
<li><code>many</code> - one or more rows are expected</li>
<li><code>none</code> - no rows are expected</li>
<li><code>result</code> - passes the original object when resolved (we&rsquo;ll look at an example of this shortly)</li>
</ul>


<p>Test the request out in the browser - <a href="http://localhost:3000/api/puppies">http://localhost:3000/api/puppies</a>:</p>

<pre><code class="json">{
  status: "success",
  data: [
    {
      id: 1,
      name: "Tyler",
      breed: "Shih-tzu",
      age: 3,
      sex: "M"
    }
  ],
  message: "Retrieved ALL puppies"
}
</code></pre>

<h3>GET Single Puppy</h3>

<pre><code class="javascript">function getSinglePuppy(req, res, next) {
  var pupID = parseInt(req.params.id);
  db.one('select * from pups where id = $1', pupID)
    .then(function (data) {
      res.status(200)
        .json({
          status: 'success',
          data: data,
          message: 'Retrieved ONE puppy'
        });
    })
    .catch(function (err) {
      return next(err);
    });
}
</code></pre>

<p>Again, test in the browser: <a href="http://localhost:3000/api/puppies/1">http://localhost:3000/api/puppies/1</a></p>

<pre><code class="json">{
  status: "success",
  data: {
    id: 1,
    name: "Tyler",
    breed: "Shih-tzu",
    age: 3,
    sex: "M"
  },
  message: "Retrieved ONE puppy"
}
</code></pre>

<h3>POST</h3>

<pre><code class="javascript">function createPuppy(req, res, next) {
  req.body.age = parseInt(req.body.age);
  db.none('insert into pups(name, breed, age, sex)' +
      'values(${name}, ${breed}, ${age}, ${sex})',
    req.body)
    .then(function () {
      res.status(200)
        .json({
          status: 'success',
          message: 'Inserted one puppy'
        });
    })
    .catch(function (err) {
      return next(err);
    });
}
</code></pre>

<p>Test with curl in a new terminal window:</p>

<pre><code class="sh">$ curl --data "name=Whisky&amp;breed=annoying&amp;age=3&amp;sex=f" \
http://127.0.0.1:3000/api/puppies
</code></pre>

<p>You should see:</p>

<pre><code class="sh">{
  "status": "success",
  "message": "Inserted one puppy"
}
</code></pre>

<p>Double check the GET ALL route in your browser to ensure that the new puppy is now part of the collection.</p>

<h3>PUT</h3>

<pre><code class="javascript">function updatePuppy(req, res, next) {
  db.none('update pups set name=$1, breed=$2, age=$3, sex=$4 where id=$5',
    [req.body.name, req.body.breed, parseInt(req.body.age),
      req.body.sex, parseInt(req.params.id)])
    .then(function () {
      res.status(200)
        .json({
          status: 'success',
          message: 'Updated puppy'
        });
    })
    .catch(function (err) {
      return next(err);
    });
}
</code></pre>

<p>Test!</p>

<pre><code class="sh">$ curl -X PUT --data "name=Hunter&amp;breed=annoying&amp;age=33&amp;sex=m" \
http://127.0.0.1:3000/api/puppies/1
</code></pre>

<h3>Delete</h3>

<pre><code class="javascript">function removePuppy(req, res, next) {
  var pupID = parseInt(req.params.id);
  db.result('delete from pups where id = $1', pupID)
    .then(function (result) {
      /* jshint ignore:start */
      res.status(200)
        .json({
          status: 'success',
          message: `Removed ${result.rowCount} puppy`
        });
      /* jshint ignore:end */
    })
    .catch(function (err) {
      return next(err);
    });
}
</code></pre>

<p>So, we used the <code>result</code> <a href="https://www.npmjs.com/package/pg-promise#query-result-mask">Query Result Mask</a>, in order to get the number of records affected by the query.</p>

<pre><code class="sh">$ curl -X DELETE http://127.0.0.1:3000/api/puppies/1
</code></pre>

<p>Result:</p>

<pre><code class="sh">{
  "status": "success",
  "message": "Removed 1 puppy"
}
</code></pre>

<h2>Error Handling</h2>

<p>Update the error handlers in <em>app.js</em> to serve up JSON:</p>

<pre><code class="javascript">// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
  app.use(function(err, req, res, next) {
    res.status( err.code || 500 )
    .json({
      status: 'error',
      message: err
    });
  });
}

// production error handler
// no stacktraces leaked to user
app.use(function(err, req, res, next) {
  res.status(err.status || 500)
  .json({
    status: 'error',
    message: err.message
  });
});
</code></pre>

<h2>Conclusion</h2>

<p>We now have a basic RESTful API built with Node, Express, and pg-promise. Be sure to comment below if you have any questions.</p>

<p>Grab the code from the <a href="https://github.com/mjhea0/node-postgres-promises">repo</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node, Postgres, and Sequelize]]></title>
    <link href="http://mherman.org/blog/2015/10/22/node-postgres-sequelize/"/>
    <updated>2015-10-22T10:52:00-06:00</updated>
    <id>http://mherman.org/blog/2015/10/22/node-postgres-sequelize</id>
    <content type="html"><![CDATA[<p><strong>Let&rsquo;s build a CRUD app with Node (v4.1.1), Express (v4.13.1), Sequelize (v3.12.2), and PostgreSQL (9.4.4).</strong></p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/node-sequelize.png" style="max-width: 100%; border:0;" alt="node sequelize">
</div>


<p><strong>Updates</strong>:
  - <em>November 1st, 2015</em> - Added Database Migrations</p>

<blockquote><p>This a follow-up to <a href="http://mherman.org/blog/2015/02/12/postgresql-and-nodejs/#.ViVUDxNViko">PostgreSQL and NodeJS</a>.</p></blockquote>

<h2>Getting Started</h2>

<p>Grab the initial boilerplate and install the dependencies:</p>

<pre><code class="sh">$ git clone git@github.com:mjhea0/node-postgres-sequelize.git
$ git checkout tags/v1
$ npm install
</code></pre>

<p>Now run a quick sanity check:</p>

<pre><code class="sh">$ gulp
</code></pre>

<p>If all went well, a new browser window should have opened to <a href="http://localhost:5000/">http://localhost:5000/</a> and you should see the &ldquo;Welcome to Express.&rdquo; text.</p>

<h2>Sequelize</h2>

<p>With Postgres listening on port 5432, we can make a connection to it using the <a href="http://docs.sequelizejs.com/en/latest/">Sequelize</a> library, <em>an Object Relational Mapper (ORM), written in JavaScript, which supports MySQL, PostgreSQL, SQLite, and MariaDB</em>.</p>

<blockquote><p>Need to set up Postgres? On a Mac? Check out <a href="http://postgresapp.com/">Postgres.app</a>.</p></blockquote>

<p>Install Sequelize, <a href="https://www.npmjs.com/package/pg">pg</a> (for making the database connection), and <a href="https://www.npmjs.com/package/pg-hstore">pg-hstore</a> (for serializing and deserializing JSON into the <a href="http://www.postgresql.org/docs/9.0/static/hstore.html">Postgres hstore key/value pair format</a>):</p>

<pre><code class="sh">$ npm install sequelize@3.12.2 pg@4.4.3 pg-hstore@2.3.2 --save
</code></pre>

<h2>Migrations</h2>

<p>The <a href="https://github.com/sequelize/cli">Sequelize CLI</a> is used to bootstrap a new project and handle <a href="https://en.wikipedia.org/wiki/Schema_migration">database migrations</a> directly from the terminal.</p>

<blockquote><p>Read more about the Sequelize CLI from the official <a href="http://docs.sequelizejs.com/en/latest/docs/migrations/">documentation</a>.</p></blockquote>

<h3>Init</h3>

<p>Start by installing the package:</p>

<pre><code class="sh">$ npm install sequelize-cli@2.1.0 --save
</code></pre>

<p>Next, create a config file called <em>.sequelizerc</em> in your project root to specify the paths to specific files required by Sequelize:</p>

<pre><code class="javascript">var path = require('path');

module.exports = {
  'config': path.resolve('./server', 'config.json'),
  'migrations-path': path.resolve('./server', 'migrations'),
  'models-path': path.resolve('./server', 'models'),
  'seeders-path': path.resolve('./server', 'seeders')
}
</code></pre>

<p>Now, run the init command to create the files (<em>config.json</em>) and folders (&ldquo;migrations&rdquo;, &ldquo;models&rdquo;, and &ldquo;seeders&rdquo;):</p>

<pre><code class="sh">$ node_modules/.bin/sequelize init
</code></pre>

<p>Take a look at the <em>index.js</em> file within the &ldquo;models&rdquo; directory:</p>

<pre><code class="javascript">'use strict';

var fs        = require('fs');
var path      = require('path');
var Sequelize = require('sequelize');
var basename  = path.basename(module.filename);
var env       = process.env.NODE_ENV || 'development';
var config    = require(__dirname + '/../config.json')[env];
var db        = {};

if (config.use_env_variable) {
  var sequelize = new Sequelize(process.env[config.use_env_variable]);
} else {
  var sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(function(file) {
    return (file.indexOf('.') !== 0) &amp;&amp; (file !== basename);
  })
  .forEach(function(file) {
    if (file.slice(-3) !== '.js') return;
    var model = sequelize['import'](path.join(__dirname, file));
    db[model.name] = model;
  });

Object.keys(db).forEach(function(modelName) {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
</code></pre>

<p>Here, we establish a connection to the database, grab all the model files from the current directory, add them to the <code>db</code> object, and apply any relations between each model (if any).</p>

<h3>Config</h3>

<p>Be sure to also update the <em>config.js</em> file for your development, test, and production databases:</p>

<pre><code class="javascript">{
  "development": {
    "username": "update me",
    "password": "update me",
    "database": "todos",
    "host": "127.0.0.1",
    "port": "5432",
    "dialect": "postgres"
  },
  "test": {
    "username": "update me",
    "password": "update me",
    "database": "update_me",
    "host": "update me",
    "dialect": "update me"
  },
  "production": {
    "username": "update me",
    "password": "update me",
    "database": "update me",
    "host": "update me",
    "dialect": "update me"
  }
}
</code></pre>

<blockquote><p>If you are just running this locally, using the basic development server, then just update the <code>development</code> config.</p></blockquote>

<p>Go ahead and create a database named &ldquo;todos&rdquo;.</p>

<h3>Create Migration</h3>

<p>Now let&rsquo;s create a model along with a migration. Since we&rsquo;re working with todos, run the following command:</p>

<pre><code class="sh">$ node_modules/.bin/sequelize model:create --name Todo --attributes "title:string, complete:boolean,UserId:integer"
</code></pre>

<p>Take a look a the newly created model file, <em>todo.js</em> in the models directory:</p>

<pre><code class="javascript">'use strict';
module.exports = function(sequelize, DataTypes) {
  var Todo = sequelize.define('Todo', {
    title: DataTypes.STRING,
    complete: DataTypes.BOOLEAN
  }, {
    classMethods: {
      associate: function(models) {
        // associations can be defined here
      }
    }
  });
  return Todo;
};
</code></pre>

<p>The corresponding migration file can be found in the &ldquo;migrations&rdquo; folder. Take a look. Next, let&rsquo;s associate a user to a todo. First, we need to define a new migration:</p>

<pre><code class="sh">$ node_modules/.bin/sequelize model:create --name User --attributes "email:string"
</code></pre>

<p>Now we need to set up the relationship between the two models&hellip;</p>

<h3>Associations</h3>

<p>To associate the models (one user can have many todos), make the following updates&hellip;</p>

<p><strong>todo.js</strong>:</p>

<pre><code class="javascript">'use strict';
module.exports = function(sequelize, DataTypes) {
  var Todo = sequelize.define('Todo', {
    title: DataTypes.STRING,
    complete: DataTypes.BOOLEAN
  }, {
    classMethods: {
      associate: function(models) {
        Todo.belongsTo(models.User);
      }
    }
  });
  return Todo;
};
</code></pre>

<p><strong>user.js</strong>:</p>

<pre><code class="javascript">'use strict';
module.exports = function(sequelize, DataTypes) {
  var User = sequelize.define('User', {
    email: DataTypes.STRING
  }, {
    classMethods: {
      associate: function(models) {
        User.hasMany(models.Todo);
      }
    }
  });
  return User;
};
</code></pre>

<h3>Sync</h3>

<p>Finally, before we sync, let&rsquo;s add an additional attribute to the <code>complete</code> field in the <em>todo.js</em> file:</p>

<pre><code class="javascript">'use strict';
module.exports = function(sequelize, DataTypes) {
  var Todo = sequelize.define('Todo', {
    title: DataTypes.STRING,
    complete: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  }, {
    classMethods: {
      associate: function(models) {
        Todo.belongsTo(models.User);
      }
    }
  });
  return Todo;
};
</code></pre>

<p>Run the migration to create the tables:</p>

<pre><code class="sh">$ node_modules/.bin/sequelize db:migrate

Sequelize [Node: 4.1.1, CLI: 2.1.0, ORM: 3.12.2]

Loaded configuration file "server/config.json".
Using environment "development".
Using gulpfile ~/node_modules/sequelize-cli/lib/gulpfile.js
Starting 'db:migrate'...
== 20151101052127-create-todo: migrating =======
== 20151101052127-create-todo: migrated (0.049s)

== 20151101052148-create-user: migrating =======
== 20151101052148-create-user: migrated (0.042s)
</code></pre>

<h2>CRUD</h2>

<p>With Sequelize set up and the models defined, we can now set up our RESTful routing structure for the todo resource. First, within <em>index.js</em> in the &ldquo;routes&rdquo; folder add the following requirement:</p>

<pre><code class="javascript">var models = require('../models/index');
</code></pre>

<p>Then add a route for creating a new user:</p>

<pre><code class="javascript">router.post('/users', function(req, res) {
  models.User.create({
    email: req.body.email
  }).then(function(user) {
    res.json(user);
  });
});
</code></pre>

<p>To add a new user, run the server - <code>gulp</code> - and then run the following in a new terminal window:</p>

<pre><code class="sh">$ curl --data "email=michael@mherman.org" http://127.0.0.1:3000/users
</code></pre>

<p>You should see:</p>

<pre><code class="json">{
  "id":1,
  "email":"michael@mherman.org",
  "updatedAt":"2015-11-01T12:24:20.375Z",
  "createdAt":"2015-11-01T12:24:20.375Z"
}
</code></pre>

<p>Now we can add the todo routes&hellip;</p>

<h3>GET all todos</h3>

<pre><code class="javascript">// get all todos
router.get('/todos', function(req, res) {
  models.Todo.findAll({}).then(function(todos) {
    res.json(todos);
  });
});
</code></pre>

<p>When you hit that route you should see an empty array since we have not added any todos. Let&rsquo;s do that now.</p>

<h3>POST</h3>

<pre><code class="javascript">// add new todo
router.post('/todos', function(req, res) {
  models.Todo.create({
    title: req.body.title,
    UserId: req.body.user_id
  }).then(function(todo) {
    res.json(todo);
  });
});
</code></pre>

<p>Now let&rsquo;s test:</p>

<pre><code class="sh">$ curl --data "title=test&amp;user_id=1" http://127.0.0.1:3000/todos
$ curl --data "title=test2&amp;user_id=1" http://127.0.0.1:3000/todos
</code></pre>

<p>Then if you go back and hit <a href="http://127.0.0.1:3000/todos">http://127.0.0.1:3000/todos</a> in our browser, you should see:</p>

<pre><code class="json">[
  {
    id: 1,
    title: "test",
    complete: false,
    createdAt: "2015-11-01T12:31:56.451Z",
    updatedAt: "2015-11-01T12:31:56.451Z",
    UserId: 1
  },
  {
    id: 2,
    title: "test2",
    complete: false,
    createdAt: "2015-11-01T12:32:09.000Z",
    updatedAt: "2015-11-01T12:32:09.000Z",
    UserId: 1
  }
]
</code></pre>

<h3>GET single todo</h3>

<p>How about getting a single todo?</p>

<pre><code class="javascript">// get single todo
router.get('/todo/:id', function(req, res) {
  models.Todo.find({
    where: {
      id: req.params.id
    }
  }).then(function(todo) {
    res.json(todo);
  });
});
</code></pre>

<p>Navigate to <a href="http://localhost:3000/todo/1">http://localhost:3000/todo/1</a> in your browser. You should the single todo.</p>

<h3>PUT</h3>

<p>Need to update a todo?</p>

<pre><code class="javascript">// update single todo
router.put('/todo/:id', function(req, res) {
  models.Todo.find({
    where: {
      id: req.params.id
    }
  }).then(function(todo) {
    if(todo){
      todo.updateAttributes({
        title: req.body.title,
        complete: req.body.complete
      }).then(function(todo) {
        res.send(todo);
      });
    }
  });
});
</code></pre>

<p>And now for a test, of course:</p>

<pre><code class="sh">$ curl -X PUT --data "complete=true" http://127.0.0.1:3000/todo/2
</code></pre>

<h3>DELETE</h3>

<p>Want to delete a todo?</p>

<pre><code class="javascript">// delete a single todo
router.delete('/todo/:id', function(req, res) {
  models.Todo.destroy({
    where: {
      id: req.params.id
    }
  }).then(function(todo) {
    res.json(todo);
  });
});
</code></pre>

<p>Test:</p>

<pre><code class="sh">$ curl -X DELETE http://127.0.0.1:3000/todo/1
</code></pre>

<p>Again, navigate to <a href="http://localhost:3000/todos">http://localhost:3000/todos</a> in your browser. You should now only see one todo.</p>

<h2>Conclusion</h2>

<p>That&rsquo;s it for the basic server-side code. You now have a database, models, and migrations set up. Whenever you want to update the state of your database, just add additional migrations and then run them as necessary.</p>

<p>Grab the code from the <a href="https://github.com/mjhea0/node-postgres-sequelize">Github repo</a>. Comment below with questions. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Social Authentication in Node.js With Passport]]></title>
    <link href="http://mherman.org/blog/2015/09/26/social-authentication-in-node-dot-js-with-passport/"/>
    <updated>2015-09-26T13:37:00-06:00</updated>
    <id>http://mherman.org/blog/2015/09/26/social-authentication-in-node-dot-js-with-passport</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/jaredhanson/passport">Passport</a> is a library that provides a mechanism for easily setting up an authentication/registration system with support for <a href="https://github.com/jaredhanson/passport#strategies">several frameworks and auth providers</a>. <strong>In this tutorial, we’ll demonstrate in detail how to integrate this library into a Node.JS/Express 4 application to provide user authentication through LinkedIn, Github, and Twitter using OAuth 2.0.</strong></p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/passport-social-auth.png" style="max-width: 100%; border:0;" alt="passport social auth">
</div>


<p>We will be using:</p>

<ul>
<li>NodeJS v<a href="https://nodejs.org/docs/v4.1.1/api/all.html">4.1.1</a></li>
<li>ExpressJS v<a href="http://expressjs.com/4x/api.html">4.13.1</a></li>
<li>Mongoose v<a href="http://mongoosejs.com/docs/guide.html">4.1.8</a></li>
<li>Passport Strategies:

<ul>
<li>passport: v<a href="https://github.com/jaredhanson/passport">0.3.0</a></li>
<li>passport-linkedin: v<a href="https://github.com/jaredhanson/passport-linkedin">1.0.0</a></li>
<li>passport-github2: v<a href="https://github.com/cfsghost/passport-github">0.1.9</a></li>
<li>passport-twitter: v<a href="https://github.com/jaredhanson/passport-twitter">1.0.3</a></li>
</ul>
</li>
</ul>


<blockquote><p>For all dependencies, please view the <em>package.json</em> file in the <a href="https://github.com/mjhea0/passport-social-auth">repo</a>.</p></blockquote>

<h2>OAuth 2.0?</h2>

<p><a href="http://oauth.net/2/">OAuth 2.0</a> is the successor of the OAuth protocol (<a href="https://en.wikipedia.org/wiki/OAuth">open standard for authorization</a>), which enables third-party applications, such as the one we&rsquo;ll be building, access to an HTTP service without having to share secure credentials.</p>

<h2>Project Setup</h2>

<p>Let&rsquo;s get started!</p>

<h3>Boilerplate</h3>

<p>Start by downloading the project structure from the <a href="https://github.com/mjhea0/passport-social-auth/releases/tag/v1">Github repo</a>.</p>

<p>You should have:</p>

<pre><code class="sh">├── client
│   └── public
│       ├── css
│       │   └── main.css
│       └── js
│           └── main.js
├── package.json
└── server
    ├── app.js
    ├── bin
    │   └── www
    ├── routes
    │   └── index.js
    └── views
        ├── error.html
        ├── index.html
        └── layout.html
</code></pre>

<h2>Passport</h2>

<p>Install Passport as well as the specific <a href="https://github.com/jaredhanson/passport#search-all-strategies">Passport Strategies</a>:</p>

<pre><code class="sh">$ npm install passport@0.3.0 --save
$ npm install passport-github2@0.1.9 passport-linkedin@1.0.0 passport-twitter@1.0.3 --save
</code></pre>

<p>Create an &ldquo;auth&rdquo; directory in the &ldquo;server&rdquo; and add the following files:</p>

<pre><code class="sh">└── auth
  ├── github.js
  ├── linkedin.js
  └── twitter.js
</code></pre>

<p>Add the Passport dependency to <em>app.js</em>:</p>

<pre><code class="javascript">var passport = require('passport');
</code></pre>

<p>Install the <a href="https://github.com/expressjs/session">express session</a> middleware:</p>

<pre><code class="sh">$ npm install express-session@1.11.3 --save
</code></pre>

<p>And add it as a dependency:</p>

<pre><code class="javascript">var session = require('express-session');
</code></pre>

<p>Then add the required middleware:</p>

<pre><code class="javascript">app.use(session({
  secret: 'keyboard cat',
  resave: true,
  saveUninitialized: true
}));
app.use(passport.initialize());
app.use(passport.session());
</code></pre>

<h3>Configuration</h3>

<p>Add a <em>_config.js</em> file to the &ldquo;server&rdquo; and add the following:</p>

<pre><code class="javascript">var ids = {
  github: {
    clientID: 'get_your_own',
    clientSecret: 'get_your_own',
    callbackURL: "http://127.0.0.1:3000/auth/github/callback"
  },
  linkedin: {
    clientID: 'get_your_own',
    clientSecret: 'get_your_own',
    callbackURL: "http://127.0.0.1:3000/auth/linkedin/callback"
  },
  twitter: {
    consumerKey: 'get_your_own',
    consumerSecret: 'get_your_own',
    callbackURL: "http://127.0.0.1:3000/auth/twitter/callback"
  }
};

module.exports = ids;
</code></pre>

<p>Make sure to add this file to your <em>.gitignore</em> since this will contain sensitive info.</p>

<h3>MongoDB and Mongoose</h3>

<p>Install <a href="http://mongoosejs.com/">Mongoose</a>:</p>

<pre><code class="sh">$ npm install mongoose@4.1.8 --save
</code></pre>

<p>Require the dependency in <em>app.js</em>:</p>

<pre><code class="javascript">var mongoose = require('mongoose');
</code></pre>

<p>Then establish the connection to MongoDB within <em>app.js</em>:</p>

<pre><code class="javascript">// *** mongoose *** //
mongoose.connect('mongodb://localhost/passport-social-auth');
</code></pre>

<p>Add a Mongoose Schema to a new file called <em>user.js</em> in a new folder, within &ldquo;server&rdquo;, called &ldquo;models&rdquo;:</p>

<pre><code class="javascript">var mongoose = require('mongoose');
var Schema = mongoose.Schema;


// create User Schema
var User = new Schema({
  name: String,
  someID: String
});


module.exports = mongoose.model('users', User);
</code></pre>

<h3>Serialize and Deserialize</h3>

<p>Passport needs to serialize and deserialize user instances from a session store to support login sessions. To add this funcionality, create an <em>init.js</em> file within the &ldquo;auth&rdquo; directory, and then add the following code:</p>

<pre><code class="javascript">var passport = require('passport');
var User = require('../models/user');


module.exports = function() {

  passport.serializeUser(function(user, done) {
    done(null, user.id);
  });

  passport.deserializeUser(function(id, done) {
    User.findById(id, function (err, user) {
      done(err, user);
    });
  });

};
</code></pre>

<h3>Routes and Views</h3>

<p>Before we test, add the following route-</p>

<pre><code class="javascript">router.get('/login', function(req, res, next) {
  res.send('Go back and register!');
});
</code></pre>

<p>-and update the <em>index.html</em> file:</p>

<p>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>{% extends <span class="ni">&amp;lsquo;</span>layout.html<span class="ni">&amp;rsquo;</span> %}<span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>{% block title %}{% endblock %}<span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>{% block content %}<span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;container&quot;</span><span class="nt">&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;pre&gt;&lt;code&gt;</span><span class="ni">&amp;lt;</span>h1<span class="ni">&amp;gt;</span>{{ title }}<span class="ni">&amp;lt;</span>/h1<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>p<span class="ni">&amp;gt;</span>Welcome! Please Login.<span class="ni">&amp;lt;</span>/p<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>hr<span class="ni">&amp;gt;&amp;lt;</span>br<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>a href=&quot;http://mherman.org/auth/linkedin&quot; class=&quot;btn btn-default&quot;<span class="ni">&amp;gt;</span>LinkedIn<span class="ni">&amp;lt;</span>/a<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>a href=&quot;http://mherman.org/auth/github&quot; class=&quot;btn btn-default&quot;<span class="ni">&amp;gt;</span>Github<span class="ni">&amp;lt;</span>/a<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>a href=&quot;http://mherman.org/auth/twitter&quot; class=&quot;btn btn-default&quot;<span class="ni">&amp;gt;</span>Twitter<span class="ni">&amp;lt;</span>/a<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>  <span class="nt">&lt;/div&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>{% endblock %}
</span></code></pre></td></tr></table></div></figure>
</p>

<h3>Sanity Check</h3>

<p>Test this code to make sure all is well:</p>

<pre><code class="sh">$ npm start
</code></pre>

<p>Once done, kill the server, and then commit your code and push to Github.</p>

<blockquote><p>Need the updated code? Grab it <a href="https://github.com/mjhea0/passport-social-auth/releases/tag/v2">here</a>.</p></blockquote>

<h2>LinkedIn Auth</h2>

<blockquote><p><a href="https://github.com/jaredhanson/passport-linkedin">https://github.com/jaredhanson/passport-linkedin</a></p></blockquote>

<p>For almost all of the strategies, you will need to-</p>

<ol>
<li>Create an app through the auth provider</li>
<li>Update the config file with the required IDs and keys as well as a callback URL</li>
<li>Configure the Passport strategy</li>
<li>Add the required routes</li>
<li>Update the view</li>
</ol>


<h3>Create an App</h3>

<p>Navigate to <a href="https://www.linkedin.com/developer/apps/">LinkedIn Developers</a> to register a new application. Just enter dummy info, make sure to add the callback - <a href="http://127.0.0.1:3000/auth/linkedin/callback">http://127.0.0.1:3000/auth/linkedin/callback</a> - and update the config within the app:</p>

<pre><code class="javascript">linkedin: {
 clientID: 'ADD YOUR ID HERE',
 clientSecret: 'ADD YOUR SECRET HERE',
 callbackURL: "http://127.0.0.1:3000/auth/linkedin/callback"
},
</code></pre>

<h3>Configure Strategy</h3>

<blockquote><p><a href="https://github.com/jaredhanson/passport-linkedin#usage">https://github.com/jaredhanson/passport-linkedin#usage</a></p></blockquote>

<p>Add the following code to <em>linkedin.js</em>:</p>

<pre><code class="javascript">var passport = require('passport');
var LinkedInStrategy = require('passport-linkedin');

var User = require('../models/user');
var config = require('../_config');
var init = require('./init');

passport.use(new LinkedInStrategy({
    consumerKey: config.linkedin.clientID,
    consumerSecret: config.linkedin.clientSecret,
    callbackURL: config.linkedin.callbackURL
  },
  // linkedin sends back the tokens and progile info
  function(token, tokenSecret, profile, done) {

    var searchQuery = {
      name: profile.displayName
    };

    var updates = {
      name: profile.displayName,
      someID: profile.id
    };

    var options = {
      upsert: true
    };

    // update the user if s/he exists or add a new user
    User.findOneAndUpdate(searchQuery, updates, options, function(err, user) {
      if(err) {
        return done(err);
      } else {
        return done(null, user);
      }
    });
  }

));

// serialize user into the session
init();


module.exports = passport;
</code></pre>

<p>Aside for the Passport magic, you can see that we&rsquo;re either updating the user, if the user is found, or creating a new user, if a user is not found.</p>

<h3>Add Routes</h3>

<blockquote><p><a href="https://github.com/jaredhanson/passport-linkedin#authenticate-requests">https://github.com/jaredhanson/passport-linkedin#authenticate-requests</a></p></blockquote>

<p>Update the routes with:</p>

<pre><code class="javascript">router.get('/auth/linkedin', passportLinkedIn.authenticate('linkedin'));

router.get('/auth/linkedin/callback',
  passportLinkedIn.authenticate('linkedin', { failureRedirect: '/login' }),
  function(req, res) {
    // Successful authentication
    res.json(req.user);
  });
</code></pre>

<p>Add in the dependency as well:</p>

<pre><code class="javascript">var passportLinkedIn = require('../auth/linkedin');
</code></pre>

<h3>Sanity Check</h3>

<p>Test this out. <em>Be sure to use <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000/</a> rather than <a href="http://localhost:3000/">http://localhost:3000/</a>.</em></p>

<p>Now, let&rsquo;s just duplicate that workflow for the remaining providers&hellip;</p>

<h2>Github Auth</h2>

<blockquote><p><a href="https://github.com/cfsghost/passport-github">https://github.com/cfsghost/passport-github</a></p></blockquote>

<h3>Create an App</h3>

<p>Again, create an app, adding in the correct callback URL, and add the given client ID and Secret Key to the <em>_config.js</em> file.</p>

<h3>Configure Strategy</h3>

<blockquote><p><a href="https://github.com/cfsghost/passport-github#configure-strategy">https://github.com/cfsghost/passport-github#configure-strategy</a></p></blockquote>

<pre><code class="javascript">var passport = require('passport');
var GitHubStrategy = require('passport-github2').Strategy;

var User = require('../models/user');
var config = require('../_config');
var init = require('./init');


passport.use(new GitHubStrategy({
  clientID: config.github.clientID,
  clientSecret: config.github.clientSecret,
  callbackURL: config.github.callbackURL
  },
  function(accessToken, refreshToken, profile, done) {

    var searchQuery = {
      name: profile.displayName
    };

    var updates = {
      name: profile.displayName,
      someID: profile.id
    };

    var options = {
      upsert: true
    };

    // update the user if s/he exists or add a new user
    User.findOneAndUpdate(searchQuery, updates, options, function(err, user) {
      if(err) {
        return done(err);
      } else {
        return done(null, user);
      }
    });
  }

));

// serialize user into the session
init();


module.exports = passport;
</code></pre>

<h3>Add Routes</h3>

<blockquote><p><a href="https://github.com/cfsghost/passport-github#authenticate-requests">https://github.com/cfsghost/passport-github#authenticate-requests</a></p></blockquote>

<pre><code class="javascript">var passportGithub = require('../auth/github');

router.get('/auth/github', passportGithub.authenticate('github', { scope: [ 'user:email' ] }));

router.get('/auth/github/callback',
  passportGithub.authenticate('github', { failureRedirect: '/login' }),
  function(req, res) {
    // Successful authentication
    res.json(req.user);
  });
</code></pre>

<h2>Twitter Auth</h2>

<blockquote><p><a href="https://github.com/jaredhanson/passport-twitter">https://github.com/jaredhanson/passport-twitter</a></p></blockquote>

<h3>Create an App</h3>

<p>Create an app on the <a href="https://apps.twitter.com/">Twitter Developer page</a>, and grab the Consumer Key and Secret.</p>

<h3>Configure Strategy</h3>

<blockquote><p><a href="https://github.com/jaredhanson/passport-twitter#configure-strategy">https://github.com/jaredhanson/passport-twitter#configure-strategy</a></p></blockquote>

<pre><code class="javascript">var passport = require('passport');
var TwitterStrategy = require('passport-twitter').Strategy;

var User = require('../models/user');
var config = require('../_config');
var init = require('./init');

passport.use(new TwitterStrategy({
    consumerKey: config.twitter.consumerKey,
    consumerSecret: config.twitter.consumerSecret,
    callbackURL: config.twitter.callbackURL
  },
  function(accessToken, refreshToken, profile, done) {

    var searchQuery = {
      name: profile.displayName
    };

    var updates = {
      name: profile.displayName,
      someID: profile.id
    };

    var options = {
      upsert: true
    };

    // update the user if s/he exists or add a new user
    User.findOneAndUpdate(searchQuery, updates, options, function(err, user) {
      if(err) {
        return done(err);
      } else {
        return done(null, user);
      }
    });
  }

));

// serialize user into the session
init();


module.exports = passport;
</code></pre>

<h3>Add Routes</h3>

<blockquote><p><a href="https://github.com/jaredhanson/passport-twitter#authenticate-requests">https://github.com/jaredhanson/passport-twitter#authenticate-requests</a></p></blockquote>

<pre><code class="javascript">var passportTwitter = require('../auth/twitter');

router.get('/auth/twitter', passportTwitter.authenticate('twitter'));

router.get('/auth/twitter/callback',
  passportTwitter.authenticate('twitter', { failureRedirect: '/login' }),
  function(req, res) {
    // Successful authentication
    res.json(req.user);
  });
</code></pre>

<h2>Conclusion</h2>

<p>Try adding some additional <a href="https://github.com/jaredhanson/passport#strategies">strategies</a>, comment below if you have questions, and grab the final code from the <a href="https://github.com/mjhea0/passport-social-auth">repo</a>.</p>

<p>Thanks for reading!</p>
]]></content>
  </entry>
  
</feed>
