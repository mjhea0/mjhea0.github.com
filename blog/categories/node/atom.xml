<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: node | Michael Herman]]></title>
  <link href="http://mjhea0.github.com/blog/categories/node/atom.xml" rel="self"/>
  <link href="http://mjhea0.github.com/"/>
  <updated>2015-08-26T20:52:15-06:00</updated>
  <id>http://mjhea0.github.com/</id>
  <author>
    <name><![CDATA[Michael Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Node, Express, Swig, and MongoDB - getting started with CRUD]]></title>
    <link href="http://mjhea0.github.com/blog/2015/08/24/node-express-swig-mongo-primer/"/>
    <updated>2015-08-24T08:11:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2015/08/24/node-express-swig-mongo-primer</id>
    <content type="html"><![CDATA[<p><strong>Let&#39;s create a basic CRUD app using Node, Express, Swig, and MongoDB.</strong></p>

<div style="text-align:center;">
  <img src="http://mjhea0.github.com/images/node-express.png" style="max-width: 100%; border:0;" alt="mean stack authentication">
</div>

<p><br></p>

<blockquote>
<p>This tutorial utilizes <a href="http://nodejs.org/">Node</a> v0.12.5, <a href="http://expressjs.com/">Express</a> v4.13.1, <a href="http://paularmstrong.github.io/swig/">Swig</a> and <a href="http://mongoosejs.com/">Mongoose</a> v4.1.3.</p>
</blockquote>

<h2>Getting started</h2>

<p>Start by downloading the <a href="http://expressjs.com/starter/generator.html">Express application generator</a> (if you don&#39;t already have it) to create a basic Express project:</p>

<p><code>sh<br>
$ npm install express-generator -g<br>
</code></p>

<blockquote>
<p>The <code>-g</code> flag indicates that you want to install the package globally, on your entire system.</p>
</blockquote>

<p>Navigate to a convenient directory, like your &quot;Desktop&quot; or &quot;Documents&quot;, then create the boilerplate:</p>

<p><code>sh<br>
$ express node-express-swig-mongo<br>
$ cd node-express-swig-mongo<br>
</code></p>

<p>Check out the project structure:</p>

<p><code>sh<br>
├── app.js<br>
├── bin<br>
│   └── www<br>
├── package.json<br>
├── public<br>
│   ├── images<br>
│   ├── javascripts<br>
│   └── stylesheets<br>
│       └── style.css<br>
├── routes<br>
│   ├── index.js<br>
│   └── users.js<br>
└── views<br>
    ├── error.jade<br>
    ├── index.jade<br>
    └── layout.jade<br>
</code></p>

<p>Don&#39;t worry about the files and folders for now. Just know that we have created a boilerplate that can be used for a number of Node/Express applications. This took care of the heavy lifting, adding common files, folders, and scripts generally associated with all apps.</p>

<p>Notice the <em>package.json</em> file. This stores your project&#39;s dependencies, which we still need to install:</p>

<p><code>sh<br>
$ npm install<br>
</code></p>

<p>Now let&#39;s install Mongoose and Swig:</p>

<p><code>sh<br>
$ npm install mongoose swig --save<br>
</code></p>

<blockquote>
<p>The <code>--save</code> flag adds the dependencies and their versions to the <em>package.json</em> file. Take a look.</p>
</blockquote>

<h2>Sanity check</h2>

<p>Let&#39;s test our setup by running the app:</p>

<p><code>sh<br>
$ npm start<br>
</code></p>

<p>Navigate to <a href="http://localhost:3000/">http://localhost:3000/</a> in your browser and you should see the &quot;Welcome to Express&quot; text. Once done, kill the server by pressing CTRL-C.</p>

<h2>Nodemon</h2>

<p>Before moving on, let&#39;s setup <a href="http://nodemon.io/">Nodemon</a> so that you can run your app and watch for code changes without having to manually restart the server. Check out the link above to learn more.</p>

<p><code>sh<br>
$ npm install supervisor -g<br>
</code></p>

<p>Let&#39;s test again:</p>

<p><code>sh<br>
$ nodemon<br>
</code></p>

<p>In your terminal you should see:</p>

<p><code>sh<br>
23 Aug 16:31:02 - [nodemon] v1.4.1<br>
23 Aug 16:31:02 - [nodemon] to restart at any time, enter `rs`<br>
23 Aug 16:31:02 - [nodemon] watching: *.*<br>
23 Aug 16:31:02 - [nodemon] starting `node ./bin/www`<br>
</code></p>

<p>Essentially, Nodemon is watching for code changes, and if they do occur, then it will refresh the local server for you so you don&#39;t have to constantly kill the server then start it back up. It saves a lot of time and keystrokes.</p>

<p>Awesome. With the setup done, let&#39;s build something!</p>

<h2>Routes</h2>

<p>Grab your favorite text editor (such as <a href="http://www.sublimetext.com/">Sublime</a> or <a href="https://atom.io/">Atom</a>), and then open the main file, <em>app.js</em>, which houses much of the business logic. Take a look at the routes:</p>

<p><code>javascript<br>
app.use(&#39;/&#39;, routes);<br>
app.use(&#39;/users&#39;, users);<br>
</code></p>

<p>Understanding how routes work as well as how to trace all the files associated with an individual route is an important skill to learn. You&#39;ll be able to approach most applications and understand how they work just by starting with the routes.</p>

<p>Let&#39;s look at this route:</p>

<p><code>javascript<br>
app.use(&#39;/users&#39;, users)<br>
</code></p>

<p>Here, we know that this route is associated with the <code>/users</code> endpoint. What&#39;s an endpoint? Simply navigate to <a href="http://localhost:3000/users">http://localhost:3000/users</a>.</p>

<p>The end user navigates to that endpoint and expects <em>something</em> to happen. That could mean some HTML is rendered or perhaps JSON is returned. That&#39;s not important at this point. For now, let&#39;s look at how Node handles the logic for &quot;handling routes&quot;.</p>

<p>Also, within that route, you can see the variable <code>users</code>. Where is in this file? It&#39;s at the top, and it loads in another file within our app:</p>

<p><code>javascript<br>
var users = require(&#39;./routes/users&#39;);<br>
</code></p>

<p>Open that file:</p>

<p>```javascript<br>
var express = require(&#39;express&#39;);<br>
var router = express.Router();</p>

<p>/* GET users listing. */<br>
router.get(&#39;/&#39;, function(req, res) {<br>
  res.send(&#39;respond with a resource&#39;);<br>
});</p>

<p>module.exports = router;<br>
```</p>

<p><strong>What&#39;s happening here?</strong> Essentially when that endpoint is hit, it responds by sending text in the form of a response to the end user - &quot;respond with a resource&quot;. Now, of course you don&#39;t always have to send text. You could respond with a template or view like a Jade or Swig template file that gets rendered into HTML. We&#39;ll look at how this works in just a minute when we add our own routes.</p>

<p><strong>Make sure you understand everything in this section before moving on.</strong></p>

<h3>Add a new route</h3>

<p>Let&#39;s now add a new route that renders a HTML form to the end user.</p>

<p>Start by adding the route handler in the <em>app.js</em> file:</p>

<p><code>javascript<br>
app.use(&#39;/api&#39;, api);<br>
</code></p>

<blockquote>
<p>Remember this simply means <code>app.use(&#39;/ENDPOINT&#39;, VARIABLE_NAME);</code>,</p>
</blockquote>

<p>Use the <code>api</code> variable to require a JS file within our routes folder.</p>

<p><code>javascript<br>
var api = require(&#39;./routes/api&#39;);<br>
</code></p>

<p>Take a look in the terminal. You should see an error, indicating Node can&#39;t find the <code>./routes/api</code> module. We need to create it!</p>

<p>Create a new file called <em>api.js</em> in the &quot;routes&quot; directory. Add the following code:</p>

<p>```javascript<br>
var express = require(&#39;express&#39;);<br>
var router = express.Router();</p>

<p>router.get(&#39;/superheros&#39;, function(req, res) {<br>
  res.send(&#39;Just a test&#39;);<br>
});</p>

<p>module.exports = router;<br>
```</p>

<blockquote>
<p>Do you remember what this code <code>res.send(&#39;Just a test&#39;);</code> will do? If not, review the previous section.</p>
</blockquote>

<p>Navigate to <a href="http://localhost:3000/api/superheros">http://localhost:3000/api/superheros</a>. You should see the text &quot;Just a test&quot; on the page.</p>

<h2>Swig</h2>

<p>Swig is a templating language, which compiles down to HTML, making it easy to separate logic from markup. For more on Swig, check out the <a href="http://mherman.org/blog/2015/08/23/primer-on-swig-templating/#.VdpL_VNViko">Primer on Swig Templating</a>.</p>

<p>Take a quick look at the <em>layout.jade</em>, <em>index.jade</em>, and <em>error.jade</em> files within the &quot;views&quot; folder. Right now these files are using <a href="http://jade-lang.com/">Jade</a> templating. Let&#39;s update these files to remove Jade and add Swig. First, remove the <em>.jade</em> extension from each file and add a <em>.html</em> extension. Now we can update the actual syntax...</p>

<p><strong><em>layout.html</em></strong></p>

<p><br>
<code>html<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
  &lt;head&gt;<br>
    &lt;meta charset=&quot;utf-8&quot;&gt;<br>
    &lt;title&gt;{{ title }}&lt;/title&gt;<br>
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://mjhea0.github.com//netdna.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css&quot;&gt;<br>
    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://mjhea0.github.com/css/main.css&quot;&gt;<br>
  &lt;/head&gt;<br>
  &lt;body&gt;<br>
    {% block content %}<br>
    {% endblock %}<br>
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://mjhea0.github.com//code.jquery.com/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;<br>
    &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;<br>
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://mjhea0.github.com/js/main.js&quot;&gt;&lt;/script&gt;<br>
  &lt;/body&gt;<br>
&lt;/html&gt;<br>
</code><br>
</p>

<p><strong><em>index.html</em></strong></p>

<p><br>
```html<br>
{% extends &#39;layout.html&#39; %}</p>

<p>{% block title %}{% endblock %}</p>

<p>{% block content %}</p>

<p><div class="container"></p>
<div class="highlight"><pre><code class="text">&lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;p&gt;Welcome to {{ title }}&lt;/p&gt;
</code></pre>
</div>

<p></div></p>

<p>{% endblock %}<br>
```<br>
</p>

<p><strong><em>error.html</em></strong></p>

<p><br>
```html<br>
{% extends &#39;layout.html&#39; %}</p>

<p>{% block title %}{% endblock %}</p>

<p>{% block content %}</p>

<p><div class="container"></p>
<div class="highlight"><pre><code class="text">&lt;h1&gt;{{ message }}&lt;/h1&gt;
&lt;h2&gt;{{ error.status }}&lt;/h2&gt;
&lt;pre&gt;{{ error.stack }}&lt;/pre&gt;
</code></pre>
</div>

<p></div></p>

<p>{% endblock %}<br>
```<br>
</p>

<p>Finally, update <em>app.js</em> by requiring the following dependency at the top of the file:</p>

<p><code>javascript<br>
var swig = require(&#39;swig&#39;);<br>
</code></p>

<p>Then set Swig as the template engine by replacing <code>app.set(&#39;view engine&#39;, &#39;jade&#39;);</code> with-</p>

<p><code>javascript<br>
var swig = new swig.Swig();<br>
app.engine(&#39;html&#39;, swig.renderFile);<br>
app.set(&#39;view engine&#39;, &#39;html&#39;);<br>
</code></p>

<p>Jump back to the &quot;views&quot;, and take a look at <em>layout.html</em> and <em>index.html</em>. There&#39;s a relationship between those two files. We define the base structure in the <em>layout</em> file, which contains common structure that can be reused in multiple places.</p>

<p>Do you see the <code>block</code> keyword?</p>

<p>What really happens when the <em>index</em> file is rendered is that it first renders the base template because of the <code>extends</code> keyword. So, the <em>layout</em> template then gets rendered, which eventually pulls in the child template, overwriting the <code>block</code> keyword with:</p>

<p><br>
```html<br>
<div class="container"></p>

<p><h1>{{ title }}</h1><br>
  <p>Welcome to {{ title }}</p></p>

<p></div><br>
```<br>
</p>

<p>Hope that makes sense. If not, check out <a href="http://mherman.org/blog/2015/08/23/primer-on-swig-templating/#template-inheritence">this</a> resource for more info on template inheritance.</p>

<h3>Setup <em>api.html</em></h3>

<p>Create a new file called <em>api.html</em> in the &quot;views&quot; directory, and then add the following code:</p>

<p><br>
```html<br>
{% extends &#39;layout.html&#39; %}</p>

<p>{% block title %}{% endblock %}</p>

<p>{% block content %}</p>

<p><div class="container"></p>
<div class="highlight"><pre><code class="text">&lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;p&gt;Welcome to {{ title }}&lt;/p&gt;
</code></pre>
</div>

<p></div></p>

<p>{% endblock %}<br>
```<br>
</p>

<p>The same thing is happening here with inheritance. If you&#39;re unfamiliar with Swig syntax, <code>{{ title }}</code> is essentially a variable, which we can pass in from <code>./routes/api.js</code>.</p>

<p>Update <code>./routes/api.js</code> by changing-</p>

<p><code>javascript<br>
res.send(&#39;Just a test&#39;);<br>
</code></p>

<p>-to-</p>

<p><code>javascript<br>
res.render(&#39;api&#39;, { title: &#39;Superhero API&#39; });<br>
</code></p>

<p>This just says, &quot;When a user hits the <code>/api/superheros</code> endpoint, render the <em>api.html</em> file and pass in <code>Superhero API</code> as the title.&quot;</p>

<blockquote>
<p>Keep in mind that all Swig files are converted to HTML since browsers can&#39;t read the Swig templating syntax.</p>
</blockquote>

<p>Ready to test? Simple refresh <a href="http://localhost:3000/api/superheros">http://localhost:3000/api/superheros</a>.</p>

<p>Did it work? If yes, move on. If not, go back through this section and review.</p>

<h3>Update <em>api.html</em></h3>

<p>So, let&#39;s update the template to display a form:</p>

<p><br>
```html<br>
{% extends &#39;layout.html&#39; %}</p>

<p>{% block title %}{% endblock %}</p>

<p>{% block content %}</p>

<p><div class="container"></p>
<div class="highlight"><pre><code class="text">&lt;h1&gt;{{ title }}&lt;/h1&gt;

&lt;br&gt;

&lt;form method=&quot;post&quot; action=&quot;/api/superheros&quot; class=&quot;form-inline&quot;&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label&gt;Superhero name&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;form-control&quot; required&gt;
  &lt;/div&gt;
  &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;
</code></pre>
</div>

<p></div></p>

<p>{% endblock %}<br>
```<br>
</p>

<p>Refresh your browser. Do you see the form? Try clicking save. What happens? Well, you just tried to send a POST request to the <code>/api/superheros</code> endpoint, which does not exist - so you should see a 404 error. Let&#39;s set up the route handler.</p>

<h2>POST requests (part 1)</h2>

<p>Open <em>api.js</em> to add the logic for this new route:</p>

<p>```javascript<br>
var express = require(&#39;express&#39;);<br>
var router = express.Router();</p>

<p>router.get(&#39;/superheros&#39;, function(req, res) {<br>
  res.render(&#39;api&#39;, { title: &#39;Superhero API&#39; });<br>
});</p>

<p>router.post(&#39;/superheros&#39;, function(req, res) {<br>
  console.log(req.body.name);<br>
  res.redirect(&#39;/api/superheros&#39;);<br>
});</p>

<p>module.exports = router;<br>
```</p>

<p>Test this out again. Now, when you submit the form, we have the <code>/api/superheros</code> endpoint setup, which then grabs the text from the input box via <code>req.body.name</code>. Make sure the text is consoled in your terminal.</p>

<p>Okay. So, we are handling the routes and rendering the right template, but we still need to setup Mongoose to save the data from our form before we can finish with the POST request.</p>

<h2>Mongoose</h2>

<p><a href="http://mongoosejs.com/">Mongoose</a> is used for interacting with MongoDB. Start with defining the Schema, which then maps to a collection in Mongo.</p>

<p>Create a file called <em>database.js</em> in your app&#39;s root directory, then add the following code:</p>

<p>```javascript<br>
var mongoose = require(&#39;mongoose&#39;);<br>
var Schema   = mongoose.Schema;</p>

<p>var Superhero = new Schema(<br>
  {name : String}<br>
);</p>

<p>mongoose.model(&#39;superheros&#39;, Superhero);</p>

<p>mongoose.connect(&#39;mongodb://localhost/node-superhero&#39;);<br>
```</p>

<p>Here, we required/included the Mongoose library along with a reference to the <code>Schema()</code> method. As said, you always start with defining the schema, then we linked it to collection called &quot;superheros&quot;. Finally, we opened a connection to an instance of our local MongoDB.</p>

<blockquote>
<p>If you don&#39;t have the MongoDB server running. Do so now. Open a new terminal window, and run the command <code>sudo mongod</code>. If you need to set up MongoDB, follow the Installation steps <a href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-os-x/">here</a>.</p>
</blockquote>

<p>Next, open <em>app.js</em> and require the Mongoose config at the very top of the file:</p>

<p><code>javascript<br>
// mongoose config<br>
require(&#39;./database&#39;);<br>
</code></p>

<p>With Mongoose setup, we need to update <em>api.js</em> to create (via POST) and read (via GET) data from the Mongo collection.</p>

<h2>GET requests (all resources)</h2>

<p>Open <em>api.js</em>. Require Mongoose as well as the <code>superheros</code> model, which we already created:</p>

<p><code>javascript<br>
var mongoose = require(&#39;mongoose&#39;);<br>
var Superhero = mongoose.model(&#39;superheros&#39;);<br>
</code></p>

<p>Now, update the function handling GET requests:</p>

<p><code>javascript<br>
router.get(&#39;/superheros&#39;, function(req, res) {<br>
  Superhero.find(function(err, superheros){<br>
    console.log(superheros)<br>
    res.render(<br>
      &#39;api&#39;,<br>
      {title : &#39;Superhero API&#39;, superheros : superheros}<br>
    );<br>
  });<br>
});<br>
</code></p>

<p><code>Superhero.find()</code> grabs all superheros from the Mongo collection, which we assign to the variable <code>superheros</code>. We can now use that variable in the Swig template.</p>

<h3>Update <em>api.html</em> to display superheros</h3>

<p>Let&#39;s add a loop to iterate through the superheros and then display the <code>name</code> key from the collection.</p>

<p><br>
```html<br>
{% extends &#39;layout.html&#39; %}</p>

<p>{% block title %}{% endblock %}</p>

<p>{% block content %}</p>

<p><div class="container"></p>
<div class="highlight"><pre><code class="text">&lt;h1&gt;{{ title }}&lt;/h1&gt;

&lt;br&gt;

&lt;form method=&quot;post&quot; action=&quot;/api/superheros&quot; class=&quot;form-inline&quot;&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label&gt;Superhero name&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;form-control&quot; required&gt;
  &lt;/div&gt;
  &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Save&lt;/button&gt;
&lt;/form&gt;

&lt;hr&gt;&lt;br&gt;

&lt;h2&gt;All Superheros&lt;/h2&gt;

&lt;ul&gt;
{% for superhero in superheros %}
  &lt;li&gt;{{superhero.name}}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</code></pre>
</div>

<p></div></p>

<p>{% endblock %}<br>
```<br>
</p>

<blockquote>
<p>Do you remember where we set the <code>name</code> key? Check out the database schema in <em>database.js</em>.</p>
</blockquote>

<p>Before this will actually work - e.g., display superheros - we first need to add the logic to insert data into the Mongo collection.</p>

<h2>POST requests (part 2)</h2>

<p>Back in <em>api.js</em>, update the function for handling POST requests:</p>

<p><code>javascript<br>
router.post(&#39;/superheros&#39;, function(req, res) {<br>
  new Superhero({name : req.body.name})<br>
  .save(function(err, superhero) {<br>
    console.log(superhero)<br>
    res.redirect(&#39;/api/superheros&#39;);<br>
  });<br>
});<br>
</code></p>

<p>This simply saves a new superhero, which again is grabbed from the form via <code>req.body.name</code>.</p>

<h2>Sanity Check</h2>

<p>Refresh you app. Add some superheros. If you&#39;ve done everything correctly, the superheros should be displayed beneath the form.</p>

<p>What about updates? And deletions? First, let&#39;s display a single superhero.</p>

<h2>GET requests (single resource)</h2>

<p>Update the list item in the HTML file like so to give each item a unique URL.</p>

<p><br>
<code>html<br>
&lt;li&gt;&lt;a href=&quot;superhero/{{superhero.id}}&quot;&lt;/a&gt;{{superhero.name}}&lt;/li&gt;<br>
</code><br>
</p>

<p>Now, let&#39;s add a new route handler to <em>app.js</em> to display a single superhero:</p>

<p><code>javascript<br>
router.get(&#39;/superhero/:id&#39;, function(req, res) {<br>
  var query = {&quot;_id&quot;: req.params.id};<br>
  Superhero.findOne(query, function(err, superhero){<br>
    console.log(superhero)<br>
    res.render(<br>
      &#39;superhero&#39;,<br>
      {title : &#39;Superhero API - &#39; + superhero.name, superhero : superhero}<br>
    );<br>
  });<br>
});<br>
</code></p>

<p>What&#39;s next? A new template. <em>superhero.html</em>:</p>

<p><br>
```html<br>
{% extends &#39;layout.html&#39; %}</p>

<p>{% block title %}{% endblock %}</p>

<p>{% block content %}</p>

<p><div class="container"></p>
<div class="highlight"><pre><code class="text">&lt;h1&gt;{{ title }}&lt;/h1&gt;

&lt;br&gt;

&lt;form method=&quot;post&quot; action=&quot;/api/superhero/{{superhero.id}}?_method=PUT&quot;&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label&gt;Superhero name&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;form-control&quot; value=&quot;{{superhero.name}}&quot; required&gt;
  &lt;/div&gt;
  &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Update&lt;/button&gt;
&lt;/form&gt;

&lt;br&gt;

&lt;form method=&quot;post&quot; action=&quot;/api/superhero/{{superhero.id}}?_method=DELETE&quot; class=&quot;form-inline&quot;&gt;
  &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Delete&lt;/button&gt;
&lt;/form&gt;
</code></pre>
</div>

<p></div></p>

<p>{% endblock %}<br>
```<br>
</p>

<p>Test this out.</p>

<h2>PUT requests</h2>

<p>Since most browsers do not handle PUT or DELETE requests, we need to use the <a href="https://github.com/expressjs/method-override">method-override</a> middleware to handle such requests.</p>

<p>Install via NPM:</p>

<p><code>sh<br>
$ npm install method-override --save<br>
</code></p>

<p>Add the requirement to <em>app.js</em>:</p>

<p><code>javascript<br>
var methodOverride = require(&#39;method-override&#39;);<br>
</code></p>

<p>Then define the middleware just below the view engine setup in <em>app.js</em>:</p>

<p><code>javascript<br>
app.use(methodOverride(&#39;_method&#39;))<br>
</code></p>

<p>Finally, add the route handler to <em>api.js</em>:</p>

<p><code>javascript<br>
router.put(&#39;/superhero/:id&#39;, function(req, res) {<br>
  var query = {&quot;_id&quot;: req.params.id};<br>
  var update = {name : req.body.name};<br>
  var options = {new: true};<br>
  Superhero.findOneAndUpdate(query, update, options, function(err, superhero){<br>
    console.log(superhero)<br>
    res.render(<br>
      &#39;superhero&#39;,<br>
      {title : &#39;Superhero API - &#39; + superhero.name, superhero : superhero}<br>
    );<br>
  });<br>
});<br>
</code></p>

<p>Here, we are simply searching Mongo for the correct superhero via the Mongo ID and then updating the superhero name, which comes from the form, <code>req.body.name</code>. By setting <code>new</code> to <code>true</code>, we&#39;re able to grab the updated superhero information after the changes are made in Mongo. Try removing this option. What happens?</p>

<h2>DELETE requests</h2>

<p>With the button already set up in the template, we just need to add the route handler to <em>api.js</em>:</p>

<p><code>javascript<br>
router.delete(&#39;/superhero/:id&#39;, function(req, res) {<br>
  var query = {&quot;_id&quot;: req.params.id};<br>
  Superhero.findOneAndRemove(query, function(err, superhero){<br>
    console.log(superhero)<br>
    res.redirect(&#39;/api/superheros&#39;);<br>
  });<br>
});<br>
</code></p>

<p>Again, we&#39;re querying the database by the Mongo ID and then removing it. Simple, right?</p>

<h2>Conclusion</h2>

<p>That&#39;s it. Post your questions below. Grab the code from the <a href="https://github.com/mjhea0/node-express-swig-mongo">repository</a>. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Primer on Swig Templating]]></title>
    <link href="http://mjhea0.github.com/blog/2015/08/23/primer-on-swig-templating/"/>
    <updated>2015-08-23T14:10:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2015/08/23/primer-on-swig-templating</id>
    <content type="html"><![CDATA[<p><strong>Let&#39;s look at the basics of <a href="http://paularmstrong.github.io/swig/">Swig</a>, &quot;a simple, powerful, and extendable JavaScript Template Engine&quot; for NodeJS.</strong></p>

<p><hr><br></p>

<p>First off, a templating engine creates web pages (or views) dynamically by combining variables and programming logic with HTML. Essentially, you can add placeholders (or tags) to your HTML that are replaced by <em>actual</em> code defined from your router or controller. In general, tags, for the majority of templating engines, fall within one of two categores-</p>

<ol>
<li><em>Variables/Output Tags</em> - surrounded by double curly brackets <code></code>, these output the results of a logic tag or a variable to the end user</li>
<li><em>Logic Tags</em> - surrouded by <code>{% ... %}</code>, these handle programming logic, like loops and conditionals</li>
</ol>

<blockquote>
<p>Before diving in, grab the basic project structure from <a href="https://github.com/mjhea0/swig-primer/releases/tag/v1">Github</a>, install the dependencies via NPM - <code>npm install</code> - and then run the server. Pay attention to where we initialize Swig and set it as the templating language in <em>app.js</em>:<br>
    <code><br>
    var swig = new swig.Swig();<br>
    app.engine(&#39;html&#39;, swig.renderFile);<br>
    app.set(&#39;view engine&#39;, &#39;html&#39;);<br>
</code></p>
</blockquote>

<h2>Output Tags</h2>

<p>Let&#39;s start with some basic examples...</p>

<h3>Basics</h3>

<p>First, we can pass variables from our route handlers/view functions directly to the templates.</p>

<p>Update the <em>index.html</em> file:</p>

<p><br>
<code>html<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
  &lt;title&gt;{{title}}&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  &lt;h1&gt;{{title}}&lt;/h1&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;<br>
</code><br>
</p>

<p>Now, we can pass in a variable called <code>title</code> to the template from <em>app.js</em>:</p>

<p><code>javascript<br>
// *** main routes *** //<br>
app.get(&#39;/&#39;, function(req, res) {<br>
  res.render(&#39;index.html&#39;, {title: &#39;Swig Primer!&#39;});<br>
});<br>
</code></p>

<p>Fire up the server and test this out. Nice. <strong>Try adding another variable to the template.</strong></p>

<p><em>index.html</em>:</p>

<p><br>
<code>html<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
  &lt;title&gt;{{title}}&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  &lt;h1&gt;{{title}}&lt;/h1&gt;<br>
  &lt;p&gt;{{description}}&lt;/p&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;<br>
</code><br>
</p>

<p><em>app.js</em>:</p>

<p><code>javascript<br>
app.get(&#39;/&#39;, function(req, res) {<br>
  var title = &#39;Swig Primer!&#39;<br>
  var description = &#39;Swig is &quot;a simple, powerful, and extendable JavaScript Template Engine&quot; for NodeJS.&#39;<br>
  res.render(&#39;index.html&#39;, {title: title, description: description});<br>
});<br>
</code></p>

<p>Keep in mind that all variable outputs are <a href="http://paularmstrong.github.io/swig/docs/api/#SwigOpts">automtomatically escaped</a> except for function outputs:</p>

<p><code>javascript<br>
// *** main routes *** //<br>
app.get(&#39;/&#39;, function(req, res) {<br>
  var title = &#39;Swig Primer!&#39;<br>
  var description = &#39;Swig is &quot;a simple, powerful, and extendable JavaScript Template Engine&quot; for NodeJS.&#39;<br>
  function allthethings() {<br>
    return &#39;&lt;span&gt;All the things!&lt;/span&gt;&#39;;<br>
  }<br>
  res.render(&#39;index.html&#39;, {<br>
    title: title,<br>
    description: description,<br>
    allthethings: allthethings<br>
  });<br>
});<br>
</code></p>

<p>Don&#39;t forget to call the function in the template - <code>&lt;p&gt;&lt;/p&gt;</code></p>

<blockquote>
<p>Please see the official <a href="http://paularmstrong.github.io/swig/docs/#variables">documentation</a> for more info on output tags.</p>
</blockquote>

<h3>Filters</h3>

<p>Filters, which are just simple methods, can be used to modify the output value. To illustrate some examples, add another route handler to <em>app.js</em>, like so:</p>

<p><code>javascript<br>
app.get(&#39;/filter&#39;, function(req, res) {<br>
  res.render(&#39;filter.html&#39;, {<br>
    title: &#39;Hello, World!&#39;,<br>
    date: new Date(),<br>
    nameArray: [&#39;This&#39;, &#39;is&#39;, &#39;just&#39;, &#39;an&#39;, &#39;example&#39;]<br>
  });<br>
});<br>
</code></p>

<p>Now just add a new template, <em>filter.html</em>, adding in a number of filters:</p>

<p><br>
<code>html<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
  &lt;title&gt;{{title}}&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  &lt;h1&gt;{{title | upper}}&lt;/h1&gt;<br>
  &lt;p&gt;{{date | date(&quot;Y-m-d&quot;)}}&lt;/p&gt;<br>
  &lt;p&gt;{{nameArray | join(&#39; &#39;)}}&lt;/p&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;<br>
</code><br>
</p>

<blockquote>
<p>Check out all the available <a href="http://paularmstrong.github.io/swig/docs/filters/">filters</a>. You can also extend the functionality of Swig by adding your own <a href="http://paularmstrong.github.io/swig/docs/extending/">custom filters</a>!</p>
</blockquote>

<h2>Logic Tags</h2>

<p>As the name suggests, <a href="http://paularmstrong.github.io/swig/docs/tags/">logic tags</a> let you use, well, logic in your templates.</p>

<h3>IF statements</h3>

<p>Here&#39;s a simple example...</p>

<p><em>app.js</em>:</p>

<p><code>javascript<br>
app.get(&#39;/logic&#39;, function(req, res) {<br>
  var title = &#39;Swig Logic!&#39;<br>
  res.render(&#39;logic.html&#39;, {title: title});<br>
});<br>
</code></p>

<p><em>logic.html</em>:</p>

<p><code>html<br>
<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
  &lt;title&gt;{% if title %}{{title}}{% endif %}&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  {% if title %}<br>
    &lt;h1&gt;{{title}}&lt;/h1&gt;<br>
  {% endif %}<br>
&lt;/body&gt;<br>
&lt;/html&gt;<br>
<br>
</code></p>

<p><strong>Test out some more examples of <a href="http://paularmstrong.github.io/swig/docs/tags/#if">if</a>, <a href="http://paularmstrong.github.io/swig/docs/tags/#elif">elif</a>, and <a href="http://paularmstrong.github.io/swig/docs/tags/#else">else</a>.</strong></p>

<h3>Loops</h3>

<p><strong>How about a for loop?</strong></p>

<p><em>app.js</em>:</p>

<p><code>javascript<br>
app.get(&#39;/logic&#39;, function(req, res) {<br>
  var title = &#39;Swig Logic!&#39;<br>
  var numberArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>
  res.render(&#39;logic.html&#39;, {title: title, numberArray: numberArray});<br>
});<br>
</code></p>

<p><em>logic.html</em>:</p>

<p><br>
<code>html<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
  &lt;title&gt;{% if title %}{{title}}{% endif %}&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  {% if title %}<br>
    &lt;h1&gt;{{title}}&lt;/h1&gt;<br>
  {% endif %}<br>
  &lt;ul&gt;<br>
    {% for num in numberArray %}<br>
      &lt;li&gt;{{ num }}&lt;/li&gt;<br>
    {% endfor %}<br>
  &lt;/ul&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;<br>
</code><br>
</p>

<p><strong>Need to reverse the loop?</strong></p>

<p>Simply add a filter:</p>

<p><br>
<code>html<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
  &lt;title&gt;{% if title %}{{title}}{% endif %}&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  {% if title %}<br>
    &lt;h1&gt;{{title}}&lt;/h1&gt;<br>
  {% endif %}<br>
  &lt;ul&gt;<br>
    {% for num in numberArray | reverse %}<br>
      &lt;li&gt;{{ num }}&lt;/li&gt;<br>
    {% endfor %}<br>
  &lt;/ul&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;<br>
</code><br>
</p>

<p><strong>What would a basic loop and filter look like?</strong></p>

<p><br>
<code>html<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
  &lt;title&gt;{% if title %}{{title}}{% endif %}&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  {% if title %}<br>
    &lt;h1&gt;{{title}}&lt;/h1&gt;<br>
  {% endif %}<br>
  &lt;ul&gt;<br>
    {% for num in numberArray %}<br>
      {% if num % 2 === 0 %}<br>
        &lt;li&gt;{{ num }}&lt;/li&gt;<br>
      {% endif %}<br>
    {% endfor %}<br>
  &lt;/ul&gt;<br>
&lt;/body&gt;<br>
&lt;/html&gt;<br>
</code><br>
</p>

<blockquote>
<p>You could also write a custom filter for this if you needed to do the <em>same</em> filtering logic a number of times throughout your application.</p>
</blockquote>

<p>There&#39;s also a number of <a href="http://paularmstrong.github.io/swig/docs/tags/#for">helper methods</a> available with loops:</p>

<ul>
<li><code>loop.index</code> returns the current iteration of the loop (1-indexed)</li>
<li><code>loop.index0</code> returns the current iteration of the loop (0-indexed)</li>
<li><code>loop.revindex</code> returns the number of iterations from the end of the loop (1-indexed)</li>
<li><code>loop.revindex0</code> returns the number of iterations from the end of the loop (0-indexed)</li>
<li><code>loop.key</code> returns the key of the current item, if the iterator is an object; otherwise it will operate the same as <code>loop.index</code></li>
<li><code>loop.first</code> returns true if the current object is the first in the object or array.</li>
<li><code>loop.last</code> returns true if the current object is the last in the object or array.</li>
</ul>

<p>Try some of these out:</p>

<p><br>
<code>html<br>
{% for num in numberArray | reverse %}<br>
  {% if num % 2 === 0 %}<br>
    &lt;li&gt;{{ num }} - {{loop.index}}&lt;/li&gt;<br>
  {% endif %}<br>
{% endfor %}<br>
</code><br>
</p>

<h2>Template Inheritence</h2>

<p>Logic tags can also be used to extend common code from a base template to child templates. You can use the <code>block</code> tag to accomplish this.</p>

<p>Create a new HTML file called <em>layout.html</em>:</p>

<p><br>
<code>html<br>
&lt;!DOCTYPE html&gt;<br>
&lt;html&gt;<br>
&lt;head&gt;<br>
  &lt;title&gt;{{title}}&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
  {% block content %}{% endblock %}<br>
&lt;/body&gt;<br>
&lt;/html&gt;<br>
</code><br>
</p>

<p>Did you notice the <code>{% block content %}{% endblock %}</code> tags? These are like placeholders that child templates fill in.</p>

<p>Add another new file called <em>test.html</em>:</p>

<p><br>
<code>html<br>
{% extends &quot;layout.html&quot; %}<br>
{% block content %}<br>
  &lt;h3&gt; This is the start of a child template&lt;/h3&gt;<br>
{% endblock %}<br>
</code><br>
</p>

<p>Finally, add a route handler to <em>app.js</em>:</p>

<p><br>
<code>html<br>
{% extends &quot;layout.html&quot; %}<br>
{% block content %}<br>
  &lt;h1&gt;This is the start of a child template&lt;/h1&gt;<br>
  &lt;h1&gt;{{title}}&lt;/h1&gt;<br>
{% endblock %}<br>
</code><br>
</p>

<p>So, the blocks -  <code>{% block content %}{% endblock %}</code> correspond to the block placeholders from the layout file, and since this file extends from the layout, the content defined here is placed in the corresponding placeholders in the layout.</p>

<h2>Conclusion</h2>

<p>Check the <a href="http://paularmstrong.github.io/swig/">documentation</a> for more info. Add your questions below. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling User Authentication with the MEAN Stack]]></title>
    <link href="http://mjhea0.github.com/blog/2015/07/02/handling-user-authentication-with-the-mean-stack/"/>
    <updated>2015-07-02T07:04:00-06:00</updated>
    <id>http://mjhea0.github.com/blog/2015/07/02/handling-user-authentication-with-the-mean-stack</id>
    <content type="html"><![CDATA[<div style="text-align:center;">
  <img src="http://mjhea0.github.com/images/mean-auth.png" style="max-width: 100%; border:0;" alt="mean stack authentication">
</div>

<p><br></p>

<p><strong>This post provides a solution to the question, &quot;How do I handle user authentication with the MEAN Stack - MongoDB, ExpressJS, AngularJS, NodeJS?&quot;.</strong></p>

<blockquote>
<p>Much of this post is ported from <a href="https://realpython.com/blog/python/handling-user-authentication-with-angular-and-flask/">Handling User Authentication with Angular and Flask</a>.</p>
</blockquote>

<p>Keep in mind that this solution posed in this tutorial is not the <em>only</em> solution to the question at hand, and it may not even be the <em>right</em> solution for your situation. Regardless of the solution you implement, it is important to note that since end users have full control of the browser as well as access to the front-end code, sensitive data living in your server-side API must be secure. In other words, make certain that you implement an authentication strategy on the server-side to protect sensitive API endpoints.</p>

<p>That said, we need to enable the following workflow:</p>

<ol>
<li>When the client accesses the main route, an index page is served, at which point Angular takes over.</li>
<li>The Angular app immediately &quot;asks&quot; the server if a user is logged in.</li>
<li>Assuming the server indicates that a user is not logged in, the client is immediately asked to log in.</li>
<li>Once logged in, the Angular app then tracks the user&#39;s login status.</li>
</ol>

<blockquote>
<p>This tutorial uses <a href="http://docs.mongodb.org/v2.6/">MongoDB</a> v2.6.7, <a href="http://expressjs.com/4x/api.html">ExpressJS</a> v4.9.8, <a href="https://code.angularjs.org/1.3.15/docs/guide">AngularJS</a> v1.3.15, <a href="https://nodejs.org/">NodeJS</a> v0.12.2, and <a href="https://github.com/jaredhanson/passport-local">Passport-Local</a> v1.0.0. For a full list of dependencies, please view the <em><a href="https://github.com/mjhea0/mean-auth/blob/master/package.json">package.json</a></em> file.</p>
</blockquote>

<h2>Getting Started</h2>

<p>First, grab the boilerplate code from the <a href="https://github.com/mjhea0/mean-auth/releases/tag/v1">project repo</a>, install the requirements, and then test out the app:</p>

<p><code>sh<br>
$ npm start<br>
</code></p>

<p>Navigate to <a href="http://localhost:3000/">http://localhost:3000/</a> and you should see a simple welcome message - &quot;Yo!&quot;. Once you&#39;re finishing admiring the page, kill the server, and glance over the code within the project folder:</p>

<p><code>sh<br>
├── client<br>
│   ├── index.html<br>
│   ├── main.js<br>
│   └── partials<br>
│       └── home.html<br>
├── package.json<br>
└── server<br>
    ├── app.js<br>
    ├── models<br>
    │   └── user.js<br>
    ├── routes<br>
    │   └── api.js<br>
    └── server.js<br>
</code></p>

<p>Nothing too spectacular. You can see that the back-end code resides in the &quot;server&quot; folder, while the front-end code lives in the &quot;client&quot; folder. Explore the files and folder within each.</p>

<h2>Login API</h2>

<p>Let&#39;s start with the back-end API. This is already built out, for your convenience. Why? The focus is mainly on the client-side. If you&#39;re looking for a back-end tutorial for setting up Passport with NodeJS, ExpressJS, and MongoDB take a look at this <a href="http://mherman.org/blog/2015/01/31/local-authentication-with-passport-and-express-4/#.VZCK9xNViko">tutorial</a>.</p>

<h3>User Registration</h3>

<p>Open the &quot;routes&quot; folder and find the following code:</p>

<p><code>javascript<br>
router.post(&#39;/register&#39;, function(req, res) {<br>
  User.register(new User({ username: req.body.username }), req.body.password, function(err, account) {<br>
    if (err) {<br>
      return res.status(500).json({err: err});<br>
    }<br>
    passport.authenticate(&#39;local&#39;)(req, res, function () {<br>
      return res.status(200).json({status: &#39;Registration successful!&#39;});<br>
    });<br>
  });<br>
});<br>
</code></p>

<p>Here, we grab the values from the payload sent with the POST request (from the client-side), create a new <code>User</code> instance, and then attempt to add the instance to the database. If this succeeds a user is added, of course, and then we return a JSON response with a <code>status</code> of &quot;success&quot;. If it fails, an &quot;error&quot; response is sent.</p>

<p>Let&#39;s test this via curl. Fire up the server and then run the following command:</p>

<p><code>sh<br>
$ curl -H &quot;Accept: application/json&quot; -H &quot;Content-type: application/json&quot; -X POST \<br>
-d &#39;{&quot;username&quot;: &quot;test@test.com&quot;, &quot;password&quot;: &quot;test&quot;}&#39; http://localhost:3000/user/register<br>
</code></p>

<p>You should see a success message:</p>

<p><code>sh<br>
{&quot;status&quot;:&quot;Registration successful!&quot;}<br>
</code></p>

<p>Try it again, with the exact same username and password, and you should see an error:</p>

<p><code>sh<br>
{&quot;err&quot;:{&quot;name&quot;:&quot;BadRequestError&quot;,&quot;message&quot;:&quot;User already exists with username test@test.com&quot;}}<br>
</code></p>

<p>On to the login...</p>

<h3>User Login</h3>

<p><code>javascript<br>
router.post(&#39;/login&#39;, function(req, res, next) {<br>
  passport.authenticate(&#39;local&#39;, function(err, user, info) {<br>
    if (err) {<br>
      return res.status(500).json({err: err});<br>
    }<br>
    if (!user) {<br>
      return res.status(401).json({err: info});<br>
    }<br>
    req.logIn(user, function(err) {<br>
      if (err) {<br>
        return res.status(500).json({err: &#39;Could not log in user&#39;});<br>
      }<br>
      res.status(200).json({status: &#39;Login successful!&#39;});<br>
    });<br>
  })(req, res, next);<br>
});<br>
</code></p>

<p>This utilizes Passport&#39;s <a href="https://github.com/jaredhanson/passport-local">local strategy</a> to verify the username/email as well as the password. The appropriate response is then returned.</p>

<p>With the server running, test again with curl-</p>

<p><code>sh<br>
curl -H &quot;Accept: application/json&quot; -H &quot;Content-type: application/json&quot; -X POST \<br>
-d &#39;{&quot;username&quot;: &quot;test@test.com&quot;, &quot;password&quot;: &quot;test&quot;}&#39; http://localhost:3000/user/login<br>
</code></p>

<p>-and you should see:</p>

<p><code>sh<br>
{&quot;message&quot;:&quot;Login successful!&quot;}<br>
</code></p>

<p>Test again with curl, sending the wrong password, and you should see:</p>

<p><code>sh<br>
{&quot;err&quot;:{&quot;status&quot;:&quot;Incorrect password&quot;}}<br>
</code></p>

<p>Perfect!</p>

<h3>User Logout</h3>

<p>Finally, take a look at the logout:</p>

<p><code>javascript<br>
router.get(&#39;/logout&#39;, function(req, res) {<br>
  req.logout();<br>
  res.status(200).json({status: &#39;Bye!&#39;});<br>
});<br>
</code></p>

<p>This should be straightforward, and you can probably guess what the response will look like - but let&#39;s test it  again:</p>

<p><code>javascript<br>
$ curl -H &quot;Accept: application/json&quot; -H &quot;Content-type: application/json&quot; -X GET \<br>
http://localhost:3000/user/logout<br>
</code></p>

<p>You should see:</p>

<p><code>sh<br>
{&quot;status&quot;:&quot;Bye!&quot;}<br>
</code></p>

<p>On to the client-side!</p>

<h2>Angular App</h2>

<p>Before diving in, remember that since end users have full access to the power of the browser as well as <a href="https://developer.chrome.com/devtools">DevTools</a> and the client-side code, it&#39;s vital that you not only restrict access to sensitive endpoints on the server-side - but that you also do not store sensitive data on the client-side. Keep this in mind as you add auth functionality to your own MEAN application stack.</p>

<h3>Client-side Routing</h3>

<p>Let&#39;s add the remainder of the client-side routes to the <em>main.js</em> file:</p>

<p><code>javascript<br>
myApp.config(function ($routeProvider) {<br>
  $routeProvider<br>
    .when(&#39;/&#39;, {templateUrl: &#39;partials/home.html&#39;})<br>
    .when(&#39;/login&#39;, {templateUrl: &#39;partials/login.html&#39;, controller: &#39;loginController&#39;})<br>
    .when(&#39;/logout&#39;, {controller: &#39;logoutController&#39;})<br>
    .when(&#39;/register&#39;, {templateUrl: &#39;partials/register.html&#39;, controller: &#39;registerController&#39;})<br>
    .when(&#39;/one&#39;, {template: &#39;&lt;h1&gt;This is page one!&lt;/h1&gt;&#39;})<br>
    .when(&#39;/two&#39;, {template: &#39;&lt;h1&gt;This is page two!&lt;/h1&gt;&#39;})<br>
    .otherwise({redirectTo: &#39;/&#39;});<br>
});<br>
</code></p>

<p>Here, we created five new routes. Before we add the subsequent templates and controllers, let&#39;s create a <a href="https://docs.angularjs.org/guide/services">service</a> to handle authentication.</p>

<h3>Authentication Service</h3>

<p>Start by adding the basic structure of the service to a new file called <em>services.js</em> in the &quot;client&quot; directory:</p>

<p>```javascript<br>
angular.module(&#39;myApp&#39;).factory(&#39;AuthService&#39;,<br>
  [&#39;$q&#39;, &#39;$timeout&#39;, &#39;$http&#39;,<br>
  function ($q, $timeout, $http) {</p>
<div class="highlight"><pre><code class="text">// create user variable
var user = null;

// return available functions for use in controllers
return ({
  isLoggedIn: isLoggedIn,
  getUserStatus: getUserStatus,
  login: login,
  logout: logout,
  register: register
});
</code></pre>
</div>

<p>}]);<br>
```</p>

<p>Here, we simply defined the service name, <code>AuthService</code>, and then injected the dependencies that we will be using - <code>$q</code>, <code>$timeout</code>, <code>$http</code> - and then returned the functions, which we still need to write, for use outside the service.</p>

<p>Make sure to add the script to the <em>index.html</em> file:</p>

<p><code>html<br>
&lt;script src=&quot;./services.js&quot;&gt;&lt;/script&gt;<br>
</code></p>

<p>Let&#39;s create each function...</p>

<p><strong><code>isLoggedIn()</code></strong></p>

<p><code>javascript<br>
function isLoggedIn() {<br>
  if(user) {<br>
    return true;<br>
  } else {<br>
    return false;<br>
  }<br>
}<br>
</code></p>

<p>This function returns <code>true</code> if <code>user</code> evaluates to <code>true</code> - a user is logged in - otherwise it returns false.</p>

<p><strong><code>getUserStatus()</code></strong></p>

<p><code>javascript<br>
function getUserStatus() {<br>
  return user;<br>
}<br>
</code></p>

<p><strong><code>login()</code></strong></p>

<p>```javascript<br>
function login(username, password) {</p>

<p>// create a new instance of deferred<br>
  var deferred = $q.defer();</p>

<p>// send a post request to the server<br>
  $http.post(&#39;/user/login&#39;, {username: username, password: password})<br>
    // handle success<br>
    .success(function (data, status) {<br>
      if(status === 200 &amp;&amp; data.status){<br>
        user = true;<br>
        deferred.resolve();<br>
      } else {<br>
        user = false;<br>
        deferred.reject();<br>
      }<br>
    })<br>
    // handle error<br>
    .error(function (data) {<br>
      user = false;<br>
      deferred.reject();<br>
    });</p>

<p>// return promise object<br>
  return deferred.promise;</p>

<p>}<br>
```</p>

<p>Here, we used the <a href="https://docs.angularjs.org/1.3.15/docs/api/ng/service/$q">$q</a> service to set up a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>, which we&#39;ll access in a future controller. We also utilized the <a href="https://docs.angularjs.org/1.3.15/docs/api/ng/service/$http">$http</a> service to send an AJAX request to the <code>/api/login</code> endpoint that we already set up in our back-end Node/Express app.</p>

<p>Based on the returned response, we either <a href="https://code.angularjs.org/1.3.15/docs/api/ng/service/$q#usage">resolve</a> or <a href="https://code.angularjs.org/1.3.15/docs/api/ng/service/$q#usage">reject</a> and set the value of <code>user</code> to <code>true</code> or <code>false</code>.</p>

<p><strong><code>logout()</code></strong></p>

<p>```javascript<br>
function logout() {</p>

<p>// create a new instance of deferred<br>
  var deferred = $q.defer();</p>

<p>// send a get request to the server<br>
  $http.get(&#39;/user/logout&#39;)<br>
    // handle success<br>
    .success(function (data) {<br>
      user = false;<br>
      deferred.resolve();<br>
    })<br>
    // handle error<br>
    .error(function (data) {<br>
      user = false;<br>
      deferred.reject();<br>
    });</p>

<p>// return promise object<br>
  return deferred.promise;</p>

<p>}<br>
```</p>

<p>Here, we followed the same formula as the <code>login()</code> function, except we sent a GET request rather than a POST and to be save we just went ahead and handled the error the same as the success.</p>

<p><strong><code>register()</code></strong></p>

<p>```javascript<br>
function register(username, password) {</p>

<p>// create a new instance of deferred<br>
  var deferred = $q.defer();</p>

<p>// send a post request to the server<br>
  $http.post(&#39;/user/register&#39;, {username: username, password: password})<br>
    // handle success<br>
    .success(function (data, status) {<br>
      if(status === 200 &amp;&amp; data.status){<br>
        deferred.resolve();<br>
      } else {<br>
        deferred.reject();<br>
      }<br>
    })<br>
    // handle error<br>
    .error(function (data) {<br>
      deferred.reject();<br>
    });</p>

<p>// return promise object<br>
  return deferred.promise;</p>

<p>}<br>
```</p>

<p>Again, we followed a similar formula to the <code>logout()</code> function. Can you tell what&#39;s happening?</p>

<p>That&#39;s it for the service. Keep in mind that we still have not &quot;used&quot; this service. In order to that we just need to inject it into the necessary components in the Angular app. In our case, that will be the controllers, which we&#39;ll build next.</p>

<h3>Templates and Controllers</h3>

<p>Looking back at our routes, we need to setup two partials/templates and three controllers:</p>

<p><code>javascript<br>
.when(&#39;/login&#39;, {templateUrl: &#39;partials/login.html&#39;, controller: &#39;loginController&#39;})<br>
.when(&#39;/logout&#39;, {controller: &#39;logoutController&#39;})<br>
.when(&#39;/register&#39;, {templateUrl: &#39;partials/register.html&#39;, controller: &#39;registerController&#39;})<br>
</code></p>

<p><strong>Login</strong></p>

<p>First, add the following HTML to a new file called <em>login.html</em>:</p>

<p><code>html<br>
&lt;div class=&quot;col-md-4&quot;&gt;<br>
  &lt;h1&gt;Login&lt;/h2&gt;<br>
  &lt;div ng-show=&quot;error&quot; class=&quot;alert alert-danger&quot;&gt;&lt;/div&gt;<br>
  &lt;form class=&quot;form&quot; ng-submit=&quot;login()&quot;&gt;<br>
    &lt;div class=&quot;form-group&quot;&gt;<br>
      &lt;label&gt;Username&lt;/label&gt;<br>
      &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; ng-model=&quot;loginForm.username&quot; required&gt;<br>
    &lt;/div&gt;<br>
    &lt;div class=&quot;form-group&quot;&gt;<br>
      &lt;label&gt;Password&lt;/label&gt;<br>
        &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; ng-model=&quot;loginForm.password&quot; required&gt;<br>
      &lt;/div&gt;<br>
      &lt;div&gt;<br>
        &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot; ng-disabled=&quot;disabled&quot;&gt;Login&lt;/button&gt;<br>
      &lt;/div&gt;<br>
  &lt;/form&gt;<br>
&lt;/div&gt;<br>
</code></p>

<p>Add this file to the &quot;partials&quot; directory.</p>

<p>Take note of the form. We used the <a href="https://code.angularjs.org/1.3.15/docs/api/ng/directive/ngModel">ng-model</a> directive on each of the inputs so that we can capture those values in the controller. Also, when the form is submitted, the <a href="https://code.angularjs.org/1.3.15/docs/api/ng/directive/ngSubmit">ng-submit</a> directive handles the event by firing the <code>login()</code> function.</p>

<p>Next, within the &quot;client&quot; folder, add a new file called <em>controllers.js</em>. Yes, this will hold all of our Angular app&#39;s controllers. Don&#39;t forget to add the script to the <em>index.html</em> file:</p>

<p><code>html<br>
&lt;script src=&quot;./controllers.js&quot;&gt;&lt;/script&gt;<br>
</code></p>

<p>Now, let&#39;s add the first controller:</p>

<p>```javascript<br>
angular.module(&#39;myApp&#39;).controller(&#39;loginController&#39;,<br>
  [&#39;$scope&#39;, &#39;$location&#39;, &#39;AuthService&#39;,<br>
  function ($scope, $location, AuthService) {</p>
<div class="highlight"><pre><code class="text">console.log(AuthService.getUserStatus());

$scope.login = function () {

  // initial values
  $scope.error = false;
  $scope.disabled = true;

  // call login from service
  AuthService.login($scope.loginForm.username, $scope.loginForm.password)
    // handle success
    .then(function () {
      $location.path(&#39;/&#39;);
      $scope.disabled = false;
      $scope.loginForm = {};
    })
    // handle error
    .catch(function () {
      $scope.error = true;
      $scope.errorMessage = &quot;Invalid username and/or password&quot;;
      $scope.disabled = false;
      $scope.loginForm = {};
    });

};
</code></pre>
</div>

<p>}]);<br>
```</p>

<p>So, when the <code>login()</code> function is fired, we set some initial values and then call <code>login()</code> from the <code>AuthService</code>, passing the user inputed email and password as arguments. The subsequent success or error is then handled and the DOM/view/template is updated appropriately.</p>

<p>Did you notice how we logged the return value of <code>AuthService.getUserStatus()</code> to the console? This is to ensure that the value is correct based on whether a user is logged in or out - <code>true</code> or <code>false</code>, respectively.</p>

<p>Ready to test the first round-trip - client =&gt; server =&gt; client?</p>

<p>Fire up the server and navigate to <a href="http://localhost:3000/#/login">http://localhost:3000/#/login</a> in your browser. First, try logging in with the user credentials used to register earlier - e.g, <code>test@test.com</code> and <code>test</code>, respectively. If all went well, you should be redirected to the main URL. Next, try to log in using invalid credentials. You should see the error message flash, &quot;Invalid username and/or password&quot;.</p>

<p><strong>Logout</strong></p>

<p>Add the controller:</p>

<p>```javascript<br>
angular.module(&#39;myApp&#39;).controller(&#39;logoutController&#39;,<br>
  [&#39;$scope&#39;, &#39;$location&#39;, &#39;AuthService&#39;,<br>
  function ($scope, $location, AuthService) {</p>
<div class="highlight"><pre><code class="text">$scope.logout = function () {

  console.log(AuthService.getUserStatus());

  // call logout from service
  AuthService.logout()
    .then(function () {
      $location.path(&#39;/login&#39;);
    });

};
</code></pre>
</div>

<p>}]);<br>
```</p>

<p>Here, we called <code>AuthService.logout()</code> and then redirected the user to the <code>/login</code> route after the promise is resolved.</p>

<p>Add a button to <em>home.html</em>:</p>

<p><code>html<br>
&lt;div ng-controller=&quot;logoutController&quot;&gt;<br>
  &lt;a ng-click=&#39;logout()&#39; class=&quot;btn btn-default&quot;&gt;Logout&lt;/a&gt;<br>
&lt;/div&gt;<br>
</code></p>

<p>And then test it out again.</p>

<p><strong>Register</strong></p>

<p>Add a new new file called <em>register.html</em> to the &quot;partials&quot; folder and add the following HTML:</p>

<p><code>html<br>
&lt;div class=&quot;col-md-4&quot;&gt;<br>
  &lt;h1&gt;Register&lt;/h2&gt;<br>
  &lt;div ng-show=&quot;error&quot; class=&quot;alert alert-danger&quot;&gt;&lt;/div&gt;<br>
  &lt;form class=&quot;form&quot; ng-submit=&quot;register()&quot;&gt;<br>
    &lt;div class=&quot;form-group&quot;&gt;<br>
      &lt;label&gt;Username&lt;/label&gt;<br>
      &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; ng-model=&quot;registerForm.username&quot; required&gt;<br>
    &lt;/div&gt;<br>
    &lt;div class=&quot;form-group&quot;&gt;<br>
      &lt;label&gt;Password&lt;/label&gt;<br>
        &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; ng-model=&quot;registerForm.password&quot; required&gt;<br>
      &lt;/div&gt;<br>
      &lt;div&gt;<br>
        &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot; ng-disabled=&quot;disabled&quot;&gt;Register&lt;/button&gt;<br>
      &lt;/div&gt;<br>
  &lt;/form&gt;<br>
&lt;/div&gt;<br>
</code></p>

<p>Next, add the controller:</p>

<p>```javascript<br>
angular.module(&#39;myApp&#39;).controller(&#39;registerController&#39;,<br>
  [&#39;$scope&#39;, &#39;$location&#39;, &#39;AuthService&#39;,<br>
  function ($scope, $location, AuthService) {</p>
<div class="highlight"><pre><code class="text">console.log(AuthService.getUserStatus());

$scope.register = function () {

  // initial values
  $scope.error = false;
  $scope.disabled = true;

  // call register from service
  AuthService.register($scope.registerForm.username, $scope.registerForm.password)
    // handle success
    .then(function () {
      $location.path(&#39;/login&#39;);
      $scope.disabled = false;
      $scope.registerForm = {};
    })
    // handle error
    .catch(function () {
      $scope.error = true;
      $scope.errorMessage = &quot;Something went wrong!&quot;;
      $scope.disabled = false;
      $scope.registerForm = {};
    });

};
</code></pre>
</div>

<p>}]);<br>
```</p>

<p>You&#39;ve seen this before, so let&#39;s move right on to testing.</p>

<p>Fire up the server and register a new user at <a href="http://localhost:3000/#/register">http://localhost:3000/#/register</a>. Make sure to test logging in with that new user as well.</p>

<p>Well, that&#39;s it for the templates and controllers. We now need to add in functionality to check if a user is logged in on each and every change of route.</p>

<h3>Route Changes</h3>

<p>Start by adding the following code to <em>main.js</em>:</p>

<p><code>javascript<br>
myApp.run(function ($rootScope, $location, $route, AuthService) {<br>
  $rootScope.$on(&#39;$routeChangeStart&#39;, function (event, next, current) {<br>
    if (AuthService.isLoggedIn() === false) {<br>
      $location.path(&#39;/login&#39;);<br>
    }<br>
  });<br>
});<br>
</code></p>

<p>The <a href="https://code.angularjs.org/1.3.15/docs/api/ngRoute/service/$route">$routeChangeStart</a> event happens before the actual route change occurs. So, whenever a route is accessed, before the view is served, we ensure that the user is logged in. Test this out!</p>

<h2>Route Restriction</h2>

<p>Right now all client-side routes require a user to be logged in. What if you want certain routes restricted and other routes open?</p>

<p>You can add the following code to each route handler, replacing <code>true</code> with <code>false</code> for routes that you do not want to restrict:</p>

<p><code>javascript<br>
access: {restricted: true}<br>
</code></p>

<p>For example:</p>

<p><code>javascript<br>
myApp.config(function ($routeProvider) {<br>
  $routeProvider<br>
    .when(&#39;/&#39;, {templateUrl: &#39;partials/home.html&#39;})<br>
    .when(&#39;/login&#39;, {<br>
      templateUrl: &#39;partials/login.html&#39;,<br>
      controller: &#39;loginController&#39;,<br>
      access: {restricted: false}<br>
    })<br>
    .when(&#39;/logout&#39;, {<br>
      controller: &#39;logoutController&#39;,<br>
      access: {restricted: true}<br>
    })<br>
    .when(&#39;/register&#39;, {<br>
      templateUrl: &#39;partials/register.html&#39;,<br>
      controller: &#39;registerController&#39;,<br>
      access: {restricted: true}<br>
    })<br>
    .when(&#39;/one&#39;, {<br>
      template: &#39;&lt;h1&gt;This is page one!&lt;/h1&gt;&#39;,<br>
      access: {restricted: true}<br>
    })<br>
    .when(&#39;/two&#39;, {<br>
      template: &#39;&lt;h1&gt;This is page two!&lt;/h1&gt;&#39;,<br>
      access: {restricted: false}<br>
    })<br>
    .otherwise({redirectTo: &#39;/&#39;});<br>
});<br>
</code></p>

<p>Now just update the <code>$routeChangeStart</code> code in <em>main.js</em>:</p>

<p><code>javascript<br>
myApp.run(function ($rootScope, $location, $route, AuthService) {<br>
  $rootScope.$on(&#39;$routeChangeStart&#39;, function (event, next, current) {<br>
    if (next.access.restricted &amp;&amp; AuthService.isLoggedIn() === false) {<br>
      $location.path(&#39;/login&#39;);<br>
      $route.reload();<br>
    }<br>
  });<br>
});<br>
</code></p>

<p>Test it out!</p>

<h2>Conclusion</h2>

<p>That&#39;s it. One thing you should note is that the Angular app can be used with various frameworks as long as the endpoints are set up correctly in the AJAX requests. So, you can easily take the Angular portion and add it to your Django or Pyramid or NodeJS app. Try it!</p>

<blockquote>
<p>Check out a Python/Flask app with Angular Auth <a href="https://realpython.com/blog/python/handling-user-authentication-with-angular-and-flask/">here</a></p>
</blockquote>

<p>Grab the final code from the <a href="https://github.com/mjhea0/mean-auth">repo</a>. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[User Authentication with Passport and Express 4]]></title>
    <link href="http://mjhea0.github.com/blog/2015/01/31/local-authentication-with-passport-and-express-4/"/>
    <updated>2015-01-31T07:07:00-07:00</updated>
    <id>http://mjhea0.github.com/blog/2015/01/31/local-authentication-with-passport-and-express-4</id>
    <content type="html"><![CDATA[<p>This post demonstrate how to add user authentication to Node/Express with Passport.js.</p>

<blockquote>
<p>If you&#39;re interested in social authentication via Passport, please check out <a href="http://mherman.org/blog/2013/11/10/social-authentication-with-passport-dot-js/">this</a> blog post. Looking for an Express 3 authentication tutorial? Check out this <a href="http://mherman.org/blog/2013/11/11/user-authentication-with-passport-dot-js/">post</a>.</p>
</blockquote>

<p>Before you start, make sure you have <a href="http://nodejs.org/download/">Node</a> installed for your specific operating system. This tutorial also uses the following tools/technologies:</p>

<ul>
<li><a href="https://www.npmjs.com/package/express">Express</a> v4.11.1</li>
<li><a href="https://www.npmjs.com/package/mongoose">Mongoose</a> v3.8.22</li>
<li><a href="https://www.npmjs.com/package/passport">Passport</a> v0.2.1</li>
<li><a href="https://www.npmjs.com/package/passport-local">Passport-local</a>: v1.0.0</li>
<li><a href="https://www.npmjs.com/package/passport-local-mongoose">Passport-local-mongoose</a>: v1.0.0</li>
</ul>

<h2>Project Setup</h2>

<p>Start by installing the Express generator, which we&#39;ll use to generate a basic project boilerplate:</p>

<p><code>sh<br>
$ npm install -g express-generator@4<br>
</code></p>

<blockquote>
<p>The <code>-g</code> flag means that we&#39;re installing this globally, on our entire system.</p>
</blockquote>

<p>Navigate to a convenient directory, like your &quot;Desktop&quot; or &quot;Documents&quot;, then create your app:</p>

<p><code>sh<br>
$ express passport-local-express4<br>
</code></p>

<p>Check out the project structure:</p>

<p><code><br>
├── app.js<br>
├── bin<br>
│   └── www<br>
├── package.json<br>
├── public<br>
│   ├── images<br>
│   ├── javascripts<br>
│   └── stylesheets<br>
│       └── style.css<br>
├── routes<br>
│   ├── index.js<br>
│   └── users.js<br>
└── views<br>
    ├── error.jade<br>
    ├── index.jade<br>
    └── layout.jade<br>
</code></p>

<p>This took care of the heavy lifting, adding common files and functions associated with all apps.</p>

<h3>Install/Update Dependencies</h3>

<p>Update the <em>package.json</em> file to reference the correct dependencies:</p>

<p><code>json<br>
{<br>
  &quot;name&quot;: &quot;passport-local-express4&quot;,<br>
  &quot;version&quot;: &quot;0.0.0&quot;,<br>
  &quot;private&quot;: true,<br>
  &quot;scripts&quot;: {<br>
    &quot;start&quot;: &quot;node ./bin/www&quot;<br>
  },<br>
  &quot;repository&quot;: {<br>
    &quot;type&quot;: &quot;git&quot;,<br>
    &quot;url&quot;: &quot;git@github.com:mjhea0/passport-local-express4.git&quot;<br>
  },<br>
  &quot;author&quot;: &quot;Michael Herman &lt;michael@mherman.org&gt;&quot;,<br>
  &quot;license&quot;: &quot;MIT&quot;,<br>
  &quot;dependencies&quot;: {<br>
    &quot;body-parser&quot;: &quot;^1.10.2&quot;,<br>
    &quot;chai&quot;: &quot;~1.8.1&quot;,<br>
    &quot;cookie-parser&quot;: &quot;^1.3.3&quot;,<br>
    &quot;express&quot;: &quot;^4.11.1&quot;,<br>
    &quot;express-session&quot;: &quot;^1.10.1&quot;,<br>
    &quot;jade&quot;: &quot;^1.9.1&quot;,<br>
    &quot;mocha&quot;: &quot;~1.14.0&quot;,<br>
    &quot;mongoose&quot;: &quot;^3.8.22&quot;,<br>
    &quot;morgan&quot;: &quot;^1.5.1&quot;,<br>
    &quot;passport&quot;: &quot;^0.2.1&quot;,<br>
    &quot;passport-local&quot;: &quot;^1.0.0&quot;,<br>
    &quot;passport-local-mongoose&quot;: &quot;^1.0.0&quot;,<br>
    &quot;should&quot;: &quot;~2.1.0&quot;,<br>
    &quot;serve-favicon&quot;: &quot;^2.2.0&quot;,<br>
    &quot;debug&quot;: &quot;^2.1.1&quot;<br>
  }<br>
}<br>
</code></p>

<p>Now install the dependencies:</p>

<p><code>sh<br>
$ cd express-local-express4<br>
$ npm install<br>
</code></p>

<h3>Sanity Check</h3>

<p>Let&#39;s test our setup by running the app:</p>

<p><code>sh<br>
$ node ./bin/www<br>
</code></p>

<p>Navigate to <a href="http://localhost:3000/">http://localhost:3000/</a> in your browser and you should see the &quot;Welcome to Express&quot; text staring back.</p>

<h3>Setup MongoDB</h3>

<p>Install:</p>

<p><code>sh<br>
$ npm install -g mongodb<br>
</code></p>

<p>Then, in a new terminal window, start the MongoDB daemon:</p>

<p><code>sh<br>
$ sudo mongod<br>
</code></p>

<h2>Edit <em>app.js</em></h2>

<h3>Update the Requirements</h3>

<p>Add the following requirements:</p>

<p><code>javascript<br>
var mongoose = require(&#39;mongoose&#39;);<br>
var passport = require(&#39;passport&#39;);<br>
var LocalStrategy = require(&#39;passport-local&#39;).Strategy;<br>
</code></p>

<h3>Update <em>app.js</em></h3>

<p>Update all of <em>app.js</em> with the following code (check the comments for a brief explanation):</p>

<p>```javascript<br>
// dependencies<br>
var express = require(&#39;express&#39;);<br>
var path = require(&#39;path&#39;);<br>
var favicon = require(&#39;serve-favicon&#39;);<br>
var logger = require(&#39;morgan&#39;);<br>
var cookieParser = require(&#39;cookie-parser&#39;);<br>
var bodyParser = require(&#39;body-parser&#39;);<br>
var mongoose = require(&#39;mongoose&#39;);<br>
var passport = require(&#39;passport&#39;);<br>
var LocalStrategy = require(&#39;passport-local&#39;).Strategy;</p>

<p>var routes = require(&#39;./routes/index&#39;);<br>
var users = require(&#39;./routes/users&#39;);</p>

<p>var app = express();</p>

<p>// view engine setup<br>
app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;));<br>
app.set(&#39;view engine&#39;, &#39;jade&#39;);</p>

<p>// uncomment after placing your favicon in /public<br>
//app.use(favicon(<strong>dirname + &#39;/public/favicon.ico&#39;));<br>
app.use(logger(&#39;dev&#39;));<br>
app.use(bodyParser.json());<br>
app.use(bodyParser.urlencoded({ extended: false }));<br>
app.use(cookieParser());<br>
app.use(require(&#39;express-session&#39;)({<br>
    secret: &#39;keyboard cat&#39;,<br>
    resave: false,<br>
    saveUninitialized: false<br>
}));<br>
app.use(passport.initialize());<br>
app.use(passport.session());<br>
app.use(express.static(path.join(</strong>dirname, &#39;public&#39;)));</p>

<p>app.use(&#39;/&#39;, routes);</p>

<p>// passport config<br>
var Account = require(&#39;./models/account&#39;);<br>
passport.use(new LocalStrategy(Account.authenticate()));<br>
passport.serializeUser(Account.serializeUser());<br>
passport.deserializeUser(Account.deserializeUser());</p>

<p>// mongoose<br>
mongoose.connect(&#39;mongodb://localhost/passport<em>local</em>mongoose_express4&#39;);</p>

<p>// catch 404 and forward to error handler<br>
app.use(function(req, res, next) {<br>
    var err = new Error(&#39;Not Found&#39;);<br>
    err.status = 404;<br>
    next(err);<br>
});</p>

<p>// error handlers</p>

<p>// development error handler<br>
// will print stacktrace<br>
if (app.get(&#39;env&#39;) === &#39;development&#39;) {<br>
    app.use(function(err, req, res, next) {<br>
        res.status(err.status || 500);<br>
        res.render(&#39;error&#39;, {<br>
            message: err.message,<br>
            error: err<br>
        });<br>
    });<br>
}</p>

<p>// production error handler<br>
// no stacktraces leaked to user<br>
app.use(function(err, req, res, next) {<br>
    res.status(err.status || 500);<br>
    res.render(&#39;error&#39;, {<br>
        message: err.message,<br>
        error: {}<br>
    });<br>
});</p>

<p>module.exports = app;<br>
```</p>

<h2>Mongoose</h2>

<p>Let&#39;s get the Mongoose up and running. Add a new file called <em>account.js</em> to a new directory called &quot;models&quot; with the following code:</p>

<p>```javascript<br>
var mongoose = require(&#39;mongoose&#39;);<br>
var Schema = mongoose.Schema;<br>
var passportLocalMongoose = require(&#39;passport-local-mongoose&#39;);</p>

<p>var Account = new Schema({<br>
    username: String,<br>
    password: String<br>
});</p>

<p>Account.plugin(passportLocalMongoose);</p>

<p>module.exports = mongoose.model(&#39;Account&#39;, Account);<br>
```</p>

<p>You may be wondering about password security, specifically salting/hashing the password. Fortunately, the <a href="https://github.com/saintedlama/passport-local-mongoose">passport-local-mongoose</a> package automatically takes care of salting and hashing the password for us. More on this further down.</p>

<h3>Sanity Check</h3>

<p>Again, test the app:</p>

<p><code>sh<br>
$ node ./bin/www<br>
</code></p>

<p>Make sure you still see the same &quot;Welcome to Express&quot; text.</p>

<h2>Add Routes</h2>

<p>Within the &quot;routes&quot; folder, add the following code to the <em>index.js</em> file:</p>

<p>```javascript<br>
var express = require(&#39;express&#39;);<br>
var passport = require(&#39;passport&#39;);<br>
var Account = require(&#39;../models/account&#39;);<br>
var router = express.Router();</p>

<p>router.get(&#39;/&#39;, function (req, res) {<br>
    res.render(&#39;index&#39;, { user : req.user });<br>
});</p>

<p>router.get(&#39;/register&#39;, function(req, res) {<br>
    res.render(&#39;register&#39;, { });<br>
});</p>

<p>router.post(&#39;/register&#39;, function(req, res) {<br>
    Account.register(new Account({ username : req.body.username }), req.body.password, function(err, account) {<br>
        if (err) {<br>
            return res.render(&#39;register&#39;, { account : account });<br>
        }</p>
<div class="highlight"><pre><code class="text">    passport.authenticate(&#39;local&#39;)(req, res, function () {
        res.redirect(&#39;/&#39;);
    });
});
</code></pre>
</div>

<p>});</p>

<p>router.get(&#39;/login&#39;, function(req, res) {<br>
    res.render(&#39;login&#39;, { user : req.user });<br>
});</p>

<p>router.post(&#39;/login&#39;, passport.authenticate(&#39;local&#39;), function(req, res) {<br>
    res.redirect(&#39;/&#39;);<br>
});</p>

<p>router.get(&#39;/logout&#39;, function(req, res) {<br>
    req.logout();<br>
    res.redirect(&#39;/&#39;);<br>
});</p>

<p>router.get(&#39;/ping&#39;, function(req, res){<br>
    res.status(200).send(&quot;pong!&quot;);<br>
});</p>

<p>module.exports = router;<br>
```</p>

<h2>Test</h2>

<p>Fire up the server. Navigate to <a href="http://localhost:3000/ping">http://localhost:3000/ping</a>. Make sure you do not get any errors and that you see the word &quot;pong!&quot;.</p>

<h2>Views</h2>

<h3><em>layout.jade</em></h3>

<p>Update:</p>

<p>```<br>
doctype html<br>
html<br>
  head<br>
    title= title<br>
    meta(name=&#39;viewport&#39;, content=&#39;width=device-width, initial-scale=1.0&#39;)<br>
    link(href=&#39;http://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css&#39;, rel=&#39;stylesheet&#39;, media=&#39;screen&#39;)<br>
    link(rel=&#39;stylesheet&#39;, href=&#39;http://mjhea0.github.com/stylesheets/style.css&#39;)<br>
  body<br>
    block content</p>

<p>script(src=&#39;http://code.jquery.com/jquery.js&#39;)<br>
  script(src=&#39;http://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js&#39;)<br>
```</p>

<h3>index.jade</h3>

<p>Update:</p>

<p>```jade<br>
extends layout</p>

<p>block content<br>
  if (!user)<br>
    a(href=&quot;/login&quot;) Login<br>
    br<br>
    a(href=&quot;/register&quot;) Register<br>
  if (user)<br>
    p You are currently logged in as #{user.username}<br>
    a(href=&quot;/logout&quot;) Logout<br>
```</p>

<h3>login.jade</h3>

<p>Add a new file called <em>login.jade</em> to the views:</p>

<p>```jade<br>
extends layout</p>

<p>block content<br>
  .container<br>
    h1 Login Page<br>
    p.lead Say something worthwhile here.<br>
    br<br>
    form(role=&#39;form&#39;, action=&quot;/login&quot;,method=&quot;post&quot;, style=&#39;max-width: 300px;&#39;)<br>
      .form-group<br>
          input.form-control(type=&#39;text&#39;, name=&quot;username&quot;, placeholder=&#39;Enter Username&#39;)<br>
      .form-group<br>
        input.form-control(type=&#39;password&#39;, name=&quot;password&quot;, placeholder=&#39;Password&#39;)<br>
      button.btn.btn-default(type=&#39;submit&#39;) Submit<br>
      &nbsp;<br>
      a(href=&#39;/&#39;)<br>
        button.btn.btn-primary(type=&quot;button&quot;) Cancel<br>
```</p>

<h3>register.jade</h3>

<p>Add another file called <em>register.jade</em> to the views:</p>

<p>```javascript<br>
extends layout</p>

<p>block content<br>
  .container<br>
    h1 Register Page<br>
    p.lead Say something worthwhile here.<br>
    br<br>
    form(role=&#39;form&#39;, action=&quot;/register&quot;,method=&quot;post&quot;, style=&#39;max-width: 300px;&#39;)<br>
      .form-group<br>
          input.form-control(type=&#39;text&#39;, name=&quot;username&quot;, placeholder=&#39;Enter Username&#39;)<br>
      .form-group<br>
        input.form-control(type=&#39;password&#39;, name=&quot;password&quot;, placeholder=&#39;Password&#39;)<br>
      button.btn.btn-default(type=&#39;submit&#39;) Submit<br>
      &nbsp;<br>
      a(href=&#39;/&#39;)<br>
        button.btn.btn-primary(type=&quot;button&quot;) Cancel<br>
```</p>

<h2>Test redux</h2>

<p>Fire up the server and test! Register, and then login.</p>

<p>Remember how I said that we&#39;d look at salting and hashing a password again? Well, let&#39;s check our Mongo database to ensure that it&#39;s working.</p>

<p>When I tested the user registration, I used &quot;michael&quot; for both my username and password.</p>

<p>Let&#39;s see what this looks like in the database:</p>

<p><code>sh<br>
$ mongo<br>
MongoDB shell version: 2.4.6<br>
connecting to: test<br>
&gt; use passport_local_mongoose_express4<br>
switched to db passport_local_mongoose_express4<br>
&gt; db.accounts.find()<br>
{ &quot;salt&quot; : &quot;9ffd63f2bcce58bf79691cacfaae678f690dd73ef778445bf79f97c41934189b&quot;, &quot;hash&quot; : &quot;17eabe62d459acdb4f3d8eaab7369a1e989c6150e231d1e87a7cf1c31dfc7eafc0616732a6db8f08c413dcbec06c95d512cef55503a1fe9a7ed5dc15ecf5cf67c114af5a659c79bb47039082a3af933e1c32dd2519b8be11596a775e1d262fd53437927e0fd948b76e738f342904a598e6c533445351c9b3d629aa118adfbe0646a80539e816c06248e353b1787dbd8c646a2ed018bbf5e58fb6a6cc1f32c6ea61b3e52230cfdf75a9f4b7ba20b3d3ae3b86f5816f5df9c48f9d1bb4a9c42e30bf646c3810d050847c1905e5a95f53c81078090e42ba58799187a61b047376def48fb640a4f48eca4c7f35610eafc2c770e61172b11c7e98c36281983de56414fa95e0708c9a6458a903baaf3818a3e4675b39418b358f51f45aca792e606f692e0a7d3667d111d00d0f521257d3486cbcff250dc7d9859ab80f9d56a3d272fb0ebb2e7dd969c0749361153c6bde62ad50b3d47233424034b959c78225db000cc1416aa0d555016f1b666d2da709e69c5030ee39753597a1d06ec0a4e001e22bff37947c1b993794d21667dc6c65e4116dd5ca216a161aa9026063e0b12e1165ffa5c827a6803df6765766cc55bcca122cd4d9f572353a988f90200ffc4a610d9eca83df01d6f30af78f9ec476fc974bc1d3a5fd2759a56486795bd7d993462a8d2f9b9c42d3197cd7b9855f17eaac4073a4d843d56b5c9a75b86cc1bb8b27ec&quot;, &quot;username&quot; : &quot;michael&quot;, &quot;_id&quot; : ObjectId(&quot;54c7bbbfaf54064909921a36&quot;), &quot;__v&quot; : 0 }<br>
&gt;<br>
</code></p>

<p>So, you can see that we have a document with five keys:</p>

<ul>
<li><code>username</code> is as we expected - &quot;michael&quot;</li>
<li><code>_id</code> pertains to the unique id associated with that document.</li>
<li><code>__v</code> is the <a href="http://mongoosejs.com/docs/guide.html#versionKey">version #</a> for that specific documents.</li>
<li>Finally, instead of a password key we have both a salt and a hash key. For more on how these are generated, please refer to the <a href="https://github.com/saintedlama/passport-local-mongoose#hash-algorithm">passport-local-mongoose</a> documentation.</li>
</ul>

<h2>Unit/Integration tests</h2>

<p>First, update the <code>scripts</code> object in <em>package.json</em>:</p>

<p><code>json<br>
&quot;scripts&quot;: {<br>
  &quot;start&quot;: &quot;node ./bin/www&quot;,<br>
  &quot;test&quot;: &quot;make test&quot;<br>
 },<br>
</code></p>

<p>Now add a Makefile to the root and include the following code:</p>

<p>```<br>
test:<br>
    @./node_modules/.bin/mocha</p>

<p>.PHONY: test<br>
```</p>

<blockquote>
<p>Take note of the spacing on the second line. This <strong>must</strong> be a tab or you will see an error.</p>
</blockquote>

<p>Create a new folder called &quot;test&quot;, and then run <code>make test</code> from the command line. If all is well, you should see - <code>0 passing (1ms)</code>. Now we just need to add some tests...</p>

<h3>Add tests</h3>

<p>Add a new file called <em>test.user.js</em> to the &quot;test folder:</p>

<p>```javascript<br>
var should = require(&quot;should&quot;);<br>
var mongoose = require(&#39;mongoose&#39;);<br>
var Account = require(&quot;../models/account.js&quot;);<br>
var db;</p>

<p>describe(&#39;Account&#39;, function() {</p>
<div class="highlight"><pre><code class="text">before(function(done) {
    db = mongoose.connect(&#39;mongodb://localhost/test&#39;);
        done();
});

after(function(done) {
    mongoose.connection.close();
    done();
});

beforeEach(function(done) {
    var account = new Account({
        username: &#39;12345&#39;,
        password: &#39;testy&#39;
    });

    account.save(function(error) {
        if (error) console.log(&#39;error&#39; + error.message);
        else console.log(&#39;no error&#39;);
        done();
    });
});

it(&#39;find a user by username&#39;, function(done) {
    Account.findOne({ username: &#39;12345&#39; }, function(err, account) {
        account.username.should.eql(&#39;12345&#39;);
        console.log(&quot;   username: &quot;, account.username);
        done();
    });
});

afterEach(function(done) {
    Account.remove({}, function() {
        done();
    });
 });
</code></pre>
</div>

<p>});<br>
```</p>

<p>Now run <code>make tests</code>. You should see that it passed - <code>1 passing (43ms)</code>.</p>

<h2>Error handling</h2>

<p>Right now we have some poorly handled errors that are confusing to the end user. For example, try to register a name that already exists, or login with a username that doesn&#39;t exist. This can and <em>should</em> be handled better.</p>

<h3>Registration</h3>

<p>First, update the <code>/register</code> route so an error is thrown, which gets sent to Jade template, if a user tries to register a username that already exists:</p>

<p>```javascript<br>
router.post(&#39;/register&#39;, function(req, res) {<br>
    Account.register(new Account({ username : req.body.username }), req.body.password, function(err, account) {<br>
        if (err) {<br>
          return res.render(&quot;register&quot;, {info: &quot;Sorry. That username already exists. Try again.&quot;});<br>
        }</p>
<div class="highlight"><pre><code class="text">    passport.authenticate(&#39;local&#39;)(req, res, function () {
        res.redirect(&#39;/&#39;);
    });
});
</code></pre>
</div>

<p>});<br>
```</p>

<p>Then add the following code to the bottom of the &quot;register.jade&quot; template:</p>

<p><code>jade<br>
br<br>
h4= info<br>
</code></p>

<p>Test this out.</p>

<p>Next, if you try to login with a username and password combo that does not exist, the user is redirected to a page with just the word &quot;Unauthorized&quot; on it. This is confusing and unhelpful. See if you can fix this on your own. Cheers!</p>

<h2>Conclusion</h2>

<p>That&#39;s it. Grab the code from the <a href="https://github.com/mjhea0/passport-local-express4">repository</a>. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node, Express, and MongoDB - a primer]]></title>
    <link href="http://mjhea0.github.com/blog/2014/12/31/node-and-mongoose-a-primer/"/>
    <updated>2014-12-31T02:28:00-07:00</updated>
    <id>http://mjhea0.github.com/blog/2014/12/31/node-and-mongoose-a-primer</id>
    <content type="html"><![CDATA[<p>Welcome. Using Node, Express, and Mongoose, let&#39;s create an interactive form.</p>

<blockquote>
<p>Before you start, make sure you have <a href="http://nodejs.org/download/">Node</a> installed for your specific operating system. This tutorial also uses <a href="http://expressjs.com/">Express</a> v4.9.0 and <a href="http://mongoosejs.com/">Mongoose</a> v3.8.21.</p>
</blockquote>

<h2>Project Setup</h2>

<p>Start by installing the Express generator, which will be used to create a basic project for us:</p>

<p><code>sh<br>
$ npm install -g express-generator@4<br>
</code></p>

<blockquote>
<p>The <code>-g</code> flag means that we&#39;re installing this on our entire system.</p>
</blockquote>

<p>Navigate to a convenient directory, like your &quot;Desktop&quot; or &quot;Documents&quot;, then create your app:</p>

<p><code>sh<br>
$ express node-mongoose-form<br>
</code></p>

<p>Check out the project structure:</p>

<p><code><br>
├── app.js<br>
├── bin<br>
│   └── www<br>
├── package.json<br>
├── public<br>
│   ├── images<br>
│   ├── javascripts<br>
│   └── stylesheets<br>
│       └── style.css<br>
├── routes<br>
│   ├── index.js<br>
│   └── users.js<br>
└── views<br>
    ├── error.jade<br>
    ├── index.jade<br>
    └── layout.jade<br>
</code></p>

<p>Don&#39;t worry about the files and folders for now. Just know that we have created a boilerplate that could be used for a number of Node applications. This took care of the heavy lifting, adding common files and functions associated with all apps.</p>

<p>Notice the <em>package.json</em> file. This stores your project&#39;s dependencies, which we still need to install:</p>

<p><code>sh<br>
$ cd node-mongoose-form<br>
$ npm install<br>
</code></p>

<p>Now let&#39;s install one last dependency:</p>

<p><code>sh<br>
$ npm install mongoose --save<br>
</code></p>

<blockquote>
<p>The <code>--save</code> flag adds the dependencies and their versions to the <em>package.json</em> file. Take a look.</p>
</blockquote>

<h2>Sanity check</h2>

<p>Let&#39;s test our setup by running the app:</p>

<p><code>sh<br>
$ npm start<br>
</code></p>

<p>Navigate to <a href="http://localhost:3000/">http://localhost:3000/</a> in your browser and you should see the &quot;Welcome to Express&quot; text.</p>

<h3>Supervisor</h3>

<p>I highly recommend setting up <a href="https://github.com/isaacs/node-supervisor">Supervisor</a> so that you can run your app and watch for code changes. Check out the above link to learn more.</p>

<p><code>sh<br>
$ npm install supervisor -g<br>
</code></p>

<p>Kill the server by pressing CTRL-C.</p>

<p>Once installed, let&#39;s update the <em>package.json</em> file to utilize Supervisor to run our program.</p>

<p>Simply change this-</p>

<p><code>javascript<br>
&quot;scripts&quot;: {<br>
  &quot;start&quot;: &quot;node ./bin/www&quot;<br>
},<br>
</code></p>

<p>To this:</p>

<p><code>javascript<br>
&quot;scripts&quot;: {<br>
  &quot;start&quot;: &quot;supervisor ./bin/www&quot;<br>
},<br>
</code></p>

<p>Let&#39;s test again:</p>

<p><code>sh<br>
$ npm start<br>
</code></p>

<p>In your terminal you should see:</p>

<p><code>sh<br>
Watching directory &#39;node-mongoose-form&#39; for changes.<br>
</code></p>

<p>If you see that, you know it&#39;s working right. Essentially, Supervisor is watching that directory for code changes, and if they do occur, then it will refresh your app for you so you don&#39;t have to constantly kill the server then start it back up. It saves a lot of time and keystrokes.</p>

<p>Awesome. With the setup out of the way, let&#39;s get our hands dirty and actually build something!</p>

<h2>Routes</h2>

<p>Grab your favorite text editor, and then open the main file, <em>app.js</em>, which houses all of the business logic. Take a look at the routes:</p>

<p><code>javascript<br>
app.use(&#39;/&#39;, routes);<br>
app.use(&#39;/users&#39;, users);<br>
</code></p>

<p>Understanding how routes work as well as how to trace all the files associated with an individual route is an important skill to learn. You&#39;ll be able to approach most applications and understand how they work just by starting with the routes.</p>

<p>Let&#39;s look at this route:</p>

<p><code>javascript<br>
app.use(&#39;/users&#39;, users)<br>
</code></p>

<p>Here, we know that this route is associated with the <code>/users</code> endpoint. What&#39;s an endpoint? Simply navigate to <a href="http://localhost:3000/users">http://localhost:3000/users</a>.</p>

<p>So the end user navigates to that endpoint and expects <em>something</em> to happen. That could mean some HTML is rendered or perhaps JSON is returned. That&#39;s not important at this point. For now, let&#39;s look at how Node handles that logic for &quot;handling routes&quot;.</p>

<p>Also, within that route, you can see the variable <code>users</code>. Where is this file this file? It&#39;s at the top, and it loads in another file within our app:</p>

<p><code>javascript<br>
var users = require(&#39;./routes/users&#39;);<br>
</code></p>

<p>Open that file:</p>

<p>```javascript<br>
var express = require(&#39;express&#39;);<br>
var router = express.Router();</p>

<p>/* GET users listing. */<br>
router.get(&#39;/&#39;, function(req, res) {<br>
  res.send(&#39;respond with a resource&#39;);<br>
});</p>

<p>module.exports = router;<br>
```</p>

<p>What&#39;s happening here? We won&#39;t touch everything but essentially when that endpoint is hit it responds by sending text in the form of a response to the end user - &quot;respond with a resource&quot;. Now, of course you don&#39;t always have to send text. You could respond with a template or view like a Jade file that gets rendered into HTML. We&#39;ll look at how this works in just a minute when we add our own routes.</p>

<p><strong>Make sure you understand everything in this section before moving on. This is very important</strong>.</p>

<h3>Add a new route</h3>

<p>Let&#39;s now add a new route that renders an HTML form to the end user.</p>

<p>Start by adding the route handler in the <em>app.js</em> file:</p>

<p><code>javascript<br>
app.use(&#39;/form&#39;, form);<br>
</code></p>

<blockquote>
<p>Remember this simply means <code>app.use(&#39;/ENDPOINT&#39;, VARIABLE_NAME);</code>,</p>
</blockquote>

<p>Use the <code>form</code> variable to require a JS file within our routes folder.</p>

<p><code>javascript<br>
var form = require(&#39;./routes/form&#39;);<br>
</code></p>

<p>Take a look in the terminal. You should see an error, indicating Node can&#39;t find that &#39;./routes/form&#39; module. We need to create it!</p>

<p>Create that JS file/module by saving an empty file called <em>form.js</em> to the &quot;routes&quot; directory. Add the following code:</p>

<p>```javascript<br>
var express = require(&#39;express&#39;);<br>
var router = express.Router();</p>

<p>/* GET form. */<br>
router.get(&#39;/&#39;, function(req, res) {<br>
  res.send(&#39;My funky form&#39;);<br>
});</p>

<p>module.exports = router;<br>
```</p>

<blockquote>
<p>Remember what this code <code>res.send(&#39;My funky form&#39;);</code> should do? If not, review the previous section.</p>
</blockquote>

<p>Navigate to <a href="http://localhost:3000/form">http://localhost:3000/form</a>. You should see the text &quot;&#39;My funky form&quot; on the page. Sweet.</p>

<h2>Jade</h2>

<p>Jade is a templating language, which compiles down to HTML. It makes it easy to separate logic from markup.</p>

<p>Take a quick look at the <em>layout.jade</em> and <em>index.jade</em> files within the &quot;views&quot; folder. There&#39;s a relationship between those two files. It&#39;s called inheritance. We define the base structure in the <em>layout</em> file, which contains common structure that can be reused in multiple places.</p>

<p>Do you see the <code>block</code> keyword?</p>

<p>What really happens when the <em>index</em> file is rendered is that it first inherits the base template because of the <code>extends</code> keywords. So, the <em>layout</em> template then gets rendered, which eventually pulls in the child template, overwriting the <code>block</code> keyword with:</p>

<p><code>html<br>
h1= title<br>
  p Welcome to #{title}<br>
</code></p>

<p>Hope that makes sense. If not, check out <a href="http://www.learnjade.com/tour/template-inheritance/">this</a> resource for more info.</p>

<h3>Setup <em>form.jade</em></h3>

<p>Create a new file called &quot;form.jade&quot; in the &quot;views&quot; directory, and then add the following code:</p>

<p>```html<br>
extends layout</p>

<p>block content<br>
  h1= title<br>
  p Welcome to #{title}<br>
```</p>

<p>The same thing is happening here with inheritance. If you&#39;re unfamiliar with Jade syntax, <code>title</code> is essentially a variable, which we can pass in from <code>./routes/form.js</code>.</p>

<p>Update <code>./routes/form.js</code> by changing-</p>

<p><code>javascript<br>
res.send(&#39;My funky form&#39;);<br>
</code></p>

<p>To:</p>

<p><code>javascript<br>
res.render(&#39;form&#39;, { title: &#39;My funky form&#39; });<br>
</code></p>

<p>This just says, &quot;When a user hits the <code>/form</code> endpoint, render the <em>form.jade</em> file and pass in <code>My funky form</code> as the title.&quot;</p>

<blockquote>
<p>Keep in mind that all Jade files are converted to HTML. Browsers can&#39;t read the Jade syntax, so it must be in HTML by the time the end user sees it.</p>
</blockquote>

<p>Ready to test? Simple refresh <a href="http://localhost:3000/form">http://localhost:3000/form</a>.</p>

<p>Did it work? If yes, move on. If not, go back through this section and review. Look in your terminal as well to see the error(s). If you&#39;re having problems, don&#39;t beat yourself up. It&#39;s all part of learning!</p>

<h3>Update <em>form.jade</em></h3>

<p>So, let&#39;s update the Jade syntax to load a form.</p>

<p>```html<br>
extends layout</p>

<p>block content<br>
  //- passed into layout.jade when form.jade is rendered<br>
  block content<br>
    h1= title<br>
    form(method=&quot;post&quot; action=&quot;/create&quot;)<br>
      label(for=&quot;comment&quot;) Got something to say:<br>
      input(type=&quot;text&quot;, name=&quot;comment&quot;, value=comment)<br>
      input(type=&quot;submit&quot;, value=&quot;Save&quot;)<br>
```</p>

<p>I&#39;m not going to touch on all the Jade syntax, but essentially, we have just a basic HTML form to submit comments.</p>

<p>Refresh your browser. Do you see the form? Try clicking save. What happens? Well, you just tried to send a POST request to the <code>/create</code> endpoint, which does not exist. Let&#39;s set it up.</p>

<h2>Add route handler for <code>/create</code></h2>

<p>Open <em>app.js</em> and add a new route:</p>

<p><code>javascript<br>
app.use(&#39;/create&#39;, form);<br>
</code></p>

<blockquote>
<p>Notice how we&#39;re using the same <code>form</code> variable. What does this mean?</p>
</blockquote>

<p>Open <em>form.js</em> to add the logic for this new route:</p>

<p>```javascript<br>
var express = require(&#39;express&#39;);<br>
var router = express.Router();</p>

<p>/* GET form. */<br>
router.get(&#39;/&#39;, function(req, res) {<br>
  res.render(&#39;form&#39;, { title: &#39;My funky form&#39; });<br>
});</p>

<p>/* POST form. */<br>
router.post(&#39;/&#39;, function(req, res) {<br>
  console.log(req.body.comment);<br>
  res.redirect(&#39;form&#39;);<br>
});</p>

<p>module.exports = router;<br>
```</p>

<p>1Test this out again. Now, when you submit the form, we have the <code>/create</code> endpoint setup, which then grabs the text from the input box via <code>req.body.comment</code>. Make sure the text is consoled to your terminal.</p>

<p>Okay. So, we are handling the routes, rendering the right template, let&#39;s now setup Mongoose to save the data from our form.</p>

<h2>Setup Mongoose</h2>

<p><a href="http://mongoosejs.com/">Mongoose</a> is awesome. Start with defining the Schema, which then maps to a collection in Mongo. It utilizes OOP.</p>

<p>Create a file called <em>database.js</em> in your app&#39;s root directory, then add the following code:</p>

<p>```javascript<br>
var mongoose = require(&#39;mongoose&#39;);<br>
var Schema   = mongoose.Schema;</p>

<p>var Comment = new Schema({<br>
    title : String,<br>
});</p>

<p>mongoose.model(&#39;comments&#39;, Comment);</p>

<p>mongoose.connect(&#39;mongodb://localhost/node-comment&#39;);<br>
```</p>

<p>Here, we required/included the Mongoose library along with a reference to the <code>Schema()</code> method. As said, you always start with defining the schema, then we linked it to collection called &quot;comments&quot;. Finally, we opened a connection to an instance of our local MongoDB.</p>

<blockquote>
<p>If you don&#39;t have the MongoDB server running. Do so now. Open a new terminal window, and run the command <code>sudo mongod</code>.</p>
</blockquote>

<p>Next, open <em>app.js</em> and require the Mongoose config at the very top of the file:</p>

<p><code>javascript<br>
// mongoose config<br>
require(&#39;./database&#39;);<br>
</code></p>

<p>With Mongoose setup, we need to update <em>form.js</em> to create (via POST) and read (via GET) data from the Mongo collection.</p>

<h2>Handling form GET requests</h2>

<p>Open <em>form.js</em>. Require Mongoose as well as the <code>comments</code> model, which we already created:</p>

<p><code>javascript<br>
var mongoose = require(&#39;mongoose&#39;);<br>
var Comment = mongoose.model(&#39;comments&#39;);<br>
</code></p>

<p>Now, update the function handling GET requests:</p>

<p><code>javascript<br>
/* GET form. */<br>
router.get(&#39;/&#39;, function(req, res) {<br>
  Comment.find(function(err, comments){<br>
    console.log(comments)<br>
    res.render(<br>
      &#39;form&#39;,<br>
      {title : &#39;My funky form&#39;, comments : comments}<br>
    );<br>
  });<br>
});<br>
</code></p>

<p><code>Comment.find()</code> grabs all comments from the Mongo collection, which we assign to the variable <code>comments</code>. We can now use that variable in our Jade file.</p>

<h2>Update <em>form.jade</em> to display comments</h2>

<p>Let&#39;s add a loop to iterate through the comments and then display the <code>title</code> key from the collection.</p>

<p>```html<br>
extends layout</p>

<p>block content<br>
  //- passed into layout.jade when form.jade is rendered<br>
  block content<br>
    h1= title<br>
    form(method=&quot;post&quot; action=&quot;/create&quot;)<br>
      label(for=&quot;comment&quot;) Got something to say:<br>
      input(type=&quot;text&quot;, name=&quot;comment&quot;, value=comment)<br>
      input(type=&quot;submit&quot;, value=&quot;Save&quot;)<br>
    br<br>
    - for comment in comments<br>
      p= comment.title<br>
```</p>

<blockquote>
<p>Do you remember where we set the <code>title</code> key? Check out the database schema in <em>database.js</em>.</p>
</blockquote>

<p>Before this will actually work - e.g., display comments - we first need to add the logic to insert data into the Mongo collection.</p>

<h2>Handling form POST requests</h2>

<p>Back in <em>form.js</em>, update the function handling POST requests:</p>

<p><code>javascript<br>
/* POST form. */<br>
router.post(&#39;/&#39;, function(req, res) {<br>
  new Comment({title : req.body.comment})<br>
  .save(function(err, comment) {<br>
    console.log(comment)<br>
    res.redirect(&#39;form&#39;);<br>
  });<br>
});<br>
</code></p>

<p>The simply saves a new comment, which again is grabbed from the form via <code>req.body.comment</code>.</p>

<h2>Sanity Check</h2>

<p>Refresh you app. Add some comments. If you&#39;ve done everything correctly, the comments should be displayed beneath the form.</p>

<h2>Conclusion</h2>

<p>That&#39;s it. Grab the code from the <a href="https://github.com/mjhea0/node-form-refresh">repository</a>. Cheers!</p>
]]></content>
  </entry>
  
</feed>
